// Copyright 2024 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/pingcap/tidb-operator/pkg/controllers/common (interfaces: StatusPersister,InstanceCondSuspendedUpdater,InstanceCondReadyUpdater,InstanceCondSyncedUpdater,GroupCondSuspendedUpdater,GroupCondReadyUpdater,GroupCondSyncedUpdater,GroupStatusSelectorUpdater,StatusRevisionAndReplicasUpdater)

// Package common is a generated GoMock package.
package common

import (
	reflect "reflect"

	v1alpha1 "github.com/pingcap/tidb-operator/api/v2/core/v1alpha1"
	client "github.com/pingcap/tidb-operator/pkg/client"
	gomock "go.uber.org/mock/gomock"
	v1 "k8s.io/api/core/v1"
)

// MockStatusPersister is a mock of StatusPersister interface.
type MockStatusPersister[T client.Object] struct {
	ctrl     *gomock.Controller
	recorder *MockStatusPersisterMockRecorder[T]
	isgomock struct{}
}

// MockStatusPersisterMockRecorder is the mock recorder for MockStatusPersister.
type MockStatusPersisterMockRecorder[T client.Object] struct {
	mock *MockStatusPersister[T]
}

// NewMockStatusPersister creates a new mock instance.
func NewMockStatusPersister[T client.Object](ctrl *gomock.Controller) *MockStatusPersister[T] {
	mock := &MockStatusPersister[T]{ctrl: ctrl}
	mock.recorder = &MockStatusPersisterMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStatusPersister[T]) EXPECT() *MockStatusPersisterMockRecorder[T] {
	return m.recorder
}

// IsStatusChanged mocks base method.
func (m *MockStatusPersister[T]) IsStatusChanged() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsStatusChanged")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsStatusChanged indicates an expected call of IsStatusChanged.
func (mr *MockStatusPersisterMockRecorder[T]) IsStatusChanged() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsStatusChanged", reflect.TypeOf((*MockStatusPersister[T])(nil).IsStatusChanged))
}

// Object mocks base method.
func (m *MockStatusPersister[T]) Object() T {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Object")
	ret0, _ := ret[0].(T)
	return ret0
}

// Object indicates an expected call of Object.
func (mr *MockStatusPersisterMockRecorder[T]) Object() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Object", reflect.TypeOf((*MockStatusPersister[T])(nil).Object))
}

// MockInstanceCondSuspendedUpdater is a mock of InstanceCondSuspendedUpdater interface.
type MockInstanceCondSuspendedUpdater[T client.Object] struct {
	ctrl     *gomock.Controller
	recorder *MockInstanceCondSuspendedUpdaterMockRecorder[T]
	isgomock struct{}
}

// MockInstanceCondSuspendedUpdaterMockRecorder is the mock recorder for MockInstanceCondSuspendedUpdater.
type MockInstanceCondSuspendedUpdaterMockRecorder[T client.Object] struct {
	mock *MockInstanceCondSuspendedUpdater[T]
}

// NewMockInstanceCondSuspendedUpdater creates a new mock instance.
func NewMockInstanceCondSuspendedUpdater[T client.Object](ctrl *gomock.Controller) *MockInstanceCondSuspendedUpdater[T] {
	mock := &MockInstanceCondSuspendedUpdater[T]{ctrl: ctrl}
	mock.recorder = &MockInstanceCondSuspendedUpdaterMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockInstanceCondSuspendedUpdater[T]) EXPECT() *MockInstanceCondSuspendedUpdaterMockRecorder[T] {
	return m.recorder
}

// Cluster mocks base method.
func (m *MockInstanceCondSuspendedUpdater[T]) Cluster() *v1alpha1.Cluster {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Cluster")
	ret0, _ := ret[0].(*v1alpha1.Cluster)
	return ret0
}

// Cluster indicates an expected call of Cluster.
func (mr *MockInstanceCondSuspendedUpdaterMockRecorder[T]) Cluster() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cluster", reflect.TypeOf((*MockInstanceCondSuspendedUpdater[T])(nil).Cluster))
}

// IsPodTerminating mocks base method.
func (m *MockInstanceCondSuspendedUpdater[T]) IsPodTerminating() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsPodTerminating")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsPodTerminating indicates an expected call of IsPodTerminating.
func (mr *MockInstanceCondSuspendedUpdaterMockRecorder[T]) IsPodTerminating() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsPodTerminating", reflect.TypeOf((*MockInstanceCondSuspendedUpdater[T])(nil).IsPodTerminating))
}

// Object mocks base method.
func (m *MockInstanceCondSuspendedUpdater[T]) Object() T {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Object")
	ret0, _ := ret[0].(T)
	return ret0
}

// Object indicates an expected call of Object.
func (mr *MockInstanceCondSuspendedUpdaterMockRecorder[T]) Object() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Object", reflect.TypeOf((*MockInstanceCondSuspendedUpdater[T])(nil).Object))
}

// Pod mocks base method.
func (m *MockInstanceCondSuspendedUpdater[T]) Pod() *v1.Pod {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Pod")
	ret0, _ := ret[0].(*v1.Pod)
	return ret0
}

// Pod indicates an expected call of Pod.
func (mr *MockInstanceCondSuspendedUpdaterMockRecorder[T]) Pod() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Pod", reflect.TypeOf((*MockInstanceCondSuspendedUpdater[T])(nil).Pod))
}

// SetStatusChanged mocks base method.
func (m *MockInstanceCondSuspendedUpdater[T]) SetStatusChanged() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetStatusChanged")
}

// SetStatusChanged indicates an expected call of SetStatusChanged.
func (mr *MockInstanceCondSuspendedUpdaterMockRecorder[T]) SetStatusChanged() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetStatusChanged", reflect.TypeOf((*MockInstanceCondSuspendedUpdater[T])(nil).SetStatusChanged))
}

// MockInstanceCondReadyUpdater is a mock of InstanceCondReadyUpdater interface.
type MockInstanceCondReadyUpdater[T client.Object] struct {
	ctrl     *gomock.Controller
	recorder *MockInstanceCondReadyUpdaterMockRecorder[T]
	isgomock struct{}
}

// MockInstanceCondReadyUpdaterMockRecorder is the mock recorder for MockInstanceCondReadyUpdater.
type MockInstanceCondReadyUpdaterMockRecorder[T client.Object] struct {
	mock *MockInstanceCondReadyUpdater[T]
}

// NewMockInstanceCondReadyUpdater creates a new mock instance.
func NewMockInstanceCondReadyUpdater[T client.Object](ctrl *gomock.Controller) *MockInstanceCondReadyUpdater[T] {
	mock := &MockInstanceCondReadyUpdater[T]{ctrl: ctrl}
	mock.recorder = &MockInstanceCondReadyUpdaterMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockInstanceCondReadyUpdater[T]) EXPECT() *MockInstanceCondReadyUpdaterMockRecorder[T] {
	return m.recorder
}

// IsHealthy mocks base method.
func (m *MockInstanceCondReadyUpdater[T]) IsHealthy() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsHealthy")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsHealthy indicates an expected call of IsHealthy.
func (mr *MockInstanceCondReadyUpdaterMockRecorder[T]) IsHealthy() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsHealthy", reflect.TypeOf((*MockInstanceCondReadyUpdater[T])(nil).IsHealthy))
}

// IsPodTerminating mocks base method.
func (m *MockInstanceCondReadyUpdater[T]) IsPodTerminating() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsPodTerminating")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsPodTerminating indicates an expected call of IsPodTerminating.
func (mr *MockInstanceCondReadyUpdaterMockRecorder[T]) IsPodTerminating() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsPodTerminating", reflect.TypeOf((*MockInstanceCondReadyUpdater[T])(nil).IsPodTerminating))
}

// Object mocks base method.
func (m *MockInstanceCondReadyUpdater[T]) Object() T {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Object")
	ret0, _ := ret[0].(T)
	return ret0
}

// Object indicates an expected call of Object.
func (mr *MockInstanceCondReadyUpdaterMockRecorder[T]) Object() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Object", reflect.TypeOf((*MockInstanceCondReadyUpdater[T])(nil).Object))
}

// Pod mocks base method.
func (m *MockInstanceCondReadyUpdater[T]) Pod() *v1.Pod {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Pod")
	ret0, _ := ret[0].(*v1.Pod)
	return ret0
}

// Pod indicates an expected call of Pod.
func (mr *MockInstanceCondReadyUpdaterMockRecorder[T]) Pod() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Pod", reflect.TypeOf((*MockInstanceCondReadyUpdater[T])(nil).Pod))
}

// SetStatusChanged mocks base method.
func (m *MockInstanceCondReadyUpdater[T]) SetStatusChanged() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetStatusChanged")
}

// SetStatusChanged indicates an expected call of SetStatusChanged.
func (mr *MockInstanceCondReadyUpdaterMockRecorder[T]) SetStatusChanged() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetStatusChanged", reflect.TypeOf((*MockInstanceCondReadyUpdater[T])(nil).SetStatusChanged))
}

// MockInstanceCondSyncedUpdater is a mock of InstanceCondSyncedUpdater interface.
type MockInstanceCondSyncedUpdater[T client.Object] struct {
	ctrl     *gomock.Controller
	recorder *MockInstanceCondSyncedUpdaterMockRecorder[T]
	isgomock struct{}
}

// MockInstanceCondSyncedUpdaterMockRecorder is the mock recorder for MockInstanceCondSyncedUpdater.
type MockInstanceCondSyncedUpdaterMockRecorder[T client.Object] struct {
	mock *MockInstanceCondSyncedUpdater[T]
}

// NewMockInstanceCondSyncedUpdater creates a new mock instance.
func NewMockInstanceCondSyncedUpdater[T client.Object](ctrl *gomock.Controller) *MockInstanceCondSyncedUpdater[T] {
	mock := &MockInstanceCondSyncedUpdater[T]{ctrl: ctrl}
	mock.recorder = &MockInstanceCondSyncedUpdaterMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockInstanceCondSyncedUpdater[T]) EXPECT() *MockInstanceCondSyncedUpdaterMockRecorder[T] {
	return m.recorder
}

// Cluster mocks base method.
func (m *MockInstanceCondSyncedUpdater[T]) Cluster() *v1alpha1.Cluster {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Cluster")
	ret0, _ := ret[0].(*v1alpha1.Cluster)
	return ret0
}

// Cluster indicates an expected call of Cluster.
func (mr *MockInstanceCondSyncedUpdaterMockRecorder[T]) Cluster() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cluster", reflect.TypeOf((*MockInstanceCondSyncedUpdater[T])(nil).Cluster))
}

// IsPodTerminating mocks base method.
func (m *MockInstanceCondSyncedUpdater[T]) IsPodTerminating() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsPodTerminating")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsPodTerminating indicates an expected call of IsPodTerminating.
func (mr *MockInstanceCondSyncedUpdaterMockRecorder[T]) IsPodTerminating() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsPodTerminating", reflect.TypeOf((*MockInstanceCondSyncedUpdater[T])(nil).IsPodTerminating))
}

// Object mocks base method.
func (m *MockInstanceCondSyncedUpdater[T]) Object() T {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Object")
	ret0, _ := ret[0].(T)
	return ret0
}

// Object indicates an expected call of Object.
func (mr *MockInstanceCondSyncedUpdaterMockRecorder[T]) Object() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Object", reflect.TypeOf((*MockInstanceCondSyncedUpdater[T])(nil).Object))
}

// Pod mocks base method.
func (m *MockInstanceCondSyncedUpdater[T]) Pod() *v1.Pod {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Pod")
	ret0, _ := ret[0].(*v1.Pod)
	return ret0
}

// Pod indicates an expected call of Pod.
func (mr *MockInstanceCondSyncedUpdaterMockRecorder[T]) Pod() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Pod", reflect.TypeOf((*MockInstanceCondSyncedUpdater[T])(nil).Pod))
}

// SetStatusChanged mocks base method.
func (m *MockInstanceCondSyncedUpdater[T]) SetStatusChanged() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetStatusChanged")
}

// SetStatusChanged indicates an expected call of SetStatusChanged.
func (mr *MockInstanceCondSyncedUpdaterMockRecorder[T]) SetStatusChanged() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetStatusChanged", reflect.TypeOf((*MockInstanceCondSyncedUpdater[T])(nil).SetStatusChanged))
}

// MockGroupCondSuspendedUpdater is a mock of GroupCondSuspendedUpdater interface.
type MockGroupCondSuspendedUpdater[G client.Object, I client.Object] struct {
	ctrl     *gomock.Controller
	recorder *MockGroupCondSuspendedUpdaterMockRecorder[G, I]
	isgomock struct{}
}

// MockGroupCondSuspendedUpdaterMockRecorder is the mock recorder for MockGroupCondSuspendedUpdater.
type MockGroupCondSuspendedUpdaterMockRecorder[G client.Object, I client.Object] struct {
	mock *MockGroupCondSuspendedUpdater[G, I]
}

// NewMockGroupCondSuspendedUpdater creates a new mock instance.
func NewMockGroupCondSuspendedUpdater[G client.Object, I client.Object](ctrl *gomock.Controller) *MockGroupCondSuspendedUpdater[G, I] {
	mock := &MockGroupCondSuspendedUpdater[G, I]{ctrl: ctrl}
	mock.recorder = &MockGroupCondSuspendedUpdaterMockRecorder[G, I]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGroupCondSuspendedUpdater[G, I]) EXPECT() *MockGroupCondSuspendedUpdaterMockRecorder[G, I] {
	return m.recorder
}

// Cluster mocks base method.
func (m *MockGroupCondSuspendedUpdater[G, I]) Cluster() *v1alpha1.Cluster {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Cluster")
	ret0, _ := ret[0].(*v1alpha1.Cluster)
	return ret0
}

// Cluster indicates an expected call of Cluster.
func (mr *MockGroupCondSuspendedUpdaterMockRecorder[G, I]) Cluster() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cluster", reflect.TypeOf((*MockGroupCondSuspendedUpdater[G, I])(nil).Cluster))
}

// InstanceSlice mocks base method.
func (m *MockGroupCondSuspendedUpdater[G, I]) InstanceSlice() []I {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InstanceSlice")
	ret0, _ := ret[0].([]I)
	return ret0
}

// InstanceSlice indicates an expected call of InstanceSlice.
func (mr *MockGroupCondSuspendedUpdaterMockRecorder[G, I]) InstanceSlice() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InstanceSlice", reflect.TypeOf((*MockGroupCondSuspendedUpdater[G, I])(nil).InstanceSlice))
}

// Object mocks base method.
func (m *MockGroupCondSuspendedUpdater[G, I]) Object() G {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Object")
	ret0, _ := ret[0].(G)
	return ret0
}

// Object indicates an expected call of Object.
func (mr *MockGroupCondSuspendedUpdaterMockRecorder[G, I]) Object() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Object", reflect.TypeOf((*MockGroupCondSuspendedUpdater[G, I])(nil).Object))
}

// SetStatusChanged mocks base method.
func (m *MockGroupCondSuspendedUpdater[G, I]) SetStatusChanged() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetStatusChanged")
}

// SetStatusChanged indicates an expected call of SetStatusChanged.
func (mr *MockGroupCondSuspendedUpdaterMockRecorder[G, I]) SetStatusChanged() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetStatusChanged", reflect.TypeOf((*MockGroupCondSuspendedUpdater[G, I])(nil).SetStatusChanged))
}

// MockGroupCondReadyUpdater is a mock of GroupCondReadyUpdater interface.
type MockGroupCondReadyUpdater[G client.Object, I client.Object] struct {
	ctrl     *gomock.Controller
	recorder *MockGroupCondReadyUpdaterMockRecorder[G, I]
	isgomock struct{}
}

// MockGroupCondReadyUpdaterMockRecorder is the mock recorder for MockGroupCondReadyUpdater.
type MockGroupCondReadyUpdaterMockRecorder[G client.Object, I client.Object] struct {
	mock *MockGroupCondReadyUpdater[G, I]
}

// NewMockGroupCondReadyUpdater creates a new mock instance.
func NewMockGroupCondReadyUpdater[G client.Object, I client.Object](ctrl *gomock.Controller) *MockGroupCondReadyUpdater[G, I] {
	mock := &MockGroupCondReadyUpdater[G, I]{ctrl: ctrl}
	mock.recorder = &MockGroupCondReadyUpdaterMockRecorder[G, I]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGroupCondReadyUpdater[G, I]) EXPECT() *MockGroupCondReadyUpdaterMockRecorder[G, I] {
	return m.recorder
}

// InstanceSlice mocks base method.
func (m *MockGroupCondReadyUpdater[G, I]) InstanceSlice() []I {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InstanceSlice")
	ret0, _ := ret[0].([]I)
	return ret0
}

// InstanceSlice indicates an expected call of InstanceSlice.
func (mr *MockGroupCondReadyUpdaterMockRecorder[G, I]) InstanceSlice() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InstanceSlice", reflect.TypeOf((*MockGroupCondReadyUpdater[G, I])(nil).InstanceSlice))
}

// Object mocks base method.
func (m *MockGroupCondReadyUpdater[G, I]) Object() G {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Object")
	ret0, _ := ret[0].(G)
	return ret0
}

// Object indicates an expected call of Object.
func (mr *MockGroupCondReadyUpdaterMockRecorder[G, I]) Object() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Object", reflect.TypeOf((*MockGroupCondReadyUpdater[G, I])(nil).Object))
}

// SetStatusChanged mocks base method.
func (m *MockGroupCondReadyUpdater[G, I]) SetStatusChanged() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetStatusChanged")
}

// SetStatusChanged indicates an expected call of SetStatusChanged.
func (mr *MockGroupCondReadyUpdaterMockRecorder[G, I]) SetStatusChanged() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetStatusChanged", reflect.TypeOf((*MockGroupCondReadyUpdater[G, I])(nil).SetStatusChanged))
}

// MockGroupCondSyncedUpdater is a mock of GroupCondSyncedUpdater interface.
type MockGroupCondSyncedUpdater[G client.Object, I client.Object] struct {
	ctrl     *gomock.Controller
	recorder *MockGroupCondSyncedUpdaterMockRecorder[G, I]
	isgomock struct{}
}

// MockGroupCondSyncedUpdaterMockRecorder is the mock recorder for MockGroupCondSyncedUpdater.
type MockGroupCondSyncedUpdaterMockRecorder[G client.Object, I client.Object] struct {
	mock *MockGroupCondSyncedUpdater[G, I]
}

// NewMockGroupCondSyncedUpdater creates a new mock instance.
func NewMockGroupCondSyncedUpdater[G client.Object, I client.Object](ctrl *gomock.Controller) *MockGroupCondSyncedUpdater[G, I] {
	mock := &MockGroupCondSyncedUpdater[G, I]{ctrl: ctrl}
	mock.recorder = &MockGroupCondSyncedUpdaterMockRecorder[G, I]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGroupCondSyncedUpdater[G, I]) EXPECT() *MockGroupCondSyncedUpdaterMockRecorder[G, I] {
	return m.recorder
}

// InstanceSlice mocks base method.
func (m *MockGroupCondSyncedUpdater[G, I]) InstanceSlice() []I {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InstanceSlice")
	ret0, _ := ret[0].([]I)
	return ret0
}

// InstanceSlice indicates an expected call of InstanceSlice.
func (mr *MockGroupCondSyncedUpdaterMockRecorder[G, I]) InstanceSlice() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InstanceSlice", reflect.TypeOf((*MockGroupCondSyncedUpdater[G, I])(nil).InstanceSlice))
}

// Object mocks base method.
func (m *MockGroupCondSyncedUpdater[G, I]) Object() G {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Object")
	ret0, _ := ret[0].(G)
	return ret0
}

// Object indicates an expected call of Object.
func (mr *MockGroupCondSyncedUpdaterMockRecorder[G, I]) Object() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Object", reflect.TypeOf((*MockGroupCondSyncedUpdater[G, I])(nil).Object))
}

// Revision mocks base method.
func (m *MockGroupCondSyncedUpdater[G, I]) Revision() (string, string, int32) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Revision")
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(int32)
	return ret0, ret1, ret2
}

// Revision indicates an expected call of Revision.
func (mr *MockGroupCondSyncedUpdaterMockRecorder[G, I]) Revision() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Revision", reflect.TypeOf((*MockGroupCondSyncedUpdater[G, I])(nil).Revision))
}

// SetStatusChanged mocks base method.
func (m *MockGroupCondSyncedUpdater[G, I]) SetStatusChanged() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetStatusChanged")
}

// SetStatusChanged indicates an expected call of SetStatusChanged.
func (mr *MockGroupCondSyncedUpdaterMockRecorder[G, I]) SetStatusChanged() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetStatusChanged", reflect.TypeOf((*MockGroupCondSyncedUpdater[G, I])(nil).SetStatusChanged))
}

// MockGroupStatusSelectorUpdater is a mock of GroupStatusSelectorUpdater interface.
type MockGroupStatusSelectorUpdater[G client.Object] struct {
	ctrl     *gomock.Controller
	recorder *MockGroupStatusSelectorUpdaterMockRecorder[G]
	isgomock struct{}
}

// MockGroupStatusSelectorUpdaterMockRecorder is the mock recorder for MockGroupStatusSelectorUpdater.
type MockGroupStatusSelectorUpdaterMockRecorder[G client.Object] struct {
	mock *MockGroupStatusSelectorUpdater[G]
}

// NewMockGroupStatusSelectorUpdater creates a new mock instance.
func NewMockGroupStatusSelectorUpdater[G client.Object](ctrl *gomock.Controller) *MockGroupStatusSelectorUpdater[G] {
	mock := &MockGroupStatusSelectorUpdater[G]{ctrl: ctrl}
	mock.recorder = &MockGroupStatusSelectorUpdaterMockRecorder[G]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGroupStatusSelectorUpdater[G]) EXPECT() *MockGroupStatusSelectorUpdaterMockRecorder[G] {
	return m.recorder
}

// Object mocks base method.
func (m *MockGroupStatusSelectorUpdater[G]) Object() G {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Object")
	ret0, _ := ret[0].(G)
	return ret0
}

// Object indicates an expected call of Object.
func (mr *MockGroupStatusSelectorUpdaterMockRecorder[G]) Object() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Object", reflect.TypeOf((*MockGroupStatusSelectorUpdater[G])(nil).Object))
}

// SetStatusChanged mocks base method.
func (m *MockGroupStatusSelectorUpdater[G]) SetStatusChanged() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetStatusChanged")
}

// SetStatusChanged indicates an expected call of SetStatusChanged.
func (mr *MockGroupStatusSelectorUpdaterMockRecorder[G]) SetStatusChanged() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetStatusChanged", reflect.TypeOf((*MockGroupStatusSelectorUpdater[G])(nil).SetStatusChanged))
}

// MockStatusRevisionAndReplicasUpdater is a mock of StatusRevisionAndReplicasUpdater interface.
type MockStatusRevisionAndReplicasUpdater[G client.Object, I client.Object] struct {
	ctrl     *gomock.Controller
	recorder *MockStatusRevisionAndReplicasUpdaterMockRecorder[G, I]
	isgomock struct{}
}

// MockStatusRevisionAndReplicasUpdaterMockRecorder is the mock recorder for MockStatusRevisionAndReplicasUpdater.
type MockStatusRevisionAndReplicasUpdaterMockRecorder[G client.Object, I client.Object] struct {
	mock *MockStatusRevisionAndReplicasUpdater[G, I]
}

// NewMockStatusRevisionAndReplicasUpdater creates a new mock instance.
func NewMockStatusRevisionAndReplicasUpdater[G client.Object, I client.Object](ctrl *gomock.Controller) *MockStatusRevisionAndReplicasUpdater[G, I] {
	mock := &MockStatusRevisionAndReplicasUpdater[G, I]{ctrl: ctrl}
	mock.recorder = &MockStatusRevisionAndReplicasUpdaterMockRecorder[G, I]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStatusRevisionAndReplicasUpdater[G, I]) EXPECT() *MockStatusRevisionAndReplicasUpdaterMockRecorder[G, I] {
	return m.recorder
}

// InstanceSlice mocks base method.
func (m *MockStatusRevisionAndReplicasUpdater[G, I]) InstanceSlice() []I {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InstanceSlice")
	ret0, _ := ret[0].([]I)
	return ret0
}

// InstanceSlice indicates an expected call of InstanceSlice.
func (mr *MockStatusRevisionAndReplicasUpdaterMockRecorder[G, I]) InstanceSlice() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InstanceSlice", reflect.TypeOf((*MockStatusRevisionAndReplicasUpdater[G, I])(nil).InstanceSlice))
}

// Object mocks base method.
func (m *MockStatusRevisionAndReplicasUpdater[G, I]) Object() G {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Object")
	ret0, _ := ret[0].(G)
	return ret0
}

// Object indicates an expected call of Object.
func (mr *MockStatusRevisionAndReplicasUpdaterMockRecorder[G, I]) Object() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Object", reflect.TypeOf((*MockStatusRevisionAndReplicasUpdater[G, I])(nil).Object))
}

// Revision mocks base method.
func (m *MockStatusRevisionAndReplicasUpdater[G, I]) Revision() (string, string, int32) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Revision")
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(int32)
	return ret0, ret1, ret2
}

// Revision indicates an expected call of Revision.
func (mr *MockStatusRevisionAndReplicasUpdaterMockRecorder[G, I]) Revision() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Revision", reflect.TypeOf((*MockStatusRevisionAndReplicasUpdater[G, I])(nil).Revision))
}

// SetStatusChanged mocks base method.
func (m *MockStatusRevisionAndReplicasUpdater[G, I]) SetStatusChanged() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetStatusChanged")
}

// SetStatusChanged indicates an expected call of SetStatusChanged.
func (mr *MockStatusRevisionAndReplicasUpdaterMockRecorder[G, I]) SetStatusChanged() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetStatusChanged", reflect.TypeOf((*MockStatusRevisionAndReplicasUpdater[G, I])(nil).SetStatusChanged))
}
