// Copyright 2024 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/pingcap/tidb-operator/pkg/controllers/common (interfaces: StatusPersister,InstanceCondSuspendedUpdater,GroupCondSuspendedUpdater,GroupCondReadyUpdater,GroupCondSyncedUpdater,StatusRevisionAndReplicasUpdater)

// Package common is a generated GoMock package.
package common

import (
	reflect "reflect"

	v1alpha1 "github.com/pingcap/tidb-operator/api/v2/core/v1alpha1"
	runtime "github.com/pingcap/tidb-operator/pkg/runtime"
	gomock "go.uber.org/mock/gomock"
	v1 "k8s.io/api/core/v1"
	client "sigs.k8s.io/controller-runtime/pkg/client"
)

// MockStatusPersister is a mock of StatusPersister interface.
type MockStatusPersister[T client.Object] struct {
	ctrl     *gomock.Controller
	recorder *MockStatusPersisterMockRecorder[T]
	isgomock struct{}
}

// MockStatusPersisterMockRecorder is the mock recorder for MockStatusPersister.
type MockStatusPersisterMockRecorder[T client.Object] struct {
	mock *MockStatusPersister[T]
}

// NewMockStatusPersister creates a new mock instance.
func NewMockStatusPersister[T client.Object](ctrl *gomock.Controller) *MockStatusPersister[T] {
	mock := &MockStatusPersister[T]{ctrl: ctrl}
	mock.recorder = &MockStatusPersisterMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStatusPersister[T]) EXPECT() *MockStatusPersisterMockRecorder[T] {
	return m.recorder
}

// IsStatusChanged mocks base method.
func (m *MockStatusPersister[T]) IsStatusChanged() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsStatusChanged")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsStatusChanged indicates an expected call of IsStatusChanged.
func (mr *MockStatusPersisterMockRecorder[T]) IsStatusChanged() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsStatusChanged", reflect.TypeOf((*MockStatusPersister[T])(nil).IsStatusChanged))
}

// Object mocks base method.
func (m *MockStatusPersister[T]) Object() T {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Object")
	ret0, _ := ret[0].(T)
	return ret0
}

// Object indicates an expected call of Object.
func (mr *MockStatusPersisterMockRecorder[T]) Object() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Object", reflect.TypeOf((*MockStatusPersister[T])(nil).Object))
}

// MockInstanceCondSuspendedUpdater is a mock of InstanceCondSuspendedUpdater interface.
type MockInstanceCondSuspendedUpdater[T client.Object] struct {
	ctrl     *gomock.Controller
	recorder *MockInstanceCondSuspendedUpdaterMockRecorder[T]
	isgomock struct{}
}

// MockInstanceCondSuspendedUpdaterMockRecorder is the mock recorder for MockInstanceCondSuspendedUpdater.
type MockInstanceCondSuspendedUpdaterMockRecorder[T client.Object] struct {
	mock *MockInstanceCondSuspendedUpdater[T]
}

// NewMockInstanceCondSuspendedUpdater creates a new mock instance.
func NewMockInstanceCondSuspendedUpdater[T client.Object](ctrl *gomock.Controller) *MockInstanceCondSuspendedUpdater[T] {
	mock := &MockInstanceCondSuspendedUpdater[T]{ctrl: ctrl}
	mock.recorder = &MockInstanceCondSuspendedUpdaterMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockInstanceCondSuspendedUpdater[T]) EXPECT() *MockInstanceCondSuspendedUpdaterMockRecorder[T] {
	return m.recorder
}

// Cluster mocks base method.
func (m *MockInstanceCondSuspendedUpdater[T]) Cluster() *v1alpha1.Cluster {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Cluster")
	ret0, _ := ret[0].(*v1alpha1.Cluster)
	return ret0
}

// Cluster indicates an expected call of Cluster.
func (mr *MockInstanceCondSuspendedUpdaterMockRecorder[T]) Cluster() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cluster", reflect.TypeOf((*MockInstanceCondSuspendedUpdater[T])(nil).Cluster))
}

// Object mocks base method.
func (m *MockInstanceCondSuspendedUpdater[T]) Object() T {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Object")
	ret0, _ := ret[0].(T)
	return ret0
}

// Object indicates an expected call of Object.
func (mr *MockInstanceCondSuspendedUpdaterMockRecorder[T]) Object() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Object", reflect.TypeOf((*MockInstanceCondSuspendedUpdater[T])(nil).Object))
}

// Pod mocks base method.
func (m *MockInstanceCondSuspendedUpdater[T]) Pod() *v1.Pod {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Pod")
	ret0, _ := ret[0].(*v1.Pod)
	return ret0
}

// Pod indicates an expected call of Pod.
func (mr *MockInstanceCondSuspendedUpdaterMockRecorder[T]) Pod() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Pod", reflect.TypeOf((*MockInstanceCondSuspendedUpdater[T])(nil).Pod))
}

// SetStatusChanged mocks base method.
func (m *MockInstanceCondSuspendedUpdater[T]) SetStatusChanged() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetStatusChanged")
}

// SetStatusChanged indicates an expected call of SetStatusChanged.
func (mr *MockInstanceCondSuspendedUpdaterMockRecorder[T]) SetStatusChanged() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetStatusChanged", reflect.TypeOf((*MockInstanceCondSuspendedUpdater[T])(nil).SetStatusChanged))
}

// MockGroupCondSuspendedUpdater is a mock of GroupCondSuspendedUpdater interface.
type MockGroupCondSuspendedUpdater[T client.Object, I runtime.Instance] struct {
	ctrl     *gomock.Controller
	recorder *MockGroupCondSuspendedUpdaterMockRecorder[T, I]
	isgomock struct{}
}

// MockGroupCondSuspendedUpdaterMockRecorder is the mock recorder for MockGroupCondSuspendedUpdater.
type MockGroupCondSuspendedUpdaterMockRecorder[T client.Object, I runtime.Instance] struct {
	mock *MockGroupCondSuspendedUpdater[T, I]
}

// NewMockGroupCondSuspendedUpdater creates a new mock instance.
func NewMockGroupCondSuspendedUpdater[T client.Object, I runtime.Instance](ctrl *gomock.Controller) *MockGroupCondSuspendedUpdater[T, I] {
	mock := &MockGroupCondSuspendedUpdater[T, I]{ctrl: ctrl}
	mock.recorder = &MockGroupCondSuspendedUpdaterMockRecorder[T, I]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGroupCondSuspendedUpdater[T, I]) EXPECT() *MockGroupCondSuspendedUpdaterMockRecorder[T, I] {
	return m.recorder
}

// Cluster mocks base method.
func (m *MockGroupCondSuspendedUpdater[T, I]) Cluster() *v1alpha1.Cluster {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Cluster")
	ret0, _ := ret[0].(*v1alpha1.Cluster)
	return ret0
}

// Cluster indicates an expected call of Cluster.
func (mr *MockGroupCondSuspendedUpdaterMockRecorder[T, I]) Cluster() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cluster", reflect.TypeOf((*MockGroupCondSuspendedUpdater[T, I])(nil).Cluster))
}

// Object mocks base method.
func (m *MockGroupCondSuspendedUpdater[T, I]) Object() T {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Object")
	ret0, _ := ret[0].(T)
	return ret0
}

// Object indicates an expected call of Object.
func (mr *MockGroupCondSuspendedUpdaterMockRecorder[T, I]) Object() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Object", reflect.TypeOf((*MockGroupCondSuspendedUpdater[T, I])(nil).Object))
}

// SetStatusChanged mocks base method.
func (m *MockGroupCondSuspendedUpdater[T, I]) SetStatusChanged() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetStatusChanged")
}

// SetStatusChanged indicates an expected call of SetStatusChanged.
func (mr *MockGroupCondSuspendedUpdaterMockRecorder[T, I]) SetStatusChanged() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetStatusChanged", reflect.TypeOf((*MockGroupCondSuspendedUpdater[T, I])(nil).SetStatusChanged))
}

// Slice mocks base method.
func (m *MockGroupCondSuspendedUpdater[T, I]) Slice() []I {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Slice")
	ret0, _ := ret[0].([]I)
	return ret0
}

// Slice indicates an expected call of Slice.
func (mr *MockGroupCondSuspendedUpdaterMockRecorder[T, I]) Slice() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Slice", reflect.TypeOf((*MockGroupCondSuspendedUpdater[T, I])(nil).Slice))
}

// MockGroupCondReadyUpdater is a mock of GroupCondReadyUpdater interface.
type MockGroupCondReadyUpdater[T client.Object, I runtime.Instance] struct {
	ctrl     *gomock.Controller
	recorder *MockGroupCondReadyUpdaterMockRecorder[T, I]
	isgomock struct{}
}

// MockGroupCondReadyUpdaterMockRecorder is the mock recorder for MockGroupCondReadyUpdater.
type MockGroupCondReadyUpdaterMockRecorder[T client.Object, I runtime.Instance] struct {
	mock *MockGroupCondReadyUpdater[T, I]
}

// NewMockGroupCondReadyUpdater creates a new mock instance.
func NewMockGroupCondReadyUpdater[T client.Object, I runtime.Instance](ctrl *gomock.Controller) *MockGroupCondReadyUpdater[T, I] {
	mock := &MockGroupCondReadyUpdater[T, I]{ctrl: ctrl}
	mock.recorder = &MockGroupCondReadyUpdaterMockRecorder[T, I]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGroupCondReadyUpdater[T, I]) EXPECT() *MockGroupCondReadyUpdaterMockRecorder[T, I] {
	return m.recorder
}

// Object mocks base method.
func (m *MockGroupCondReadyUpdater[T, I]) Object() T {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Object")
	ret0, _ := ret[0].(T)
	return ret0
}

// Object indicates an expected call of Object.
func (mr *MockGroupCondReadyUpdaterMockRecorder[T, I]) Object() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Object", reflect.TypeOf((*MockGroupCondReadyUpdater[T, I])(nil).Object))
}

// SetStatusChanged mocks base method.
func (m *MockGroupCondReadyUpdater[T, I]) SetStatusChanged() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetStatusChanged")
}

// SetStatusChanged indicates an expected call of SetStatusChanged.
func (mr *MockGroupCondReadyUpdaterMockRecorder[T, I]) SetStatusChanged() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetStatusChanged", reflect.TypeOf((*MockGroupCondReadyUpdater[T, I])(nil).SetStatusChanged))
}

// Slice mocks base method.
func (m *MockGroupCondReadyUpdater[T, I]) Slice() []I {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Slice")
	ret0, _ := ret[0].([]I)
	return ret0
}

// Slice indicates an expected call of Slice.
func (mr *MockGroupCondReadyUpdaterMockRecorder[T, I]) Slice() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Slice", reflect.TypeOf((*MockGroupCondReadyUpdater[T, I])(nil).Slice))
}

// MockGroupCondSyncedUpdater is a mock of GroupCondSyncedUpdater interface.
type MockGroupCondSyncedUpdater[T client.Object, I runtime.Instance] struct {
	ctrl     *gomock.Controller
	recorder *MockGroupCondSyncedUpdaterMockRecorder[T, I]
	isgomock struct{}
}

// MockGroupCondSyncedUpdaterMockRecorder is the mock recorder for MockGroupCondSyncedUpdater.
type MockGroupCondSyncedUpdaterMockRecorder[T client.Object, I runtime.Instance] struct {
	mock *MockGroupCondSyncedUpdater[T, I]
}

// NewMockGroupCondSyncedUpdater creates a new mock instance.
func NewMockGroupCondSyncedUpdater[T client.Object, I runtime.Instance](ctrl *gomock.Controller) *MockGroupCondSyncedUpdater[T, I] {
	mock := &MockGroupCondSyncedUpdater[T, I]{ctrl: ctrl}
	mock.recorder = &MockGroupCondSyncedUpdaterMockRecorder[T, I]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGroupCondSyncedUpdater[T, I]) EXPECT() *MockGroupCondSyncedUpdaterMockRecorder[T, I] {
	return m.recorder
}

// Object mocks base method.
func (m *MockGroupCondSyncedUpdater[T, I]) Object() T {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Object")
	ret0, _ := ret[0].(T)
	return ret0
}

// Object indicates an expected call of Object.
func (mr *MockGroupCondSyncedUpdaterMockRecorder[T, I]) Object() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Object", reflect.TypeOf((*MockGroupCondSyncedUpdater[T, I])(nil).Object))
}

// Revision mocks base method.
func (m *MockGroupCondSyncedUpdater[T, I]) Revision() (string, string, int32) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Revision")
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(int32)
	return ret0, ret1, ret2
}

// Revision indicates an expected call of Revision.
func (mr *MockGroupCondSyncedUpdaterMockRecorder[T, I]) Revision() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Revision", reflect.TypeOf((*MockGroupCondSyncedUpdater[T, I])(nil).Revision))
}

// SetStatusChanged mocks base method.
func (m *MockGroupCondSyncedUpdater[T, I]) SetStatusChanged() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetStatusChanged")
}

// SetStatusChanged indicates an expected call of SetStatusChanged.
func (mr *MockGroupCondSyncedUpdaterMockRecorder[T, I]) SetStatusChanged() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetStatusChanged", reflect.TypeOf((*MockGroupCondSyncedUpdater[T, I])(nil).SetStatusChanged))
}

// Slice mocks base method.
func (m *MockGroupCondSyncedUpdater[T, I]) Slice() []I {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Slice")
	ret0, _ := ret[0].([]I)
	return ret0
}

// Slice indicates an expected call of Slice.
func (mr *MockGroupCondSyncedUpdaterMockRecorder[T, I]) Slice() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Slice", reflect.TypeOf((*MockGroupCondSyncedUpdater[T, I])(nil).Slice))
}

// MockStatusRevisionAndReplicasUpdater is a mock of StatusRevisionAndReplicasUpdater interface.
type MockStatusRevisionAndReplicasUpdater[T client.Object, I runtime.Instance] struct {
	ctrl     *gomock.Controller
	recorder *MockStatusRevisionAndReplicasUpdaterMockRecorder[T, I]
	isgomock struct{}
}

// MockStatusRevisionAndReplicasUpdaterMockRecorder is the mock recorder for MockStatusRevisionAndReplicasUpdater.
type MockStatusRevisionAndReplicasUpdaterMockRecorder[T client.Object, I runtime.Instance] struct {
	mock *MockStatusRevisionAndReplicasUpdater[T, I]
}

// NewMockStatusRevisionAndReplicasUpdater creates a new mock instance.
func NewMockStatusRevisionAndReplicasUpdater[T client.Object, I runtime.Instance](ctrl *gomock.Controller) *MockStatusRevisionAndReplicasUpdater[T, I] {
	mock := &MockStatusRevisionAndReplicasUpdater[T, I]{ctrl: ctrl}
	mock.recorder = &MockStatusRevisionAndReplicasUpdaterMockRecorder[T, I]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStatusRevisionAndReplicasUpdater[T, I]) EXPECT() *MockStatusRevisionAndReplicasUpdaterMockRecorder[T, I] {
	return m.recorder
}

// Object mocks base method.
func (m *MockStatusRevisionAndReplicasUpdater[T, I]) Object() T {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Object")
	ret0, _ := ret[0].(T)
	return ret0
}

// Object indicates an expected call of Object.
func (mr *MockStatusRevisionAndReplicasUpdaterMockRecorder[T, I]) Object() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Object", reflect.TypeOf((*MockStatusRevisionAndReplicasUpdater[T, I])(nil).Object))
}

// Revision mocks base method.
func (m *MockStatusRevisionAndReplicasUpdater[T, I]) Revision() (string, string, int32) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Revision")
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(int32)
	return ret0, ret1, ret2
}

// Revision indicates an expected call of Revision.
func (mr *MockStatusRevisionAndReplicasUpdaterMockRecorder[T, I]) Revision() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Revision", reflect.TypeOf((*MockStatusRevisionAndReplicasUpdater[T, I])(nil).Revision))
}

// SetStatusChanged mocks base method.
func (m *MockStatusRevisionAndReplicasUpdater[T, I]) SetStatusChanged() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetStatusChanged")
}

// SetStatusChanged indicates an expected call of SetStatusChanged.
func (mr *MockStatusRevisionAndReplicasUpdaterMockRecorder[T, I]) SetStatusChanged() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetStatusChanged", reflect.TypeOf((*MockStatusRevisionAndReplicasUpdater[T, I])(nil).SetStatusChanged))
}

// Slice mocks base method.
func (m *MockStatusRevisionAndReplicasUpdater[T, I]) Slice() []I {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Slice")
	ret0, _ := ret[0].([]I)
	return ret0
}

// Slice indicates an expected call of Slice.
func (mr *MockStatusRevisionAndReplicasUpdaterMockRecorder[T, I]) Slice() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Slice", reflect.TypeOf((*MockStatusRevisionAndReplicasUpdater[T, I])(nil).Slice))
}
