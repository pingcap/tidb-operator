//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Copyright 2024 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by runtime-gen. DO NOT EDIT.

package runtime

import (
	"unsafe"

	"github.com/pingcap/tidb-operator/api/v2/core/v1alpha1"
	metav1alpha1 "github.com/pingcap/tidb-operator/api/v2/meta/v1alpha1"
	"k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
)

type (
	TSO v1alpha1.TSO
)

type TSOTuple struct{}

var _ InstanceTuple[*v1alpha1.TSO, *TSO] = TSOTuple{}

func (TSOTuple) From(t *v1alpha1.TSO) *TSO {
	return FromTSO(t)
}

func (TSOTuple) FromSlice(t []*v1alpha1.TSO) []*TSO {
	return FromTSOSlice(t)
}

func (TSOTuple) To(t *TSO) *v1alpha1.TSO {
	return ToTSO(t)
}

func (TSOTuple) ToSlice(t []*TSO) []*v1alpha1.TSO {
	return ToTSOSlice(t)
}

func FromTSO(in *v1alpha1.TSO) *TSO {
	return (*TSO)(in)
}

func ToTSO(in *TSO) *v1alpha1.TSO {
	return (*v1alpha1.TSO)(in)
}

func FromTSOSlice(ins []*v1alpha1.TSO) []*TSO {
	return *(*[]*TSO)(unsafe.Pointer(&ins))
}

func ToTSOSlice(ins []*TSO) []*v1alpha1.TSO {
	return *(*[]*v1alpha1.TSO)(unsafe.Pointer(&ins))
}

var _ Instance = &TSO{}

func (in *TSO) DeepCopyObject() runtime.Object {
	return (*v1alpha1.TSO)(in).DeepCopyObject()
}

func (in *TSO) To() *v1alpha1.TSO {
	return ToTSO(in)
}

func (in *TSO) GetTopology() v1alpha1.Topology {
	return in.Spec.Topology
}

func (in *TSO) SetTopology(t v1alpha1.Topology) {
	in.Spec.Topology = t
}

func (in *TSO) GetUpdateRevision() string {
	if in.Labels == nil {
		return ""
	}
	return in.Labels[v1alpha1.LabelKeyInstanceRevisionHash]
}

func (in *TSO) CurrentRevision() string {
	return in.Status.CurrentRevision
}

func (in *TSO) SetCurrentRevision(rev string) {
	in.Status.CurrentRevision = rev
}

func (in *TSO) IsReady() bool {
	cond := meta.FindStatusCondition(in.Status.Conditions, v1alpha1.CondReady)
	if cond == nil {
		return false
	}
	if cond.ObservedGeneration != in.GetGeneration() {
		return false
	}
	return cond.Status == metav1.ConditionTrue
}

func (in *TSO) IsUpToDate() bool {
	return in.Status.ObservedGeneration == in.GetGeneration() && in.GetUpdateRevision() == in.Status.CurrentRevision
}

func (in *TSO) Conditions() []metav1.Condition {
	return in.Status.Conditions
}

func (in *TSO) SetConditions(conds []metav1.Condition) {
	in.Status.Conditions = conds
}

func (in *TSO) ObservedGeneration() int64 {
	return in.Status.ObservedGeneration
}

func (in *TSO) SetObservedGeneration(gen int64) {
	in.Status.ObservedGeneration = gen
}

func (in *TSO) SetCluster(cluster string) {
	in.Spec.Cluster.Name = cluster
}

func (in *TSO) Cluster() string {
	return in.Spec.Cluster.Name
}

func (*TSO) Component() string {
	return v1alpha1.LabelValComponentTSO
}

func (in *TSO) PodOverlay() *v1alpha1.PodOverlay {
	if in.Spec.Overlay == nil {
		return nil
	}
	return in.Spec.Overlay.Pod
}

func (in *TSO) Features() []metav1alpha1.Feature {
	return in.Spec.Features
}

type (
	TSOGroup v1alpha1.TSOGroup
)

type TSOGroupTuple struct{}

var _ GroupTuple[*v1alpha1.TSOGroup, *TSOGroup] = TSOGroupTuple{}

func (TSOGroupTuple) From(t *v1alpha1.TSOGroup) *TSOGroup {
	return FromTSOGroup(t)
}

func (TSOGroupTuple) FromSlice(t []*v1alpha1.TSOGroup) []*TSOGroup {
	return FromTSOGroupSlice(t)
}

func (TSOGroupTuple) To(t *TSOGroup) *v1alpha1.TSOGroup {
	return ToTSOGroup(t)
}

func (TSOGroupTuple) ToSlice(t []*TSOGroup) []*v1alpha1.TSOGroup {
	return ToTSOGroupSlice(t)
}

func FromTSOGroup(g *v1alpha1.TSOGroup) *TSOGroup {
	return (*TSOGroup)(g)
}

func ToTSOGroup(g *TSOGroup) *v1alpha1.TSOGroup {
	return (*v1alpha1.TSOGroup)(g)
}

func FromTSOGroupSlice(gs []*v1alpha1.TSOGroup) []*TSOGroup {
	return *(*[]*TSOGroup)(unsafe.Pointer(&gs))
}

func ToTSOGroupSlice(gs []*TSOGroup) []*v1alpha1.TSOGroup {
	return *(*[]*v1alpha1.TSOGroup)(unsafe.Pointer(&gs))
}

var _ Group = &TSOGroup{}

func (g *TSOGroup) DeepCopyObject() runtime.Object {
	return (*v1alpha1.TSOGroup)(g)
}

func (g *TSOGroup) To() *v1alpha1.TSOGroup {
	return ToTSOGroup(g)
}

func (g *TSOGroup) SetReplicas(replicas int32) {
	g.Spec.Replicas = &replicas
}

func (g *TSOGroup) Replicas() int32 {
	if g.Spec.Replicas == nil {
		return 1
	}
	return *g.Spec.Replicas
}

func (g *TSOGroup) SetVersion(version string) {
	g.Spec.Template.Spec.Version = version
}

func (g *TSOGroup) Version() string {
	return g.Spec.Template.Spec.Version
}

func (g *TSOGroup) SetCluster(cluster string) {
	g.Spec.Cluster.Name = cluster
}

func (g *TSOGroup) Cluster() string {
	return g.Spec.Cluster.Name
}

func (*TSOGroup) Component() string {
	return v1alpha1.LabelValComponentTSO
}

func (g *TSOGroup) Conditions() []metav1.Condition {
	return g.Status.Conditions
}

func (g *TSOGroup) SetConditions(conds []metav1.Condition) {
	g.Status.Conditions = conds
}

func (g *TSOGroup) ObservedGeneration() int64 {
	return g.Status.ObservedGeneration
}

func (g *TSOGroup) SetObservedGeneration(gen int64) {
	g.Status.ObservedGeneration = gen
}

func (g *TSOGroup) SetStatusVersion(version string) {
	g.Status.Version = version
}

func (g *TSOGroup) StatusVersion() string {
	return g.Status.Version
}

func (g *TSOGroup) SetStatusReplicas(replicas, ready, update, current int32) {
	g.Status.Replicas = replicas
	g.Status.ReadyReplicas = ready
	g.Status.UpdatedReplicas = update
	g.Status.CurrentReplicas = current
}

func (g *TSOGroup) StatusReplicas() (replicas, ready, update, current int32) {
	return g.Status.Replicas,
		g.Status.ReadyReplicas,
		g.Status.UpdatedReplicas,
		g.Status.CurrentReplicas
}

func (g *TSOGroup) SetStatusRevision(update, current string, collisionCount *int32) {
	g.Status.UpdateRevision = update
	g.Status.CurrentRevision = current
	g.Status.CollisionCount = collisionCount
}

func (g *TSOGroup) StatusRevision() (update, current string, collisionCount *int32) {
	return g.Status.UpdateRevision,
		g.Status.CurrentRevision,
		g.Status.CollisionCount
}

func (g *TSOGroup) SetStatusSelector(l string) {
	g.Status.Selector = l
}

func (g *TSOGroup) StatusSelector() string {
	return g.Status.Selector
}

func (g *TSOGroup) TemplateLabels() map[string]string {
	return g.Spec.Template.Labels
}

func (g *TSOGroup) TemplateAnnotations() map[string]string {
	return g.Spec.Template.Annotations
}

func (g *TSOGroup) Features() []metav1alpha1.Feature {
	return g.Spec.Features
}
