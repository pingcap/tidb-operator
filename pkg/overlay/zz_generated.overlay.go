//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Copyright 2024 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by overlay-gen. DO NOT EDIT.

package overlay

import (
	strconv "strconv"
	strings "strings"

	v1 "k8s.io/api/core/v1"
	resource "k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	intstr "k8s.io/apimachinery/pkg/util/intstr"
)

func overlayPodSpec(dst, src *v1.PodSpec) {
	if dst.Volumes != nil && src.Volumes != nil {
		overlayMapListSliceVolume(&(dst.Volumes), &(src.Volumes))
	} else if dst.Volumes == nil {
		dst.Volumes = src.Volumes
	}
	if dst.InitContainers != nil && src.InitContainers != nil {
		overlayMapListSliceContainer(&(dst.InitContainers), &(src.InitContainers))
	} else if dst.InitContainers == nil {
		dst.InitContainers = src.InitContainers
	}
	if dst.Containers != nil && src.Containers != nil {
		overlayMapListSliceContainer(&(dst.Containers), &(src.Containers))
	} else if dst.Containers == nil {
		dst.Containers = src.Containers
	}
	if dst.EphemeralContainers != nil && src.EphemeralContainers != nil {
		overlayMapListSliceEphemeralContainer(&(dst.EphemeralContainers), &(src.EphemeralContainers))
	} else if dst.EphemeralContainers == nil {
		dst.EphemeralContainers = src.EphemeralContainers
	}
	overlayRestartPolicy(&(dst.RestartPolicy), &(src.RestartPolicy))
	if dst.TerminationGracePeriodSeconds != nil && src.TerminationGracePeriodSeconds != nil {
		if *src.TerminationGracePeriodSeconds != 0 {
			*dst.TerminationGracePeriodSeconds = *src.TerminationGracePeriodSeconds
		}
	} else if dst.TerminationGracePeriodSeconds == nil {
		dst.TerminationGracePeriodSeconds = src.TerminationGracePeriodSeconds
	}
	if dst.ActiveDeadlineSeconds != nil && src.ActiveDeadlineSeconds != nil {
		if *src.ActiveDeadlineSeconds != 0 {
			*dst.ActiveDeadlineSeconds = *src.ActiveDeadlineSeconds
		}
	} else if dst.ActiveDeadlineSeconds == nil {
		dst.ActiveDeadlineSeconds = src.ActiveDeadlineSeconds
	}
	overlayDNSPolicy(&(dst.DNSPolicy), &(src.DNSPolicy))
	if dst.NodeSelector != nil && src.NodeSelector != nil {
		overlayAtomicMapStringToString(&(dst.NodeSelector), &(src.NodeSelector))
	} else if dst.NodeSelector == nil {
		dst.NodeSelector = src.NodeSelector
	}
	if src.ServiceAccountName != "" {
		dst.ServiceAccountName = src.ServiceAccountName
	}
	if src.DeprecatedServiceAccount != "" {
		dst.DeprecatedServiceAccount = src.DeprecatedServiceAccount
	}
	if dst.AutomountServiceAccountToken != nil && src.AutomountServiceAccountToken != nil {
		if *src.AutomountServiceAccountToken {
			*dst.AutomountServiceAccountToken = *src.AutomountServiceAccountToken
		}
	} else if dst.AutomountServiceAccountToken == nil {
		dst.AutomountServiceAccountToken = src.AutomountServiceAccountToken
	}
	if src.NodeName != "" {
		dst.NodeName = src.NodeName
	}
	if src.HostNetwork {
		dst.HostNetwork = src.HostNetwork
	}
	if src.HostPID {
		dst.HostPID = src.HostPID
	}
	if src.HostIPC {
		dst.HostIPC = src.HostIPC
	}
	if dst.ShareProcessNamespace != nil && src.ShareProcessNamespace != nil {
		if *src.ShareProcessNamespace {
			*dst.ShareProcessNamespace = *src.ShareProcessNamespace
		}
	} else if dst.ShareProcessNamespace == nil {
		dst.ShareProcessNamespace = src.ShareProcessNamespace
	}
	if dst.SecurityContext != nil && src.SecurityContext != nil {
		overlayPodSecurityContext(dst.SecurityContext, src.SecurityContext)
	} else if dst.SecurityContext == nil {
		dst.SecurityContext = src.SecurityContext
	}
	if dst.ImagePullSecrets != nil && src.ImagePullSecrets != nil {
		overlayMapListSliceLocalObjectReference(&(dst.ImagePullSecrets), &(src.ImagePullSecrets))
	} else if dst.ImagePullSecrets == nil {
		dst.ImagePullSecrets = src.ImagePullSecrets
	}
	if src.Hostname != "" {
		dst.Hostname = src.Hostname
	}
	if src.Subdomain != "" {
		dst.Subdomain = src.Subdomain
	}
	if dst.Affinity != nil && src.Affinity != nil {
		overlayAffinity(dst.Affinity, src.Affinity)
	} else if dst.Affinity == nil {
		dst.Affinity = src.Affinity
	}
	if src.SchedulerName != "" {
		dst.SchedulerName = src.SchedulerName
	}
	if dst.Tolerations != nil && src.Tolerations != nil {
		overlayAtomicListSliceToleration(&(dst.Tolerations), &(src.Tolerations))
	} else if dst.Tolerations == nil {
		dst.Tolerations = src.Tolerations
	}
	if dst.HostAliases != nil && src.HostAliases != nil {
		overlayMapListSliceHostAlias(&(dst.HostAliases), &(src.HostAliases))
	} else if dst.HostAliases == nil {
		dst.HostAliases = src.HostAliases
	}
	if src.PriorityClassName != "" {
		dst.PriorityClassName = src.PriorityClassName
	}
	if dst.Priority != nil && src.Priority != nil {
		if *src.Priority != 0 {
			*dst.Priority = *src.Priority
		}
	} else if dst.Priority == nil {
		dst.Priority = src.Priority
	}
	if dst.DNSConfig != nil && src.DNSConfig != nil {
		overlayPodDNSConfig(dst.DNSConfig, src.DNSConfig)
	} else if dst.DNSConfig == nil {
		dst.DNSConfig = src.DNSConfig
	}
	if dst.ReadinessGates != nil && src.ReadinessGates != nil {
		overlayAtomicListSlicePodReadinessGate(&(dst.ReadinessGates), &(src.ReadinessGates))
	} else if dst.ReadinessGates == nil {
		dst.ReadinessGates = src.ReadinessGates
	}
	if dst.RuntimeClassName != nil && src.RuntimeClassName != nil {
		if *src.RuntimeClassName != "" {
			*dst.RuntimeClassName = *src.RuntimeClassName
		}
	} else if dst.RuntimeClassName == nil {
		dst.RuntimeClassName = src.RuntimeClassName
	}
	if dst.EnableServiceLinks != nil && src.EnableServiceLinks != nil {
		if *src.EnableServiceLinks {
			*dst.EnableServiceLinks = *src.EnableServiceLinks
		}
	} else if dst.EnableServiceLinks == nil {
		dst.EnableServiceLinks = src.EnableServiceLinks
	}
	if dst.PreemptionPolicy != nil && src.PreemptionPolicy != nil {
		overlayPreemptionPolicy(dst.PreemptionPolicy, src.PreemptionPolicy)
	} else if dst.PreemptionPolicy == nil {
		dst.PreemptionPolicy = src.PreemptionPolicy
	}
	if dst.Overhead != nil && src.Overhead != nil {
		overlayResourceList(&(dst.Overhead), &(src.Overhead))
	} else if dst.Overhead == nil {
		dst.Overhead = src.Overhead
	}
	if dst.TopologySpreadConstraints != nil && src.TopologySpreadConstraints != nil {
		overlayMapListSliceTopologySpreadConstraint(&(dst.TopologySpreadConstraints), &(src.TopologySpreadConstraints))
	} else if dst.TopologySpreadConstraints == nil {
		dst.TopologySpreadConstraints = src.TopologySpreadConstraints
	}
	if dst.SetHostnameAsFQDN != nil && src.SetHostnameAsFQDN != nil {
		if *src.SetHostnameAsFQDN {
			*dst.SetHostnameAsFQDN = *src.SetHostnameAsFQDN
		}
	} else if dst.SetHostnameAsFQDN == nil {
		dst.SetHostnameAsFQDN = src.SetHostnameAsFQDN
	}
	if dst.OS != nil && src.OS != nil {
		overlayPodOS(dst.OS, src.OS)
	} else if dst.OS == nil {
		dst.OS = src.OS
	}
	if dst.HostUsers != nil && src.HostUsers != nil {
		if *src.HostUsers {
			*dst.HostUsers = *src.HostUsers
		}
	} else if dst.HostUsers == nil {
		dst.HostUsers = src.HostUsers
	}
	if dst.SchedulingGates != nil && src.SchedulingGates != nil {
		overlayMapListSlicePodSchedulingGate(&(dst.SchedulingGates), &(src.SchedulingGates))
	} else if dst.SchedulingGates == nil {
		dst.SchedulingGates = src.SchedulingGates
	}
	if dst.ResourceClaims != nil && src.ResourceClaims != nil {
		overlayMapListSlicePodResourceClaim(&(dst.ResourceClaims), &(src.ResourceClaims))
	} else if dst.ResourceClaims == nil {
		dst.ResourceClaims = src.ResourceClaims
	}
}
func overlayMapListSliceVolume(dst, src *[]v1.Volume) {
	m := map[string]int{}
	for i := range *dst {
		item := (*dst)[i]
		keys := []string{}
		keys = append(keys, StringToString(item.Name))
		key := strings.Join(keys, ",")
		m[key] = i
	}
	for si := range *src {
		item := (*src)[si]
		keys := []string{}
		keys = append(keys, StringToString(item.Name))
		key := strings.Join(keys, ",")
		di, ok := m[key]
		if !ok {
			*dst = append(*dst, item)
			continue
		}
		overlayVolume(&((*dst)[di]), &((*src)[si]))
	}
}
func StringToString(val string) string {
	return val
}
func overlayVolume(dst, src *v1.Volume) {
	if src.Name != "" {
		dst.Name = src.Name
	}
	overlayVolumeSource(&(dst.VolumeSource), &(src.VolumeSource))
}
func overlayVolumeSource(dst, src *v1.VolumeSource) {
	if dst.HostPath != nil && src.HostPath != nil {
		overlayHostPathVolumeSource(dst.HostPath, src.HostPath)
	} else if dst.HostPath == nil {
		dst.HostPath = src.HostPath
	}
	if dst.EmptyDir != nil && src.EmptyDir != nil {
		overlayEmptyDirVolumeSource(dst.EmptyDir, src.EmptyDir)
	} else if dst.EmptyDir == nil {
		dst.EmptyDir = src.EmptyDir
	}
	if dst.GCEPersistentDisk != nil && src.GCEPersistentDisk != nil {
		overlayGCEPersistentDiskVolumeSource(dst.GCEPersistentDisk, src.GCEPersistentDisk)
	} else if dst.GCEPersistentDisk == nil {
		dst.GCEPersistentDisk = src.GCEPersistentDisk
	}
	if dst.AWSElasticBlockStore != nil && src.AWSElasticBlockStore != nil {
		overlayAWSElasticBlockStoreVolumeSource(dst.AWSElasticBlockStore, src.AWSElasticBlockStore)
	} else if dst.AWSElasticBlockStore == nil {
		dst.AWSElasticBlockStore = src.AWSElasticBlockStore
	}
	if dst.GitRepo != nil && src.GitRepo != nil {
		overlayGitRepoVolumeSource(dst.GitRepo, src.GitRepo)
	} else if dst.GitRepo == nil {
		dst.GitRepo = src.GitRepo
	}
	if dst.Secret != nil && src.Secret != nil {
		overlaySecretVolumeSource(dst.Secret, src.Secret)
	} else if dst.Secret == nil {
		dst.Secret = src.Secret
	}
	if dst.NFS != nil && src.NFS != nil {
		overlayNFSVolumeSource(dst.NFS, src.NFS)
	} else if dst.NFS == nil {
		dst.NFS = src.NFS
	}
	if dst.ISCSI != nil && src.ISCSI != nil {
		overlayISCSIVolumeSource(dst.ISCSI, src.ISCSI)
	} else if dst.ISCSI == nil {
		dst.ISCSI = src.ISCSI
	}
	if dst.Glusterfs != nil && src.Glusterfs != nil {
		overlayGlusterfsVolumeSource(dst.Glusterfs, src.Glusterfs)
	} else if dst.Glusterfs == nil {
		dst.Glusterfs = src.Glusterfs
	}
	if dst.PersistentVolumeClaim != nil && src.PersistentVolumeClaim != nil {
		overlayPersistentVolumeClaimVolumeSource(dst.PersistentVolumeClaim, src.PersistentVolumeClaim)
	} else if dst.PersistentVolumeClaim == nil {
		dst.PersistentVolumeClaim = src.PersistentVolumeClaim
	}
	if dst.RBD != nil && src.RBD != nil {
		overlayRBDVolumeSource(dst.RBD, src.RBD)
	} else if dst.RBD == nil {
		dst.RBD = src.RBD
	}
	if dst.FlexVolume != nil && src.FlexVolume != nil {
		overlayFlexVolumeSource(dst.FlexVolume, src.FlexVolume)
	} else if dst.FlexVolume == nil {
		dst.FlexVolume = src.FlexVolume
	}
	if dst.Cinder != nil && src.Cinder != nil {
		overlayCinderVolumeSource(dst.Cinder, src.Cinder)
	} else if dst.Cinder == nil {
		dst.Cinder = src.Cinder
	}
	if dst.CephFS != nil && src.CephFS != nil {
		overlayCephFSVolumeSource(dst.CephFS, src.CephFS)
	} else if dst.CephFS == nil {
		dst.CephFS = src.CephFS
	}
	if dst.Flocker != nil && src.Flocker != nil {
		overlayFlockerVolumeSource(dst.Flocker, src.Flocker)
	} else if dst.Flocker == nil {
		dst.Flocker = src.Flocker
	}
	if dst.DownwardAPI != nil && src.DownwardAPI != nil {
		overlayDownwardAPIVolumeSource(dst.DownwardAPI, src.DownwardAPI)
	} else if dst.DownwardAPI == nil {
		dst.DownwardAPI = src.DownwardAPI
	}
	if dst.FC != nil && src.FC != nil {
		overlayFCVolumeSource(dst.FC, src.FC)
	} else if dst.FC == nil {
		dst.FC = src.FC
	}
	if dst.AzureFile != nil && src.AzureFile != nil {
		overlayAzureFileVolumeSource(dst.AzureFile, src.AzureFile)
	} else if dst.AzureFile == nil {
		dst.AzureFile = src.AzureFile
	}
	if dst.ConfigMap != nil && src.ConfigMap != nil {
		overlayConfigMapVolumeSource(dst.ConfigMap, src.ConfigMap)
	} else if dst.ConfigMap == nil {
		dst.ConfigMap = src.ConfigMap
	}
	if dst.VsphereVolume != nil && src.VsphereVolume != nil {
		overlayVsphereVirtualDiskVolumeSource(dst.VsphereVolume, src.VsphereVolume)
	} else if dst.VsphereVolume == nil {
		dst.VsphereVolume = src.VsphereVolume
	}
	if dst.Quobyte != nil && src.Quobyte != nil {
		overlayQuobyteVolumeSource(dst.Quobyte, src.Quobyte)
	} else if dst.Quobyte == nil {
		dst.Quobyte = src.Quobyte
	}
	if dst.AzureDisk != nil && src.AzureDisk != nil {
		overlayAzureDiskVolumeSource(dst.AzureDisk, src.AzureDisk)
	} else if dst.AzureDisk == nil {
		dst.AzureDisk = src.AzureDisk
	}
	if dst.PhotonPersistentDisk != nil && src.PhotonPersistentDisk != nil {
		overlayPhotonPersistentDiskVolumeSource(dst.PhotonPersistentDisk, src.PhotonPersistentDisk)
	} else if dst.PhotonPersistentDisk == nil {
		dst.PhotonPersistentDisk = src.PhotonPersistentDisk
	}
	if dst.Projected != nil && src.Projected != nil {
		overlayProjectedVolumeSource(dst.Projected, src.Projected)
	} else if dst.Projected == nil {
		dst.Projected = src.Projected
	}
	if dst.PortworxVolume != nil && src.PortworxVolume != nil {
		overlayPortworxVolumeSource(dst.PortworxVolume, src.PortworxVolume)
	} else if dst.PortworxVolume == nil {
		dst.PortworxVolume = src.PortworxVolume
	}
	if dst.ScaleIO != nil && src.ScaleIO != nil {
		overlayScaleIOVolumeSource(dst.ScaleIO, src.ScaleIO)
	} else if dst.ScaleIO == nil {
		dst.ScaleIO = src.ScaleIO
	}
	if dst.StorageOS != nil && src.StorageOS != nil {
		overlayStorageOSVolumeSource(dst.StorageOS, src.StorageOS)
	} else if dst.StorageOS == nil {
		dst.StorageOS = src.StorageOS
	}
	if dst.CSI != nil && src.CSI != nil {
		overlayCSIVolumeSource(dst.CSI, src.CSI)
	} else if dst.CSI == nil {
		dst.CSI = src.CSI
	}
	if dst.Ephemeral != nil && src.Ephemeral != nil {
		overlayEphemeralVolumeSource(dst.Ephemeral, src.Ephemeral)
	} else if dst.Ephemeral == nil {
		dst.Ephemeral = src.Ephemeral
	}
	if dst.Image != nil && src.Image != nil {
		overlayImageVolumeSource(dst.Image, src.Image)
	} else if dst.Image == nil {
		dst.Image = src.Image
	}
}
func overlayHostPathVolumeSource(dst, src *v1.HostPathVolumeSource) {
	if src.Path != "" {
		dst.Path = src.Path
	}
	if dst.Type != nil && src.Type != nil {
		overlayHostPathType(dst.Type, src.Type)
	} else if dst.Type == nil {
		dst.Type = src.Type
	}
}
func overlayHostPathType(dst, src *v1.HostPathType) {
	ndst := (*string)(dst)
	nsrc := (*string)(src)
	if *nsrc != "" {
		*ndst = *nsrc
	}
}
func overlayEmptyDirVolumeSource(dst, src *v1.EmptyDirVolumeSource) {
	overlayStorageMedium(&(dst.Medium), &(src.Medium))
	if dst.SizeLimit != nil && src.SizeLimit != nil {
		overlayQuantity(dst.SizeLimit, src.SizeLimit)
	} else if dst.SizeLimit == nil {
		dst.SizeLimit = src.SizeLimit
	}
}
func overlayStorageMedium(dst, src *v1.StorageMedium) {
	ndst := (*string)(dst)
	nsrc := (*string)(src)
	if *nsrc != "" {
		*ndst = *nsrc
	}
}
func overlayGCEPersistentDiskVolumeSource(dst, src *v1.GCEPersistentDiskVolumeSource) {
	if src.PDName != "" {
		dst.PDName = src.PDName
	}
	if src.FSType != "" {
		dst.FSType = src.FSType
	}
	if src.Partition != 0 {
		dst.Partition = src.Partition
	}
	if src.ReadOnly {
		dst.ReadOnly = src.ReadOnly
	}
}
func overlayAWSElasticBlockStoreVolumeSource(dst, src *v1.AWSElasticBlockStoreVolumeSource) {
	if src.VolumeID != "" {
		dst.VolumeID = src.VolumeID
	}
	if src.FSType != "" {
		dst.FSType = src.FSType
	}
	if src.Partition != 0 {
		dst.Partition = src.Partition
	}
	if src.ReadOnly {
		dst.ReadOnly = src.ReadOnly
	}
}
func overlayGitRepoVolumeSource(dst, src *v1.GitRepoVolumeSource) {
	if src.Repository != "" {
		dst.Repository = src.Repository
	}
	if src.Revision != "" {
		dst.Revision = src.Revision
	}
	if src.Directory != "" {
		dst.Directory = src.Directory
	}
}
func overlaySecretVolumeSource(dst, src *v1.SecretVolumeSource) {
	if src.SecretName != "" {
		dst.SecretName = src.SecretName
	}
	if dst.Items != nil && src.Items != nil {
		overlayAtomicListSliceKeyToPath(&(dst.Items), &(src.Items))
	} else if dst.Items == nil {
		dst.Items = src.Items
	}
	if dst.DefaultMode != nil && src.DefaultMode != nil {
		if *src.DefaultMode != 0 {
			*dst.DefaultMode = *src.DefaultMode
		}
	} else if dst.DefaultMode == nil {
		dst.DefaultMode = src.DefaultMode
	}
	if dst.Optional != nil && src.Optional != nil {
		if *src.Optional {
			*dst.Optional = *src.Optional
		}
	} else if dst.Optional == nil {
		dst.Optional = src.Optional
	}
}
func overlayAtomicListSliceKeyToPath(dst, src *[]v1.KeyToPath) {
	if len(*src) == 0 {
		return
	}
	*dst = *src
}
func overlayNFSVolumeSource(dst, src *v1.NFSVolumeSource) {
	if src.Server != "" {
		dst.Server = src.Server
	}
	if src.Path != "" {
		dst.Path = src.Path
	}
	if src.ReadOnly {
		dst.ReadOnly = src.ReadOnly
	}
}
func overlayISCSIVolumeSource(dst, src *v1.ISCSIVolumeSource) {
	if src.TargetPortal != "" {
		dst.TargetPortal = src.TargetPortal
	}
	if src.IQN != "" {
		dst.IQN = src.IQN
	}
	if src.Lun != 0 {
		dst.Lun = src.Lun
	}
	if src.ISCSIInterface != "" {
		dst.ISCSIInterface = src.ISCSIInterface
	}
	if src.FSType != "" {
		dst.FSType = src.FSType
	}
	if src.ReadOnly {
		dst.ReadOnly = src.ReadOnly
	}
	if dst.Portals != nil && src.Portals != nil {
		overlayAtomicListSliceString(&(dst.Portals), &(src.Portals))
	} else if dst.Portals == nil {
		dst.Portals = src.Portals
	}
	if src.DiscoveryCHAPAuth {
		dst.DiscoveryCHAPAuth = src.DiscoveryCHAPAuth
	}
	if src.SessionCHAPAuth {
		dst.SessionCHAPAuth = src.SessionCHAPAuth
	}
	if dst.SecretRef != nil && src.SecretRef != nil {
		overlayAtomicLocalObjectReference(dst.SecretRef, src.SecretRef)
	} else if dst.SecretRef == nil {
		dst.SecretRef = src.SecretRef
	}
	if dst.InitiatorName != nil && src.InitiatorName != nil {
		if *src.InitiatorName != "" {
			*dst.InitiatorName = *src.InitiatorName
		}
	} else if dst.InitiatorName == nil {
		dst.InitiatorName = src.InitiatorName
	}
}
func overlayAtomicListSliceString(dst, src *[]string) {
	if len(*src) == 0 {
		return
	}
	*dst = *src
}
func overlayAtomicLocalObjectReference(dst, src *v1.LocalObjectReference) {
	*dst = *src
}
func overlayGlusterfsVolumeSource(dst, src *v1.GlusterfsVolumeSource) {
	if src.EndpointsName != "" {
		dst.EndpointsName = src.EndpointsName
	}
	if src.Path != "" {
		dst.Path = src.Path
	}
	if src.ReadOnly {
		dst.ReadOnly = src.ReadOnly
	}
}
func overlayPersistentVolumeClaimVolumeSource(dst, src *v1.PersistentVolumeClaimVolumeSource) {
	if src.ClaimName != "" {
		dst.ClaimName = src.ClaimName
	}
	if src.ReadOnly {
		dst.ReadOnly = src.ReadOnly
	}
}
func overlayRBDVolumeSource(dst, src *v1.RBDVolumeSource) {
	if dst.CephMonitors != nil && src.CephMonitors != nil {
		overlayAtomicListSliceString(&(dst.CephMonitors), &(src.CephMonitors))
	} else if dst.CephMonitors == nil {
		dst.CephMonitors = src.CephMonitors
	}
	if src.RBDImage != "" {
		dst.RBDImage = src.RBDImage
	}
	if src.FSType != "" {
		dst.FSType = src.FSType
	}
	if src.RBDPool != "" {
		dst.RBDPool = src.RBDPool
	}
	if src.RadosUser != "" {
		dst.RadosUser = src.RadosUser
	}
	if src.Keyring != "" {
		dst.Keyring = src.Keyring
	}
	if dst.SecretRef != nil && src.SecretRef != nil {
		overlayAtomicLocalObjectReference(dst.SecretRef, src.SecretRef)
	} else if dst.SecretRef == nil {
		dst.SecretRef = src.SecretRef
	}
	if src.ReadOnly {
		dst.ReadOnly = src.ReadOnly
	}
}
func overlayFlexVolumeSource(dst, src *v1.FlexVolumeSource) {
	if src.Driver != "" {
		dst.Driver = src.Driver
	}
	if src.FSType != "" {
		dst.FSType = src.FSType
	}
	if dst.SecretRef != nil && src.SecretRef != nil {
		overlayAtomicLocalObjectReference(dst.SecretRef, src.SecretRef)
	} else if dst.SecretRef == nil {
		dst.SecretRef = src.SecretRef
	}
	if src.ReadOnly {
		dst.ReadOnly = src.ReadOnly
	}
	if dst.Options != nil && src.Options != nil {
		overlayMapStringToString(&(dst.Options), &(src.Options))
	} else if dst.Options == nil {
		dst.Options = src.Options
	}
}
func overlayMapStringToString(dst, src *map[string]string) {
	for k := range *src {
		vdst, ok := (*dst)[k]
		if !ok {
			(*dst)[k] = (*src)[k]
			continue
		}
		vsrc := (*src)[k]
		if vsrc != "" {
			vdst = vsrc
		}
		(*dst)[k] = vdst
	}
}
func overlayCinderVolumeSource(dst, src *v1.CinderVolumeSource) {
	if src.VolumeID != "" {
		dst.VolumeID = src.VolumeID
	}
	if src.FSType != "" {
		dst.FSType = src.FSType
	}
	if src.ReadOnly {
		dst.ReadOnly = src.ReadOnly
	}
	if dst.SecretRef != nil && src.SecretRef != nil {
		overlayAtomicLocalObjectReference(dst.SecretRef, src.SecretRef)
	} else if dst.SecretRef == nil {
		dst.SecretRef = src.SecretRef
	}
}
func overlayCephFSVolumeSource(dst, src *v1.CephFSVolumeSource) {
	if dst.Monitors != nil && src.Monitors != nil {
		overlayAtomicListSliceString(&(dst.Monitors), &(src.Monitors))
	} else if dst.Monitors == nil {
		dst.Monitors = src.Monitors
	}
	if src.Path != "" {
		dst.Path = src.Path
	}
	if src.User != "" {
		dst.User = src.User
	}
	if src.SecretFile != "" {
		dst.SecretFile = src.SecretFile
	}
	if dst.SecretRef != nil && src.SecretRef != nil {
		overlayAtomicLocalObjectReference(dst.SecretRef, src.SecretRef)
	} else if dst.SecretRef == nil {
		dst.SecretRef = src.SecretRef
	}
	if src.ReadOnly {
		dst.ReadOnly = src.ReadOnly
	}
}
func overlayFlockerVolumeSource(dst, src *v1.FlockerVolumeSource) {
	if src.DatasetName != "" {
		dst.DatasetName = src.DatasetName
	}
	if src.DatasetUUID != "" {
		dst.DatasetUUID = src.DatasetUUID
	}
}
func overlayDownwardAPIVolumeSource(dst, src *v1.DownwardAPIVolumeSource) {
	if dst.Items != nil && src.Items != nil {
		overlayAtomicListSliceDownwardAPIVolumeFile(&(dst.Items), &(src.Items))
	} else if dst.Items == nil {
		dst.Items = src.Items
	}
	if dst.DefaultMode != nil && src.DefaultMode != nil {
		if *src.DefaultMode != 0 {
			*dst.DefaultMode = *src.DefaultMode
		}
	} else if dst.DefaultMode == nil {
		dst.DefaultMode = src.DefaultMode
	}
}
func overlayAtomicListSliceDownwardAPIVolumeFile(dst, src *[]v1.DownwardAPIVolumeFile) {
	if len(*src) == 0 {
		return
	}
	*dst = *src
}
func overlayFCVolumeSource(dst, src *v1.FCVolumeSource) {
	if dst.TargetWWNs != nil && src.TargetWWNs != nil {
		overlayAtomicListSliceString(&(dst.TargetWWNs), &(src.TargetWWNs))
	} else if dst.TargetWWNs == nil {
		dst.TargetWWNs = src.TargetWWNs
	}
	if dst.Lun != nil && src.Lun != nil {
		if *src.Lun != 0 {
			*dst.Lun = *src.Lun
		}
	} else if dst.Lun == nil {
		dst.Lun = src.Lun
	}
	if src.FSType != "" {
		dst.FSType = src.FSType
	}
	if src.ReadOnly {
		dst.ReadOnly = src.ReadOnly
	}
	if dst.WWIDs != nil && src.WWIDs != nil {
		overlayAtomicListSliceString(&(dst.WWIDs), &(src.WWIDs))
	} else if dst.WWIDs == nil {
		dst.WWIDs = src.WWIDs
	}
}
func overlayAzureFileVolumeSource(dst, src *v1.AzureFileVolumeSource) {
	if src.SecretName != "" {
		dst.SecretName = src.SecretName
	}
	if src.ShareName != "" {
		dst.ShareName = src.ShareName
	}
	if src.ReadOnly {
		dst.ReadOnly = src.ReadOnly
	}
}
func overlayConfigMapVolumeSource(dst, src *v1.ConfigMapVolumeSource) {
	overlayAtomicLocalObjectReference(&(dst.LocalObjectReference), &(src.LocalObjectReference))
	if dst.Items != nil && src.Items != nil {
		overlayAtomicListSliceKeyToPath(&(dst.Items), &(src.Items))
	} else if dst.Items == nil {
		dst.Items = src.Items
	}
	if dst.DefaultMode != nil && src.DefaultMode != nil {
		if *src.DefaultMode != 0 {
			*dst.DefaultMode = *src.DefaultMode
		}
	} else if dst.DefaultMode == nil {
		dst.DefaultMode = src.DefaultMode
	}
	if dst.Optional != nil && src.Optional != nil {
		if *src.Optional {
			*dst.Optional = *src.Optional
		}
	} else if dst.Optional == nil {
		dst.Optional = src.Optional
	}
}
func overlayVsphereVirtualDiskVolumeSource(dst, src *v1.VsphereVirtualDiskVolumeSource) {
	if src.VolumePath != "" {
		dst.VolumePath = src.VolumePath
	}
	if src.FSType != "" {
		dst.FSType = src.FSType
	}
	if src.StoragePolicyName != "" {
		dst.StoragePolicyName = src.StoragePolicyName
	}
	if src.StoragePolicyID != "" {
		dst.StoragePolicyID = src.StoragePolicyID
	}
}
func overlayQuobyteVolumeSource(dst, src *v1.QuobyteVolumeSource) {
	if src.Registry != "" {
		dst.Registry = src.Registry
	}
	if src.Volume != "" {
		dst.Volume = src.Volume
	}
	if src.ReadOnly {
		dst.ReadOnly = src.ReadOnly
	}
	if src.User != "" {
		dst.User = src.User
	}
	if src.Group != "" {
		dst.Group = src.Group
	}
	if src.Tenant != "" {
		dst.Tenant = src.Tenant
	}
}
func overlayAzureDiskVolumeSource(dst, src *v1.AzureDiskVolumeSource) {
	if src.DiskName != "" {
		dst.DiskName = src.DiskName
	}
	if src.DataDiskURI != "" {
		dst.DataDiskURI = src.DataDiskURI
	}
	if dst.CachingMode != nil && src.CachingMode != nil {
		overlayAzureDataDiskCachingMode(dst.CachingMode, src.CachingMode)
	} else if dst.CachingMode == nil {
		dst.CachingMode = src.CachingMode
	}
	if dst.FSType != nil && src.FSType != nil {
		if *src.FSType != "" {
			*dst.FSType = *src.FSType
		}
	} else if dst.FSType == nil {
		dst.FSType = src.FSType
	}
	if dst.ReadOnly != nil && src.ReadOnly != nil {
		if *src.ReadOnly {
			*dst.ReadOnly = *src.ReadOnly
		}
	} else if dst.ReadOnly == nil {
		dst.ReadOnly = src.ReadOnly
	}
	if dst.Kind != nil && src.Kind != nil {
		overlayAzureDataDiskKind(dst.Kind, src.Kind)
	} else if dst.Kind == nil {
		dst.Kind = src.Kind
	}
}
func overlayAzureDataDiskCachingMode(dst, src *v1.AzureDataDiskCachingMode) {
	ndst := (*string)(dst)
	nsrc := (*string)(src)
	if *nsrc != "" {
		*ndst = *nsrc
	}
}
func overlayAzureDataDiskKind(dst, src *v1.AzureDataDiskKind) {
	ndst := (*string)(dst)
	nsrc := (*string)(src)
	if *nsrc != "" {
		*ndst = *nsrc
	}
}
func overlayPhotonPersistentDiskVolumeSource(dst, src *v1.PhotonPersistentDiskVolumeSource) {
	if src.PdID != "" {
		dst.PdID = src.PdID
	}
	if src.FSType != "" {
		dst.FSType = src.FSType
	}
}
func overlayProjectedVolumeSource(dst, src *v1.ProjectedVolumeSource) {
	if dst.Sources != nil && src.Sources != nil {
		overlayAtomicListSliceVolumeProjection(&(dst.Sources), &(src.Sources))
	} else if dst.Sources == nil {
		dst.Sources = src.Sources
	}
	if dst.DefaultMode != nil && src.DefaultMode != nil {
		if *src.DefaultMode != 0 {
			*dst.DefaultMode = *src.DefaultMode
		}
	} else if dst.DefaultMode == nil {
		dst.DefaultMode = src.DefaultMode
	}
}
func overlayAtomicListSliceVolumeProjection(dst, src *[]v1.VolumeProjection) {
	if len(*src) == 0 {
		return
	}
	*dst = *src
}
func overlayPortworxVolumeSource(dst, src *v1.PortworxVolumeSource) {
	if src.VolumeID != "" {
		dst.VolumeID = src.VolumeID
	}
	if src.FSType != "" {
		dst.FSType = src.FSType
	}
	if src.ReadOnly {
		dst.ReadOnly = src.ReadOnly
	}
}
func overlayScaleIOVolumeSource(dst, src *v1.ScaleIOVolumeSource) {
	if src.Gateway != "" {
		dst.Gateway = src.Gateway
	}
	if src.System != "" {
		dst.System = src.System
	}
	if dst.SecretRef != nil && src.SecretRef != nil {
		overlayAtomicLocalObjectReference(dst.SecretRef, src.SecretRef)
	} else if dst.SecretRef == nil {
		dst.SecretRef = src.SecretRef
	}
	if src.SSLEnabled {
		dst.SSLEnabled = src.SSLEnabled
	}
	if src.ProtectionDomain != "" {
		dst.ProtectionDomain = src.ProtectionDomain
	}
	if src.StoragePool != "" {
		dst.StoragePool = src.StoragePool
	}
	if src.StorageMode != "" {
		dst.StorageMode = src.StorageMode
	}
	if src.VolumeName != "" {
		dst.VolumeName = src.VolumeName
	}
	if src.FSType != "" {
		dst.FSType = src.FSType
	}
	if src.ReadOnly {
		dst.ReadOnly = src.ReadOnly
	}
}
func overlayStorageOSVolumeSource(dst, src *v1.StorageOSVolumeSource) {
	if src.VolumeName != "" {
		dst.VolumeName = src.VolumeName
	}
	if src.VolumeNamespace != "" {
		dst.VolumeNamespace = src.VolumeNamespace
	}
	if src.FSType != "" {
		dst.FSType = src.FSType
	}
	if src.ReadOnly {
		dst.ReadOnly = src.ReadOnly
	}
	if dst.SecretRef != nil && src.SecretRef != nil {
		overlayAtomicLocalObjectReference(dst.SecretRef, src.SecretRef)
	} else if dst.SecretRef == nil {
		dst.SecretRef = src.SecretRef
	}
}
func overlayCSIVolumeSource(dst, src *v1.CSIVolumeSource) {
	if src.Driver != "" {
		dst.Driver = src.Driver
	}
	if dst.ReadOnly != nil && src.ReadOnly != nil {
		if *src.ReadOnly {
			*dst.ReadOnly = *src.ReadOnly
		}
	} else if dst.ReadOnly == nil {
		dst.ReadOnly = src.ReadOnly
	}
	if dst.FSType != nil && src.FSType != nil {
		if *src.FSType != "" {
			*dst.FSType = *src.FSType
		}
	} else if dst.FSType == nil {
		dst.FSType = src.FSType
	}
	if dst.VolumeAttributes != nil && src.VolumeAttributes != nil {
		overlayMapStringToString(&(dst.VolumeAttributes), &(src.VolumeAttributes))
	} else if dst.VolumeAttributes == nil {
		dst.VolumeAttributes = src.VolumeAttributes
	}
	if dst.NodePublishSecretRef != nil && src.NodePublishSecretRef != nil {
		overlayAtomicLocalObjectReference(dst.NodePublishSecretRef, src.NodePublishSecretRef)
	} else if dst.NodePublishSecretRef == nil {
		dst.NodePublishSecretRef = src.NodePublishSecretRef
	}
}
func overlayEphemeralVolumeSource(dst, src *v1.EphemeralVolumeSource) {
	if dst.VolumeClaimTemplate != nil && src.VolumeClaimTemplate != nil {
		overlayPersistentVolumeClaimTemplate(dst.VolumeClaimTemplate, src.VolumeClaimTemplate)
	} else if dst.VolumeClaimTemplate == nil {
		dst.VolumeClaimTemplate = src.VolumeClaimTemplate
	}
}
func overlayPersistentVolumeClaimTemplate(dst, src *v1.PersistentVolumeClaimTemplate) {
	overlayObjectMeta(&(dst.ObjectMeta), &(src.ObjectMeta))
	overlayPersistentVolumeClaimSpec(&(dst.Spec), &(src.Spec))
}
func overlayPersistentVolumeClaimSpec(dst, src *v1.PersistentVolumeClaimSpec) {
	if dst.AccessModes != nil && src.AccessModes != nil {
		overlayAtomicListSlicePersistentVolumeAccessMode(&(dst.AccessModes), &(src.AccessModes))
	} else if dst.AccessModes == nil {
		dst.AccessModes = src.AccessModes
	}
	if dst.Selector != nil && src.Selector != nil {
		overlayLabelSelector(dst.Selector, src.Selector)
	} else if dst.Selector == nil {
		dst.Selector = src.Selector
	}
	overlayVolumeResourceRequirements(&(dst.Resources), &(src.Resources))
	if src.VolumeName != "" {
		dst.VolumeName = src.VolumeName
	}
	if dst.StorageClassName != nil && src.StorageClassName != nil {
		if *src.StorageClassName != "" {
			*dst.StorageClassName = *src.StorageClassName
		}
	} else if dst.StorageClassName == nil {
		dst.StorageClassName = src.StorageClassName
	}
	if dst.VolumeMode != nil && src.VolumeMode != nil {
		overlayPersistentVolumeMode(dst.VolumeMode, src.VolumeMode)
	} else if dst.VolumeMode == nil {
		dst.VolumeMode = src.VolumeMode
	}
	if dst.DataSource != nil && src.DataSource != nil {
		overlayAtomicTypedLocalObjectReference(dst.DataSource, src.DataSource)
	} else if dst.DataSource == nil {
		dst.DataSource = src.DataSource
	}
	if dst.DataSourceRef != nil && src.DataSourceRef != nil {
		overlayTypedObjectReference(dst.DataSourceRef, src.DataSourceRef)
	} else if dst.DataSourceRef == nil {
		dst.DataSourceRef = src.DataSourceRef
	}
	if dst.VolumeAttributesClassName != nil && src.VolumeAttributesClassName != nil {
		if *src.VolumeAttributesClassName != "" {
			*dst.VolumeAttributesClassName = *src.VolumeAttributesClassName
		}
	} else if dst.VolumeAttributesClassName == nil {
		dst.VolumeAttributesClassName = src.VolumeAttributesClassName
	}
}
func overlayAtomicListSlicePersistentVolumeAccessMode(dst, src *[]v1.PersistentVolumeAccessMode) {
	if len(*src) == 0 {
		return
	}
	*dst = *src
}
func overlayLabelSelector(dst, src *metav1.LabelSelector) {
	if dst.MatchLabels != nil && src.MatchLabels != nil {
		overlayMapStringToString(&(dst.MatchLabels), &(src.MatchLabels))
	} else if dst.MatchLabels == nil {
		dst.MatchLabels = src.MatchLabels
	}
	if dst.MatchExpressions != nil && src.MatchExpressions != nil {
		overlayAtomicListSliceLabelSelectorRequirement(&(dst.MatchExpressions), &(src.MatchExpressions))
	} else if dst.MatchExpressions == nil {
		dst.MatchExpressions = src.MatchExpressions
	}
}
func overlayAtomicListSliceLabelSelectorRequirement(dst, src *[]metav1.LabelSelectorRequirement) {
	if len(*src) == 0 {
		return
	}
	*dst = *src
}
func overlayVolumeResourceRequirements(dst, src *v1.VolumeResourceRequirements) {
	if dst.Limits != nil && src.Limits != nil {
		overlayResourceList(&(dst.Limits), &(src.Limits))
	} else if dst.Limits == nil {
		dst.Limits = src.Limits
	}
	if dst.Requests != nil && src.Requests != nil {
		overlayResourceList(&(dst.Requests), &(src.Requests))
	} else if dst.Requests == nil {
		dst.Requests = src.Requests
	}
}
func overlayResourceList(dst, src *v1.ResourceList) {
	ndst := (*map[v1.ResourceName]resource.Quantity)(dst)
	nsrc := (*map[v1.ResourceName]resource.Quantity)(src)
	overlayMapResourceNameToQuantity(ndst, nsrc)
}
func overlayMapResourceNameToQuantity(dst, src *map[v1.ResourceName]resource.Quantity) {
	for k := range *src {
		vdst, ok := (*dst)[k]
		if !ok {
			(*dst)[k] = (*src)[k]
			continue
		}
		vsrc := (*src)[k]
		overlayQuantity(&(vdst), &(vsrc))
		(*dst)[k] = vdst
	}
}
func overlayPersistentVolumeMode(dst, src *v1.PersistentVolumeMode) {
	ndst := (*string)(dst)
	nsrc := (*string)(src)
	if *nsrc != "" {
		*ndst = *nsrc
	}
}
func overlayAtomicTypedLocalObjectReference(dst, src *v1.TypedLocalObjectReference) {
	*dst = *src
}
func overlayTypedObjectReference(dst, src *v1.TypedObjectReference) {
	if dst.APIGroup != nil && src.APIGroup != nil {
		if *src.APIGroup != "" {
			*dst.APIGroup = *src.APIGroup
		}
	} else if dst.APIGroup == nil {
		dst.APIGroup = src.APIGroup
	}
	if src.Kind != "" {
		dst.Kind = src.Kind
	}
	if src.Name != "" {
		dst.Name = src.Name
	}
	if dst.Namespace != nil && src.Namespace != nil {
		if *src.Namespace != "" {
			*dst.Namespace = *src.Namespace
		}
	} else if dst.Namespace == nil {
		dst.Namespace = src.Namespace
	}
}
func overlayImageVolumeSource(dst, src *v1.ImageVolumeSource) {
	if src.Reference != "" {
		dst.Reference = src.Reference
	}
	overlayPullPolicy(&(dst.PullPolicy), &(src.PullPolicy))
}
func overlayPullPolicy(dst, src *v1.PullPolicy) {
	ndst := (*string)(dst)
	nsrc := (*string)(src)
	if *nsrc != "" {
		*ndst = *nsrc
	}
}
func overlayMapListSliceContainer(dst, src *[]v1.Container) {
	m := map[string]int{}
	for i := range *dst {
		item := (*dst)[i]
		keys := []string{}
		keys = append(keys, StringToString(item.Name))
		key := strings.Join(keys, ",")
		m[key] = i
	}
	for si := range *src {
		item := (*src)[si]
		keys := []string{}
		keys = append(keys, StringToString(item.Name))
		key := strings.Join(keys, ",")
		di, ok := m[key]
		if !ok {
			*dst = append(*dst, item)
			continue
		}
		overlayContainer(&((*dst)[di]), &((*src)[si]))
	}
}
func overlayContainer(dst, src *v1.Container) {
	if src.Name != "" {
		dst.Name = src.Name
	}
	if src.Image != "" {
		dst.Image = src.Image
	}
	if dst.Command != nil && src.Command != nil {
		overlayAtomicListSliceString(&(dst.Command), &(src.Command))
	} else if dst.Command == nil {
		dst.Command = src.Command
	}
	if dst.Args != nil && src.Args != nil {
		overlayAtomicListSliceString(&(dst.Args), &(src.Args))
	} else if dst.Args == nil {
		dst.Args = src.Args
	}
	if src.WorkingDir != "" {
		dst.WorkingDir = src.WorkingDir
	}
	if dst.Ports != nil && src.Ports != nil {
		overlayMapListSliceContainerPort(&(dst.Ports), &(src.Ports))
	} else if dst.Ports == nil {
		dst.Ports = src.Ports
	}
	if dst.EnvFrom != nil && src.EnvFrom != nil {
		overlayAtomicListSliceEnvFromSource(&(dst.EnvFrom), &(src.EnvFrom))
	} else if dst.EnvFrom == nil {
		dst.EnvFrom = src.EnvFrom
	}
	if dst.Env != nil && src.Env != nil {
		overlayMapListSliceEnvVar(&(dst.Env), &(src.Env))
	} else if dst.Env == nil {
		dst.Env = src.Env
	}
	overlayResourceRequirements(&(dst.Resources), &(src.Resources))
	if dst.ResizePolicy != nil && src.ResizePolicy != nil {
		overlayAtomicListSliceContainerResizePolicy(&(dst.ResizePolicy), &(src.ResizePolicy))
	} else if dst.ResizePolicy == nil {
		dst.ResizePolicy = src.ResizePolicy
	}
	if dst.RestartPolicy != nil && src.RestartPolicy != nil {
		overlayContainerRestartPolicy(dst.RestartPolicy, src.RestartPolicy)
	} else if dst.RestartPolicy == nil {
		dst.RestartPolicy = src.RestartPolicy
	}
	if dst.VolumeMounts != nil && src.VolumeMounts != nil {
		overlayMapListSliceVolumeMount(&(dst.VolumeMounts), &(src.VolumeMounts))
	} else if dst.VolumeMounts == nil {
		dst.VolumeMounts = src.VolumeMounts
	}
	if dst.VolumeDevices != nil && src.VolumeDevices != nil {
		overlayMapListSliceVolumeDevice(&(dst.VolumeDevices), &(src.VolumeDevices))
	} else if dst.VolumeDevices == nil {
		dst.VolumeDevices = src.VolumeDevices
	}
	if dst.LivenessProbe != nil && src.LivenessProbe != nil {
		overlayProbe(dst.LivenessProbe, src.LivenessProbe)
	} else if dst.LivenessProbe == nil {
		dst.LivenessProbe = src.LivenessProbe
	}
	if dst.ReadinessProbe != nil && src.ReadinessProbe != nil {
		overlayProbe(dst.ReadinessProbe, src.ReadinessProbe)
	} else if dst.ReadinessProbe == nil {
		dst.ReadinessProbe = src.ReadinessProbe
	}
	if dst.StartupProbe != nil && src.StartupProbe != nil {
		overlayProbe(dst.StartupProbe, src.StartupProbe)
	} else if dst.StartupProbe == nil {
		dst.StartupProbe = src.StartupProbe
	}
	if dst.Lifecycle != nil && src.Lifecycle != nil {
		overlayLifecycle(dst.Lifecycle, src.Lifecycle)
	} else if dst.Lifecycle == nil {
		dst.Lifecycle = src.Lifecycle
	}
	if src.TerminationMessagePath != "" {
		dst.TerminationMessagePath = src.TerminationMessagePath
	}
	overlayTerminationMessagePolicy(&(dst.TerminationMessagePolicy), &(src.TerminationMessagePolicy))
	overlayPullPolicy(&(dst.ImagePullPolicy), &(src.ImagePullPolicy))
	if dst.SecurityContext != nil && src.SecurityContext != nil {
		overlaySecurityContext(dst.SecurityContext, src.SecurityContext)
	} else if dst.SecurityContext == nil {
		dst.SecurityContext = src.SecurityContext
	}
	if src.Stdin {
		dst.Stdin = src.Stdin
	}
	if src.StdinOnce {
		dst.StdinOnce = src.StdinOnce
	}
	if src.TTY {
		dst.TTY = src.TTY
	}
}
func overlayMapListSliceContainerPort(dst, src *[]v1.ContainerPort) {
	m := map[string]int{}
	for i := range *dst {
		item := (*dst)[i]
		keys := []string{}
		keys = append(keys, Int32ToString(item.ContainerPort))
		keys = append(keys, ProtocolToString(item.Protocol))
		key := strings.Join(keys, ",")
		m[key] = i
	}
	for si := range *src {
		item := (*src)[si]
		keys := []string{}
		keys = append(keys, Int32ToString(item.ContainerPort))
		keys = append(keys, ProtocolToString(item.Protocol))
		key := strings.Join(keys, ",")
		di, ok := m[key]
		if !ok {
			*dst = append(*dst, item)
			continue
		}
		overlayContainerPort(&((*dst)[di]), &((*src)[si]))
	}
}
func Int32ToString(val int32) string {
	return strconv.FormatInt(int64(val), 10)
}
func ProtocolToString(val v1.Protocol) string {
	return StringToString(string(val))
}
func overlayContainerPort(dst, src *v1.ContainerPort) {
	if src.Name != "" {
		dst.Name = src.Name
	}
	if src.HostPort != 0 {
		dst.HostPort = src.HostPort
	}
	if src.ContainerPort != 0 {
		dst.ContainerPort = src.ContainerPort
	}
	overlayProtocol(&(dst.Protocol), &(src.Protocol))
	if src.HostIP != "" {
		dst.HostIP = src.HostIP
	}
}
func overlayProtocol(dst, src *v1.Protocol) {
	ndst := (*string)(dst)
	nsrc := (*string)(src)
	if *nsrc != "" {
		*ndst = *nsrc
	}
}
func overlayAtomicListSliceEnvFromSource(dst, src *[]v1.EnvFromSource) {
	if len(*src) == 0 {
		return
	}
	*dst = *src
}
func overlayMapListSliceEnvVar(dst, src *[]v1.EnvVar) {
	m := map[string]int{}
	for i := range *dst {
		item := (*dst)[i]
		keys := []string{}
		keys = append(keys, StringToString(item.Name))
		key := strings.Join(keys, ",")
		m[key] = i
	}
	for si := range *src {
		item := (*src)[si]
		keys := []string{}
		keys = append(keys, StringToString(item.Name))
		key := strings.Join(keys, ",")
		di, ok := m[key]
		if !ok {
			*dst = append(*dst, item)
			continue
		}
		overlayEnvVar(&((*dst)[di]), &((*src)[si]))
	}
}
func overlayEnvVar(dst, src *v1.EnvVar) {
	if src.Name != "" {
		dst.Name = src.Name
	}
	if src.Value != "" {
		dst.Value = src.Value
	}
	if dst.ValueFrom != nil && src.ValueFrom != nil {
		overlayEnvVarSource(dst.ValueFrom, src.ValueFrom)
	} else if dst.ValueFrom == nil {
		dst.ValueFrom = src.ValueFrom
	}
}
func overlayEnvVarSource(dst, src *v1.EnvVarSource) {
	if dst.FieldRef != nil && src.FieldRef != nil {
		overlayAtomicObjectFieldSelector(dst.FieldRef, src.FieldRef)
	} else if dst.FieldRef == nil {
		dst.FieldRef = src.FieldRef
	}
	if dst.ResourceFieldRef != nil && src.ResourceFieldRef != nil {
		overlayAtomicResourceFieldSelector(dst.ResourceFieldRef, src.ResourceFieldRef)
	} else if dst.ResourceFieldRef == nil {
		dst.ResourceFieldRef = src.ResourceFieldRef
	}
	if dst.ConfigMapKeyRef != nil && src.ConfigMapKeyRef != nil {
		overlayAtomicConfigMapKeySelector(dst.ConfigMapKeyRef, src.ConfigMapKeyRef)
	} else if dst.ConfigMapKeyRef == nil {
		dst.ConfigMapKeyRef = src.ConfigMapKeyRef
	}
	if dst.SecretKeyRef != nil && src.SecretKeyRef != nil {
		overlayAtomicSecretKeySelector(dst.SecretKeyRef, src.SecretKeyRef)
	} else if dst.SecretKeyRef == nil {
		dst.SecretKeyRef = src.SecretKeyRef
	}
}
func overlayAtomicObjectFieldSelector(dst, src *v1.ObjectFieldSelector) {
	*dst = *src
}
func overlayAtomicResourceFieldSelector(dst, src *v1.ResourceFieldSelector) {
	*dst = *src
}
func overlayAtomicConfigMapKeySelector(dst, src *v1.ConfigMapKeySelector) {
	*dst = *src
}
func overlayAtomicSecretKeySelector(dst, src *v1.SecretKeySelector) {
	*dst = *src
}
func overlayResourceRequirements(dst, src *v1.ResourceRequirements) {
	if dst.Limits != nil && src.Limits != nil {
		overlayResourceList(&(dst.Limits), &(src.Limits))
	} else if dst.Limits == nil {
		dst.Limits = src.Limits
	}
	if dst.Requests != nil && src.Requests != nil {
		overlayResourceList(&(dst.Requests), &(src.Requests))
	} else if dst.Requests == nil {
		dst.Requests = src.Requests
	}
	if dst.Claims != nil && src.Claims != nil {
		overlayMapListSliceResourceClaim(&(dst.Claims), &(src.Claims))
	} else if dst.Claims == nil {
		dst.Claims = src.Claims
	}
}
func overlayMapListSliceResourceClaim(dst, src *[]v1.ResourceClaim) {
	m := map[string]int{}
	for i := range *dst {
		item := (*dst)[i]
		keys := []string{}
		keys = append(keys, StringToString(item.Name))
		key := strings.Join(keys, ",")
		m[key] = i
	}
	for si := range *src {
		item := (*src)[si]
		keys := []string{}
		keys = append(keys, StringToString(item.Name))
		key := strings.Join(keys, ",")
		di, ok := m[key]
		if !ok {
			*dst = append(*dst, item)
			continue
		}
		overlayResourceClaim(&((*dst)[di]), &((*src)[si]))
	}
}
func overlayResourceClaim(dst, src *v1.ResourceClaim) {
	if src.Name != "" {
		dst.Name = src.Name
	}
	if src.Request != "" {
		dst.Request = src.Request
	}
}
func overlayAtomicListSliceContainerResizePolicy(dst, src *[]v1.ContainerResizePolicy) {
	if len(*src) == 0 {
		return
	}
	*dst = *src
}
func overlayContainerRestartPolicy(dst, src *v1.ContainerRestartPolicy) {
	ndst := (*string)(dst)
	nsrc := (*string)(src)
	if *nsrc != "" {
		*ndst = *nsrc
	}
}
func overlayMapListSliceVolumeMount(dst, src *[]v1.VolumeMount) {
	m := map[string]int{}
	for i := range *dst {
		item := (*dst)[i]
		keys := []string{}
		keys = append(keys, StringToString(item.MountPath))
		key := strings.Join(keys, ",")
		m[key] = i
	}
	for si := range *src {
		item := (*src)[si]
		keys := []string{}
		keys = append(keys, StringToString(item.MountPath))
		key := strings.Join(keys, ",")
		di, ok := m[key]
		if !ok {
			*dst = append(*dst, item)
			continue
		}
		overlayVolumeMount(&((*dst)[di]), &((*src)[si]))
	}
}
func overlayVolumeMount(dst, src *v1.VolumeMount) {
	if src.Name != "" {
		dst.Name = src.Name
	}
	if src.ReadOnly {
		dst.ReadOnly = src.ReadOnly
	}
	if dst.RecursiveReadOnly != nil && src.RecursiveReadOnly != nil {
		overlayRecursiveReadOnlyMode(dst.RecursiveReadOnly, src.RecursiveReadOnly)
	} else if dst.RecursiveReadOnly == nil {
		dst.RecursiveReadOnly = src.RecursiveReadOnly
	}
	if src.MountPath != "" {
		dst.MountPath = src.MountPath
	}
	if src.SubPath != "" {
		dst.SubPath = src.SubPath
	}
	if dst.MountPropagation != nil && src.MountPropagation != nil {
		overlayMountPropagationMode(dst.MountPropagation, src.MountPropagation)
	} else if dst.MountPropagation == nil {
		dst.MountPropagation = src.MountPropagation
	}
	if src.SubPathExpr != "" {
		dst.SubPathExpr = src.SubPathExpr
	}
}
func overlayRecursiveReadOnlyMode(dst, src *v1.RecursiveReadOnlyMode) {
	ndst := (*string)(dst)
	nsrc := (*string)(src)
	if *nsrc != "" {
		*ndst = *nsrc
	}
}
func overlayMountPropagationMode(dst, src *v1.MountPropagationMode) {
	ndst := (*string)(dst)
	nsrc := (*string)(src)
	if *nsrc != "" {
		*ndst = *nsrc
	}
}
func overlayMapListSliceVolumeDevice(dst, src *[]v1.VolumeDevice) {
	m := map[string]int{}
	for i := range *dst {
		item := (*dst)[i]
		keys := []string{}
		keys = append(keys, StringToString(item.DevicePath))
		key := strings.Join(keys, ",")
		m[key] = i
	}
	for si := range *src {
		item := (*src)[si]
		keys := []string{}
		keys = append(keys, StringToString(item.DevicePath))
		key := strings.Join(keys, ",")
		di, ok := m[key]
		if !ok {
			*dst = append(*dst, item)
			continue
		}
		overlayVolumeDevice(&((*dst)[di]), &((*src)[si]))
	}
}
func overlayVolumeDevice(dst, src *v1.VolumeDevice) {
	if src.Name != "" {
		dst.Name = src.Name
	}
	if src.DevicePath != "" {
		dst.DevicePath = src.DevicePath
	}
}
func overlayProbe(dst, src *v1.Probe) {
	overlayProbeHandler(&(dst.ProbeHandler), &(src.ProbeHandler))
	if src.InitialDelaySeconds != 0 {
		dst.InitialDelaySeconds = src.InitialDelaySeconds
	}
	if src.TimeoutSeconds != 0 {
		dst.TimeoutSeconds = src.TimeoutSeconds
	}
	if src.PeriodSeconds != 0 {
		dst.PeriodSeconds = src.PeriodSeconds
	}
	if src.SuccessThreshold != 0 {
		dst.SuccessThreshold = src.SuccessThreshold
	}
	if src.FailureThreshold != 0 {
		dst.FailureThreshold = src.FailureThreshold
	}
	if dst.TerminationGracePeriodSeconds != nil && src.TerminationGracePeriodSeconds != nil {
		if *src.TerminationGracePeriodSeconds != 0 {
			*dst.TerminationGracePeriodSeconds = *src.TerminationGracePeriodSeconds
		}
	} else if dst.TerminationGracePeriodSeconds == nil {
		dst.TerminationGracePeriodSeconds = src.TerminationGracePeriodSeconds
	}
}
func overlayProbeHandler(dst, src *v1.ProbeHandler) {
	if dst.Exec != nil && src.Exec != nil {
		overlayExecAction(dst.Exec, src.Exec)
	} else if dst.Exec == nil {
		dst.Exec = src.Exec
	}
	if dst.HTTPGet != nil && src.HTTPGet != nil {
		overlayHTTPGetAction(dst.HTTPGet, src.HTTPGet)
	} else if dst.HTTPGet == nil {
		dst.HTTPGet = src.HTTPGet
	}
	if dst.TCPSocket != nil && src.TCPSocket != nil {
		overlayTCPSocketAction(dst.TCPSocket, src.TCPSocket)
	} else if dst.TCPSocket == nil {
		dst.TCPSocket = src.TCPSocket
	}
	if dst.GRPC != nil && src.GRPC != nil {
		overlayGRPCAction(dst.GRPC, src.GRPC)
	} else if dst.GRPC == nil {
		dst.GRPC = src.GRPC
	}
}
func overlayExecAction(dst, src *v1.ExecAction) {
	if dst.Command != nil && src.Command != nil {
		overlayAtomicListSliceString(&(dst.Command), &(src.Command))
	} else if dst.Command == nil {
		dst.Command = src.Command
	}
}
func overlayHTTPGetAction(dst, src *v1.HTTPGetAction) {
	if src.Path != "" {
		dst.Path = src.Path
	}
	overlayIntOrString(&(dst.Port), &(src.Port))
	if src.Host != "" {
		dst.Host = src.Host
	}
	overlayURIScheme(&(dst.Scheme), &(src.Scheme))
	if dst.HTTPHeaders != nil && src.HTTPHeaders != nil {
		overlayAtomicListSliceHTTPHeader(&(dst.HTTPHeaders), &(src.HTTPHeaders))
	} else if dst.HTTPHeaders == nil {
		dst.HTTPHeaders = src.HTTPHeaders
	}
}
func overlayIntOrString(dst, src *intstr.IntOrString) {
	overlayType(&(dst.Type), &(src.Type))
	if src.IntVal != 0 {
		dst.IntVal = src.IntVal
	}
	if src.StrVal != "" {
		dst.StrVal = src.StrVal
	}
}
func overlayType(dst, src *intstr.Type) {
	ndst := (*int64)(dst)
	nsrc := (*int64)(src)
	if *nsrc != 0 {
		*ndst = *nsrc
	}
}
func overlayURIScheme(dst, src *v1.URIScheme) {
	ndst := (*string)(dst)
	nsrc := (*string)(src)
	if *nsrc != "" {
		*ndst = *nsrc
	}
}
func overlayAtomicListSliceHTTPHeader(dst, src *[]v1.HTTPHeader) {
	if len(*src) == 0 {
		return
	}
	*dst = *src
}
func overlayTCPSocketAction(dst, src *v1.TCPSocketAction) {
	overlayIntOrString(&(dst.Port), &(src.Port))
	if src.Host != "" {
		dst.Host = src.Host
	}
}
func overlayGRPCAction(dst, src *v1.GRPCAction) {
	if src.Port != 0 {
		dst.Port = src.Port
	}
	if dst.Service != nil && src.Service != nil {
		if *src.Service != "" {
			*dst.Service = *src.Service
		}
	} else if dst.Service == nil {
		dst.Service = src.Service
	}
}
func overlayLifecycle(dst, src *v1.Lifecycle) {
	if dst.PostStart != nil && src.PostStart != nil {
		overlayLifecycleHandler(dst.PostStart, src.PostStart)
	} else if dst.PostStart == nil {
		dst.PostStart = src.PostStart
	}
	if dst.PreStop != nil && src.PreStop != nil {
		overlayLifecycleHandler(dst.PreStop, src.PreStop)
	} else if dst.PreStop == nil {
		dst.PreStop = src.PreStop
	}
}
func overlayLifecycleHandler(dst, src *v1.LifecycleHandler) {
	if dst.Exec != nil && src.Exec != nil {
		overlayExecAction(dst.Exec, src.Exec)
	} else if dst.Exec == nil {
		dst.Exec = src.Exec
	}
	if dst.HTTPGet != nil && src.HTTPGet != nil {
		overlayHTTPGetAction(dst.HTTPGet, src.HTTPGet)
	} else if dst.HTTPGet == nil {
		dst.HTTPGet = src.HTTPGet
	}
	if dst.TCPSocket != nil && src.TCPSocket != nil {
		overlayTCPSocketAction(dst.TCPSocket, src.TCPSocket)
	} else if dst.TCPSocket == nil {
		dst.TCPSocket = src.TCPSocket
	}
	if dst.Sleep != nil && src.Sleep != nil {
		overlaySleepAction(dst.Sleep, src.Sleep)
	} else if dst.Sleep == nil {
		dst.Sleep = src.Sleep
	}
}
func overlaySleepAction(dst, src *v1.SleepAction) {
	if src.Seconds != 0 {
		dst.Seconds = src.Seconds
	}
}
func overlayTerminationMessagePolicy(dst, src *v1.TerminationMessagePolicy) {
	ndst := (*string)(dst)
	nsrc := (*string)(src)
	if *nsrc != "" {
		*ndst = *nsrc
	}
}
func overlaySecurityContext(dst, src *v1.SecurityContext) {
	if dst.Capabilities != nil && src.Capabilities != nil {
		overlayCapabilities(dst.Capabilities, src.Capabilities)
	} else if dst.Capabilities == nil {
		dst.Capabilities = src.Capabilities
	}
	if dst.Privileged != nil && src.Privileged != nil {
		if *src.Privileged {
			*dst.Privileged = *src.Privileged
		}
	} else if dst.Privileged == nil {
		dst.Privileged = src.Privileged
	}
	if dst.SELinuxOptions != nil && src.SELinuxOptions != nil {
		overlaySELinuxOptions(dst.SELinuxOptions, src.SELinuxOptions)
	} else if dst.SELinuxOptions == nil {
		dst.SELinuxOptions = src.SELinuxOptions
	}
	if dst.WindowsOptions != nil && src.WindowsOptions != nil {
		overlayWindowsSecurityContextOptions(dst.WindowsOptions, src.WindowsOptions)
	} else if dst.WindowsOptions == nil {
		dst.WindowsOptions = src.WindowsOptions
	}
	if dst.RunAsUser != nil && src.RunAsUser != nil {
		if *src.RunAsUser != 0 {
			*dst.RunAsUser = *src.RunAsUser
		}
	} else if dst.RunAsUser == nil {
		dst.RunAsUser = src.RunAsUser
	}
	if dst.RunAsGroup != nil && src.RunAsGroup != nil {
		if *src.RunAsGroup != 0 {
			*dst.RunAsGroup = *src.RunAsGroup
		}
	} else if dst.RunAsGroup == nil {
		dst.RunAsGroup = src.RunAsGroup
	}
	if dst.RunAsNonRoot != nil && src.RunAsNonRoot != nil {
		if *src.RunAsNonRoot {
			*dst.RunAsNonRoot = *src.RunAsNonRoot
		}
	} else if dst.RunAsNonRoot == nil {
		dst.RunAsNonRoot = src.RunAsNonRoot
	}
	if dst.ReadOnlyRootFilesystem != nil && src.ReadOnlyRootFilesystem != nil {
		if *src.ReadOnlyRootFilesystem {
			*dst.ReadOnlyRootFilesystem = *src.ReadOnlyRootFilesystem
		}
	} else if dst.ReadOnlyRootFilesystem == nil {
		dst.ReadOnlyRootFilesystem = src.ReadOnlyRootFilesystem
	}
	if dst.AllowPrivilegeEscalation != nil && src.AllowPrivilegeEscalation != nil {
		if *src.AllowPrivilegeEscalation {
			*dst.AllowPrivilegeEscalation = *src.AllowPrivilegeEscalation
		}
	} else if dst.AllowPrivilegeEscalation == nil {
		dst.AllowPrivilegeEscalation = src.AllowPrivilegeEscalation
	}
	if dst.ProcMount != nil && src.ProcMount != nil {
		overlayProcMountType(dst.ProcMount, src.ProcMount)
	} else if dst.ProcMount == nil {
		dst.ProcMount = src.ProcMount
	}
	if dst.SeccompProfile != nil && src.SeccompProfile != nil {
		overlaySeccompProfile(dst.SeccompProfile, src.SeccompProfile)
	} else if dst.SeccompProfile == nil {
		dst.SeccompProfile = src.SeccompProfile
	}
	if dst.AppArmorProfile != nil && src.AppArmorProfile != nil {
		overlayAppArmorProfile(dst.AppArmorProfile, src.AppArmorProfile)
	} else if dst.AppArmorProfile == nil {
		dst.AppArmorProfile = src.AppArmorProfile
	}
}
func overlayCapabilities(dst, src *v1.Capabilities) {
	if dst.Add != nil && src.Add != nil {
		overlayAtomicListSliceCapability(&(dst.Add), &(src.Add))
	} else if dst.Add == nil {
		dst.Add = src.Add
	}
	if dst.Drop != nil && src.Drop != nil {
		overlayAtomicListSliceCapability(&(dst.Drop), &(src.Drop))
	} else if dst.Drop == nil {
		dst.Drop = src.Drop
	}
}
func overlayAtomicListSliceCapability(dst, src *[]v1.Capability) {
	if len(*src) == 0 {
		return
	}
	*dst = *src
}
func overlaySELinuxOptions(dst, src *v1.SELinuxOptions) {
	if src.User != "" {
		dst.User = src.User
	}
	if src.Role != "" {
		dst.Role = src.Role
	}
	if src.Type != "" {
		dst.Type = src.Type
	}
	if src.Level != "" {
		dst.Level = src.Level
	}
}
func overlayWindowsSecurityContextOptions(dst, src *v1.WindowsSecurityContextOptions) {
	if dst.GMSACredentialSpecName != nil && src.GMSACredentialSpecName != nil {
		if *src.GMSACredentialSpecName != "" {
			*dst.GMSACredentialSpecName = *src.GMSACredentialSpecName
		}
	} else if dst.GMSACredentialSpecName == nil {
		dst.GMSACredentialSpecName = src.GMSACredentialSpecName
	}
	if dst.GMSACredentialSpec != nil && src.GMSACredentialSpec != nil {
		if *src.GMSACredentialSpec != "" {
			*dst.GMSACredentialSpec = *src.GMSACredentialSpec
		}
	} else if dst.GMSACredentialSpec == nil {
		dst.GMSACredentialSpec = src.GMSACredentialSpec
	}
	if dst.RunAsUserName != nil && src.RunAsUserName != nil {
		if *src.RunAsUserName != "" {
			*dst.RunAsUserName = *src.RunAsUserName
		}
	} else if dst.RunAsUserName == nil {
		dst.RunAsUserName = src.RunAsUserName
	}
	if dst.HostProcess != nil && src.HostProcess != nil {
		if *src.HostProcess {
			*dst.HostProcess = *src.HostProcess
		}
	} else if dst.HostProcess == nil {
		dst.HostProcess = src.HostProcess
	}
}
func overlayProcMountType(dst, src *v1.ProcMountType) {
	ndst := (*string)(dst)
	nsrc := (*string)(src)
	if *nsrc != "" {
		*ndst = *nsrc
	}
}
func overlaySeccompProfile(dst, src *v1.SeccompProfile) {
	overlaySeccompProfileType(&(dst.Type), &(src.Type))
	if dst.LocalhostProfile != nil && src.LocalhostProfile != nil {
		if *src.LocalhostProfile != "" {
			*dst.LocalhostProfile = *src.LocalhostProfile
		}
	} else if dst.LocalhostProfile == nil {
		dst.LocalhostProfile = src.LocalhostProfile
	}
}
func overlaySeccompProfileType(dst, src *v1.SeccompProfileType) {
	ndst := (*string)(dst)
	nsrc := (*string)(src)
	if *nsrc != "" {
		*ndst = *nsrc
	}
}
func overlayAppArmorProfile(dst, src *v1.AppArmorProfile) {
	overlayAppArmorProfileType(&(dst.Type), &(src.Type))
	if dst.LocalhostProfile != nil && src.LocalhostProfile != nil {
		if *src.LocalhostProfile != "" {
			*dst.LocalhostProfile = *src.LocalhostProfile
		}
	} else if dst.LocalhostProfile == nil {
		dst.LocalhostProfile = src.LocalhostProfile
	}
}
func overlayAppArmorProfileType(dst, src *v1.AppArmorProfileType) {
	ndst := (*string)(dst)
	nsrc := (*string)(src)
	if *nsrc != "" {
		*ndst = *nsrc
	}
}
func overlayMapListSliceEphemeralContainer(dst, src *[]v1.EphemeralContainer) {
	m := map[string]int{}
	for i := range *dst {
		item := (*dst)[i]
		keys := []string{}
		keys = append(keys, StringToString(item.Name))
		key := strings.Join(keys, ",")
		m[key] = i
	}
	for si := range *src {
		item := (*src)[si]
		keys := []string{}
		keys = append(keys, StringToString(item.Name))
		key := strings.Join(keys, ",")
		di, ok := m[key]
		if !ok {
			*dst = append(*dst, item)
			continue
		}
		overlayEphemeralContainer(&((*dst)[di]), &((*src)[si]))
	}
}
func overlayEphemeralContainer(dst, src *v1.EphemeralContainer) {
	overlayEphemeralContainerCommon(&(dst.EphemeralContainerCommon), &(src.EphemeralContainerCommon))
	if src.TargetContainerName != "" {
		dst.TargetContainerName = src.TargetContainerName
	}
}
func overlayEphemeralContainerCommon(dst, src *v1.EphemeralContainerCommon) {
	if src.Name != "" {
		dst.Name = src.Name
	}
	if src.Image != "" {
		dst.Image = src.Image
	}
	if dst.Command != nil && src.Command != nil {
		overlayAtomicListSliceString(&(dst.Command), &(src.Command))
	} else if dst.Command == nil {
		dst.Command = src.Command
	}
	if dst.Args != nil && src.Args != nil {
		overlayAtomicListSliceString(&(dst.Args), &(src.Args))
	} else if dst.Args == nil {
		dst.Args = src.Args
	}
	if src.WorkingDir != "" {
		dst.WorkingDir = src.WorkingDir
	}
	if dst.Ports != nil && src.Ports != nil {
		overlayMapListSliceContainerPort(&(dst.Ports), &(src.Ports))
	} else if dst.Ports == nil {
		dst.Ports = src.Ports
	}
	if dst.EnvFrom != nil && src.EnvFrom != nil {
		overlayAtomicListSliceEnvFromSource(&(dst.EnvFrom), &(src.EnvFrom))
	} else if dst.EnvFrom == nil {
		dst.EnvFrom = src.EnvFrom
	}
	if dst.Env != nil && src.Env != nil {
		overlayMapListSliceEnvVar(&(dst.Env), &(src.Env))
	} else if dst.Env == nil {
		dst.Env = src.Env
	}
	overlayResourceRequirements(&(dst.Resources), &(src.Resources))
	if dst.ResizePolicy != nil && src.ResizePolicy != nil {
		overlayAtomicListSliceContainerResizePolicy(&(dst.ResizePolicy), &(src.ResizePolicy))
	} else if dst.ResizePolicy == nil {
		dst.ResizePolicy = src.ResizePolicy
	}
	if dst.RestartPolicy != nil && src.RestartPolicy != nil {
		overlayContainerRestartPolicy(dst.RestartPolicy, src.RestartPolicy)
	} else if dst.RestartPolicy == nil {
		dst.RestartPolicy = src.RestartPolicy
	}
	if dst.VolumeMounts != nil && src.VolumeMounts != nil {
		overlayMapListSliceVolumeMount(&(dst.VolumeMounts), &(src.VolumeMounts))
	} else if dst.VolumeMounts == nil {
		dst.VolumeMounts = src.VolumeMounts
	}
	if dst.VolumeDevices != nil && src.VolumeDevices != nil {
		overlayMapListSliceVolumeDevice(&(dst.VolumeDevices), &(src.VolumeDevices))
	} else if dst.VolumeDevices == nil {
		dst.VolumeDevices = src.VolumeDevices
	}
	if dst.LivenessProbe != nil && src.LivenessProbe != nil {
		overlayProbe(dst.LivenessProbe, src.LivenessProbe)
	} else if dst.LivenessProbe == nil {
		dst.LivenessProbe = src.LivenessProbe
	}
	if dst.ReadinessProbe != nil && src.ReadinessProbe != nil {
		overlayProbe(dst.ReadinessProbe, src.ReadinessProbe)
	} else if dst.ReadinessProbe == nil {
		dst.ReadinessProbe = src.ReadinessProbe
	}
	if dst.StartupProbe != nil && src.StartupProbe != nil {
		overlayProbe(dst.StartupProbe, src.StartupProbe)
	} else if dst.StartupProbe == nil {
		dst.StartupProbe = src.StartupProbe
	}
	if dst.Lifecycle != nil && src.Lifecycle != nil {
		overlayLifecycle(dst.Lifecycle, src.Lifecycle)
	} else if dst.Lifecycle == nil {
		dst.Lifecycle = src.Lifecycle
	}
	if src.TerminationMessagePath != "" {
		dst.TerminationMessagePath = src.TerminationMessagePath
	}
	overlayTerminationMessagePolicy(&(dst.TerminationMessagePolicy), &(src.TerminationMessagePolicy))
	overlayPullPolicy(&(dst.ImagePullPolicy), &(src.ImagePullPolicy))
	if dst.SecurityContext != nil && src.SecurityContext != nil {
		overlaySecurityContext(dst.SecurityContext, src.SecurityContext)
	} else if dst.SecurityContext == nil {
		dst.SecurityContext = src.SecurityContext
	}
	if src.Stdin {
		dst.Stdin = src.Stdin
	}
	if src.StdinOnce {
		dst.StdinOnce = src.StdinOnce
	}
	if src.TTY {
		dst.TTY = src.TTY
	}
}
func overlayRestartPolicy(dst, src *v1.RestartPolicy) {
	ndst := (*string)(dst)
	nsrc := (*string)(src)
	if *nsrc != "" {
		*ndst = *nsrc
	}
}
func overlayDNSPolicy(dst, src *v1.DNSPolicy) {
	ndst := (*string)(dst)
	nsrc := (*string)(src)
	if *nsrc != "" {
		*ndst = *nsrc
	}
}
func overlayAtomicMapStringToString(dst, src *map[string]string) {
	if len(*src) == 0 {
		return
	}
	*dst = *src
}
func overlayPodSecurityContext(dst, src *v1.PodSecurityContext) {
	if dst.SELinuxOptions != nil && src.SELinuxOptions != nil {
		overlaySELinuxOptions(dst.SELinuxOptions, src.SELinuxOptions)
	} else if dst.SELinuxOptions == nil {
		dst.SELinuxOptions = src.SELinuxOptions
	}
	if dst.WindowsOptions != nil && src.WindowsOptions != nil {
		overlayWindowsSecurityContextOptions(dst.WindowsOptions, src.WindowsOptions)
	} else if dst.WindowsOptions == nil {
		dst.WindowsOptions = src.WindowsOptions
	}
	if dst.RunAsUser != nil && src.RunAsUser != nil {
		if *src.RunAsUser != 0 {
			*dst.RunAsUser = *src.RunAsUser
		}
	} else if dst.RunAsUser == nil {
		dst.RunAsUser = src.RunAsUser
	}
	if dst.RunAsGroup != nil && src.RunAsGroup != nil {
		if *src.RunAsGroup != 0 {
			*dst.RunAsGroup = *src.RunAsGroup
		}
	} else if dst.RunAsGroup == nil {
		dst.RunAsGroup = src.RunAsGroup
	}
	if dst.RunAsNonRoot != nil && src.RunAsNonRoot != nil {
		if *src.RunAsNonRoot {
			*dst.RunAsNonRoot = *src.RunAsNonRoot
		}
	} else if dst.RunAsNonRoot == nil {
		dst.RunAsNonRoot = src.RunAsNonRoot
	}
	if dst.SupplementalGroups != nil && src.SupplementalGroups != nil {
		overlayAtomicListSliceInt64(&(dst.SupplementalGroups), &(src.SupplementalGroups))
	} else if dst.SupplementalGroups == nil {
		dst.SupplementalGroups = src.SupplementalGroups
	}
	if dst.SupplementalGroupsPolicy != nil && src.SupplementalGroupsPolicy != nil {
		overlaySupplementalGroupsPolicy(dst.SupplementalGroupsPolicy, src.SupplementalGroupsPolicy)
	} else if dst.SupplementalGroupsPolicy == nil {
		dst.SupplementalGroupsPolicy = src.SupplementalGroupsPolicy
	}
	if dst.FSGroup != nil && src.FSGroup != nil {
		if *src.FSGroup != 0 {
			*dst.FSGroup = *src.FSGroup
		}
	} else if dst.FSGroup == nil {
		dst.FSGroup = src.FSGroup
	}
	if dst.Sysctls != nil && src.Sysctls != nil {
		overlayAtomicListSliceSysctl(&(dst.Sysctls), &(src.Sysctls))
	} else if dst.Sysctls == nil {
		dst.Sysctls = src.Sysctls
	}
	if dst.FSGroupChangePolicy != nil && src.FSGroupChangePolicy != nil {
		overlayPodFSGroupChangePolicy(dst.FSGroupChangePolicy, src.FSGroupChangePolicy)
	} else if dst.FSGroupChangePolicy == nil {
		dst.FSGroupChangePolicy = src.FSGroupChangePolicy
	}
	if dst.SeccompProfile != nil && src.SeccompProfile != nil {
		overlaySeccompProfile(dst.SeccompProfile, src.SeccompProfile)
	} else if dst.SeccompProfile == nil {
		dst.SeccompProfile = src.SeccompProfile
	}
	if dst.AppArmorProfile != nil && src.AppArmorProfile != nil {
		overlayAppArmorProfile(dst.AppArmorProfile, src.AppArmorProfile)
	} else if dst.AppArmorProfile == nil {
		dst.AppArmorProfile = src.AppArmorProfile
	}
}
func overlayAtomicListSliceInt64(dst, src *[]int64) {
	if len(*src) == 0 {
		return
	}
	*dst = *src
}
func overlaySupplementalGroupsPolicy(dst, src *v1.SupplementalGroupsPolicy) {
	ndst := (*string)(dst)
	nsrc := (*string)(src)
	if *nsrc != "" {
		*ndst = *nsrc
	}
}
func overlayAtomicListSliceSysctl(dst, src *[]v1.Sysctl) {
	if len(*src) == 0 {
		return
	}
	*dst = *src
}
func overlayPodFSGroupChangePolicy(dst, src *v1.PodFSGroupChangePolicy) {
	ndst := (*string)(dst)
	nsrc := (*string)(src)
	if *nsrc != "" {
		*ndst = *nsrc
	}
}
func overlayMapListSliceLocalObjectReference(dst, src *[]v1.LocalObjectReference) {
	m := map[string]int{}
	for i := range *dst {
		item := (*dst)[i]
		keys := []string{}
		keys = append(keys, StringToString(item.Name))
		key := strings.Join(keys, ",")
		m[key] = i
	}
	for si := range *src {
		item := (*src)[si]
		keys := []string{}
		keys = append(keys, StringToString(item.Name))
		key := strings.Join(keys, ",")
		di, ok := m[key]
		if !ok {
			*dst = append(*dst, item)
			continue
		}
		overlayAtomicLocalObjectReference(&((*dst)[di]), &((*src)[si]))
	}
}
func overlayAffinity(dst, src *v1.Affinity) {
	if dst.NodeAffinity != nil && src.NodeAffinity != nil {
		overlayNodeAffinity(dst.NodeAffinity, src.NodeAffinity)
	} else if dst.NodeAffinity == nil {
		dst.NodeAffinity = src.NodeAffinity
	}
	if dst.PodAffinity != nil && src.PodAffinity != nil {
		overlayPodAffinity(dst.PodAffinity, src.PodAffinity)
	} else if dst.PodAffinity == nil {
		dst.PodAffinity = src.PodAffinity
	}
	if dst.PodAntiAffinity != nil && src.PodAntiAffinity != nil {
		overlayPodAntiAffinity(dst.PodAntiAffinity, src.PodAntiAffinity)
	} else if dst.PodAntiAffinity == nil {
		dst.PodAntiAffinity = src.PodAntiAffinity
	}
}
func overlayNodeAffinity(dst, src *v1.NodeAffinity) {
	if dst.RequiredDuringSchedulingIgnoredDuringExecution != nil && src.RequiredDuringSchedulingIgnoredDuringExecution != nil {
		overlayAtomicNodeSelector(dst.RequiredDuringSchedulingIgnoredDuringExecution, src.RequiredDuringSchedulingIgnoredDuringExecution)
	} else if dst.RequiredDuringSchedulingIgnoredDuringExecution == nil {
		dst.RequiredDuringSchedulingIgnoredDuringExecution = src.RequiredDuringSchedulingIgnoredDuringExecution
	}
	if dst.PreferredDuringSchedulingIgnoredDuringExecution != nil && src.PreferredDuringSchedulingIgnoredDuringExecution != nil {
		overlayAtomicListSlicePreferredSchedulingTerm(&(dst.PreferredDuringSchedulingIgnoredDuringExecution), &(src.PreferredDuringSchedulingIgnoredDuringExecution))
	} else if dst.PreferredDuringSchedulingIgnoredDuringExecution == nil {
		dst.PreferredDuringSchedulingIgnoredDuringExecution = src.PreferredDuringSchedulingIgnoredDuringExecution
	}
}
func overlayAtomicNodeSelector(dst, src *v1.NodeSelector) {
	*dst = *src
}
func overlayAtomicListSlicePreferredSchedulingTerm(dst, src *[]v1.PreferredSchedulingTerm) {
	if len(*src) == 0 {
		return
	}
	*dst = *src
}
func overlayPodAffinity(dst, src *v1.PodAffinity) {
	if dst.RequiredDuringSchedulingIgnoredDuringExecution != nil && src.RequiredDuringSchedulingIgnoredDuringExecution != nil {
		overlayAtomicListSlicePodAffinityTerm(&(dst.RequiredDuringSchedulingIgnoredDuringExecution), &(src.RequiredDuringSchedulingIgnoredDuringExecution))
	} else if dst.RequiredDuringSchedulingIgnoredDuringExecution == nil {
		dst.RequiredDuringSchedulingIgnoredDuringExecution = src.RequiredDuringSchedulingIgnoredDuringExecution
	}
	if dst.PreferredDuringSchedulingIgnoredDuringExecution != nil && src.PreferredDuringSchedulingIgnoredDuringExecution != nil {
		overlayAtomicListSliceWeightedPodAffinityTerm(&(dst.PreferredDuringSchedulingIgnoredDuringExecution), &(src.PreferredDuringSchedulingIgnoredDuringExecution))
	} else if dst.PreferredDuringSchedulingIgnoredDuringExecution == nil {
		dst.PreferredDuringSchedulingIgnoredDuringExecution = src.PreferredDuringSchedulingIgnoredDuringExecution
	}
}
func overlayAtomicListSlicePodAffinityTerm(dst, src *[]v1.PodAffinityTerm) {
	if len(*src) == 0 {
		return
	}
	*dst = *src
}
func overlayAtomicListSliceWeightedPodAffinityTerm(dst, src *[]v1.WeightedPodAffinityTerm) {
	if len(*src) == 0 {
		return
	}
	*dst = *src
}
func overlayPodAntiAffinity(dst, src *v1.PodAntiAffinity) {
	if dst.RequiredDuringSchedulingIgnoredDuringExecution != nil && src.RequiredDuringSchedulingIgnoredDuringExecution != nil {
		overlayAtomicListSlicePodAffinityTerm(&(dst.RequiredDuringSchedulingIgnoredDuringExecution), &(src.RequiredDuringSchedulingIgnoredDuringExecution))
	} else if dst.RequiredDuringSchedulingIgnoredDuringExecution == nil {
		dst.RequiredDuringSchedulingIgnoredDuringExecution = src.RequiredDuringSchedulingIgnoredDuringExecution
	}
	if dst.PreferredDuringSchedulingIgnoredDuringExecution != nil && src.PreferredDuringSchedulingIgnoredDuringExecution != nil {
		overlayAtomicListSliceWeightedPodAffinityTerm(&(dst.PreferredDuringSchedulingIgnoredDuringExecution), &(src.PreferredDuringSchedulingIgnoredDuringExecution))
	} else if dst.PreferredDuringSchedulingIgnoredDuringExecution == nil {
		dst.PreferredDuringSchedulingIgnoredDuringExecution = src.PreferredDuringSchedulingIgnoredDuringExecution
	}
}
func overlayAtomicListSliceToleration(dst, src *[]v1.Toleration) {
	if len(*src) == 0 {
		return
	}
	*dst = *src
}
func overlayMapListSliceHostAlias(dst, src *[]v1.HostAlias) {
	m := map[string]int{}
	for i := range *dst {
		item := (*dst)[i]
		keys := []string{}
		keys = append(keys, StringToString(item.IP))
		key := strings.Join(keys, ",")
		m[key] = i
	}
	for si := range *src {
		item := (*src)[si]
		keys := []string{}
		keys = append(keys, StringToString(item.IP))
		key := strings.Join(keys, ",")
		di, ok := m[key]
		if !ok {
			*dst = append(*dst, item)
			continue
		}
		overlayHostAlias(&((*dst)[di]), &((*src)[si]))
	}
}
func overlayHostAlias(dst, src *v1.HostAlias) {
	if src.IP != "" {
		dst.IP = src.IP
	}
	if dst.Hostnames != nil && src.Hostnames != nil {
		overlayAtomicListSliceString(&(dst.Hostnames), &(src.Hostnames))
	} else if dst.Hostnames == nil {
		dst.Hostnames = src.Hostnames
	}
}
func overlayPodDNSConfig(dst, src *v1.PodDNSConfig) {
	if dst.Nameservers != nil && src.Nameservers != nil {
		overlayAtomicListSliceString(&(dst.Nameservers), &(src.Nameservers))
	} else if dst.Nameservers == nil {
		dst.Nameservers = src.Nameservers
	}
	if dst.Searches != nil && src.Searches != nil {
		overlayAtomicListSliceString(&(dst.Searches), &(src.Searches))
	} else if dst.Searches == nil {
		dst.Searches = src.Searches
	}
	if dst.Options != nil && src.Options != nil {
		overlayAtomicListSlicePodDNSConfigOption(&(dst.Options), &(src.Options))
	} else if dst.Options == nil {
		dst.Options = src.Options
	}
}
func overlayAtomicListSlicePodDNSConfigOption(dst, src *[]v1.PodDNSConfigOption) {
	if len(*src) == 0 {
		return
	}
	*dst = *src
}
func overlayAtomicListSlicePodReadinessGate(dst, src *[]v1.PodReadinessGate) {
	if len(*src) == 0 {
		return
	}
	*dst = *src
}
func overlayPreemptionPolicy(dst, src *v1.PreemptionPolicy) {
	ndst := (*string)(dst)
	nsrc := (*string)(src)
	if *nsrc != "" {
		*ndst = *nsrc
	}
}
func overlayMapListSliceTopologySpreadConstraint(dst, src *[]v1.TopologySpreadConstraint) {
	m := map[string]int{}
	for i := range *dst {
		item := (*dst)[i]
		keys := []string{}
		keys = append(keys, StringToString(item.TopologyKey))
		keys = append(keys, UnsatisfiableConstraintActionToString(item.WhenUnsatisfiable))
		key := strings.Join(keys, ",")
		m[key] = i
	}
	for si := range *src {
		item := (*src)[si]
		keys := []string{}
		keys = append(keys, StringToString(item.TopologyKey))
		keys = append(keys, UnsatisfiableConstraintActionToString(item.WhenUnsatisfiable))
		key := strings.Join(keys, ",")
		di, ok := m[key]
		if !ok {
			*dst = append(*dst, item)
			continue
		}
		overlayTopologySpreadConstraint(&((*dst)[di]), &((*src)[si]))
	}
}
func UnsatisfiableConstraintActionToString(val v1.UnsatisfiableConstraintAction) string {
	return StringToString(string(val))
}
func overlayTopologySpreadConstraint(dst, src *v1.TopologySpreadConstraint) {
	if src.MaxSkew != 0 {
		dst.MaxSkew = src.MaxSkew
	}
	if src.TopologyKey != "" {
		dst.TopologyKey = src.TopologyKey
	}
	overlayUnsatisfiableConstraintAction(&(dst.WhenUnsatisfiable), &(src.WhenUnsatisfiable))
	if dst.LabelSelector != nil && src.LabelSelector != nil {
		overlayLabelSelector(dst.LabelSelector, src.LabelSelector)
	} else if dst.LabelSelector == nil {
		dst.LabelSelector = src.LabelSelector
	}
	if dst.MinDomains != nil && src.MinDomains != nil {
		if *src.MinDomains != 0 {
			*dst.MinDomains = *src.MinDomains
		}
	} else if dst.MinDomains == nil {
		dst.MinDomains = src.MinDomains
	}
	if dst.NodeAffinityPolicy != nil && src.NodeAffinityPolicy != nil {
		overlayNodeInclusionPolicy(dst.NodeAffinityPolicy, src.NodeAffinityPolicy)
	} else if dst.NodeAffinityPolicy == nil {
		dst.NodeAffinityPolicy = src.NodeAffinityPolicy
	}
	if dst.NodeTaintsPolicy != nil && src.NodeTaintsPolicy != nil {
		overlayNodeInclusionPolicy(dst.NodeTaintsPolicy, src.NodeTaintsPolicy)
	} else if dst.NodeTaintsPolicy == nil {
		dst.NodeTaintsPolicy = src.NodeTaintsPolicy
	}
	if dst.MatchLabelKeys != nil && src.MatchLabelKeys != nil {
		overlayAtomicListSliceString(&(dst.MatchLabelKeys), &(src.MatchLabelKeys))
	} else if dst.MatchLabelKeys == nil {
		dst.MatchLabelKeys = src.MatchLabelKeys
	}
}
func overlayUnsatisfiableConstraintAction(dst, src *v1.UnsatisfiableConstraintAction) {
	ndst := (*string)(dst)
	nsrc := (*string)(src)
	if *nsrc != "" {
		*ndst = *nsrc
	}
}
func overlayNodeInclusionPolicy(dst, src *v1.NodeInclusionPolicy) {
	ndst := (*string)(dst)
	nsrc := (*string)(src)
	if *nsrc != "" {
		*ndst = *nsrc
	}
}
func overlayPodOS(dst, src *v1.PodOS) {
	overlayOSName(&(dst.Name), &(src.Name))
}
func overlayOSName(dst, src *v1.OSName) {
	ndst := (*string)(dst)
	nsrc := (*string)(src)
	if *nsrc != "" {
		*ndst = *nsrc
	}
}
func overlayMapListSlicePodSchedulingGate(dst, src *[]v1.PodSchedulingGate) {
	m := map[string]int{}
	for i := range *dst {
		item := (*dst)[i]
		keys := []string{}
		keys = append(keys, StringToString(item.Name))
		key := strings.Join(keys, ",")
		m[key] = i
	}
	for si := range *src {
		item := (*src)[si]
		keys := []string{}
		keys = append(keys, StringToString(item.Name))
		key := strings.Join(keys, ",")
		di, ok := m[key]
		if !ok {
			*dst = append(*dst, item)
			continue
		}
		overlayPodSchedulingGate(&((*dst)[di]), &((*src)[si]))
	}
}
func overlayPodSchedulingGate(dst, src *v1.PodSchedulingGate) {
	if src.Name != "" {
		dst.Name = src.Name
	}
}
func overlayMapListSlicePodResourceClaim(dst, src *[]v1.PodResourceClaim) {
	m := map[string]int{}
	for i := range *dst {
		item := (*dst)[i]
		keys := []string{}
		keys = append(keys, StringToString(item.Name))
		key := strings.Join(keys, ",")
		m[key] = i
	}
	for si := range *src {
		item := (*src)[si]
		keys := []string{}
		keys = append(keys, StringToString(item.Name))
		key := strings.Join(keys, ",")
		di, ok := m[key]
		if !ok {
			*dst = append(*dst, item)
			continue
		}
		overlayPodResourceClaim(&((*dst)[di]), &((*src)[si]))
	}
}
func overlayPodResourceClaim(dst, src *v1.PodResourceClaim) {
	if src.Name != "" {
		dst.Name = src.Name
	}
	if dst.ResourceClaimName != nil && src.ResourceClaimName != nil {
		if *src.ResourceClaimName != "" {
			*dst.ResourceClaimName = *src.ResourceClaimName
		}
	} else if dst.ResourceClaimName == nil {
		dst.ResourceClaimName = src.ResourceClaimName
	}
	if dst.ResourceClaimTemplateName != nil && src.ResourceClaimTemplateName != nil {
		if *src.ResourceClaimTemplateName != "" {
			*dst.ResourceClaimTemplateName = *src.ResourceClaimTemplateName
		}
	} else if dst.ResourceClaimTemplateName == nil {
		dst.ResourceClaimTemplateName = src.ResourceClaimTemplateName
	}
}
