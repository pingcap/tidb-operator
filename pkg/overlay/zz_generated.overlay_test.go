//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Copyright 2024 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by overlay-gen. DO NOT EDIT.

package overlay

import (
	v1 "k8s.io/api/core/v1"
	resource "k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	intstr "k8s.io/apimachinery/pkg/util/intstr"
)

func constructPodSpec(p Policy) []Case[v1.PodSpec] {
	cases := []Case[v1.PodSpec]{}
	cs0 := constructMapSliceVolume(NoLimit)
	cs1 := constructMapSliceContainer(NoLimit)
	cs2 := constructMapSliceContainer(NoLimit)
	cs3 := constructMapSliceEphemeralContainer(NoLimit)
	cs4 := constructRestartPolicy(NoLimit)
	cs5 := constructPointerInt64(NoLimit)
	cs6 := constructPointerInt64(NoLimit)
	cs7 := constructDNSPolicy(NoLimit)
	cs8 := constructAtomicMapStringToString(NoLimit)
	cs9 := constructString(NoLimit)
	cs10 := constructString(NoLimit)
	cs11 := constructPointerBool(NoLimit)
	cs12 := constructString(NoLimit)
	cs13 := constructBool(NoLimit)
	cs14 := constructBool(NoLimit)
	cs15 := constructBool(NoLimit)
	cs16 := constructPointerBool(NoLimit)
	cs17 := constructPointerPodSecurityContext(NoLimit)
	cs18 := constructMapSliceLocalObjectReference(NoLimit)
	cs19 := constructString(NoLimit)
	cs20 := constructString(NoLimit)
	cs21 := constructPointerAffinity(NoLimit)
	cs22 := constructString(NoLimit)
	cs23 := constructAtomicSliceToleration(NoLimit)
	cs24 := constructMapSliceHostAlias(NoLimit)
	cs25 := constructString(NoLimit)
	cs26 := constructPointerInt32(NoLimit)
	cs27 := constructPointerPodDNSConfig(NoLimit)
	cs28 := constructAtomicSlicePodReadinessGate(NoLimit)
	cs29 := constructPointerString(NoLimit)
	cs30 := constructPointerBool(NoLimit)
	cs31 := constructPointerPreemptionPolicy(NoLimit)
	cs32 := constructResourceList(NoLimit)
	cs33 := constructMapSliceTopologySpreadConstraint(NoLimit)
	cs34 := constructPointerBool(NoLimit)
	cs35 := constructPointerPodOS(NoLimit)
	cs36 := constructPointerBool(NoLimit)
	cs37 := constructMapSlicePodSchedulingGate(NoLimit)
	cs38 := constructMapSlicePodResourceClaim(NoLimit)
	cs39 := constructPointerResourceRequirements(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
		len(cs4),
		len(cs5),
		len(cs6),
		len(cs7),
		len(cs8),
		len(cs9),
		len(cs10),
		len(cs11),
		len(cs12),
		len(cs13),
		len(cs14),
		len(cs15),
		len(cs16),
		len(cs17),
		len(cs18),
		len(cs19),
		len(cs20),
		len(cs21),
		len(cs22),
		len(cs23),
		len(cs24),
		len(cs25),
		len(cs26),
		len(cs27),
		len(cs28),
		len(cs29),
		len(cs30),
		len(cs31),
		len(cs32),
		len(cs33),
		len(cs34),
		len(cs35),
		len(cs36),
		len(cs37),
		len(cs38),
		len(cs39),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	k4 := 0
	k5 := 0
	k6 := 0
	k7 := 0
	k8 := 0
	k9 := 0
	k10 := 0
	k11 := 0
	k12 := 0
	k13 := 0
	k14 := 0
	k15 := 0
	k16 := 0
	k17 := 0
	k18 := 0
	k19 := 0
	k20 := 0
	k21 := 0
	k22 := 0
	k23 := 0
	k24 := 0
	k25 := 0
	k26 := 0
	k27 := 0
	k28 := 0
	k29 := 0
	k30 := 0
	k31 := 0
	k32 := 0
	k33 := 0
	k34 := 0
	k35 := 0
	k36 := 0
	k37 := 0
	k38 := 0
	k39 := 0
	for i := range maxCount {
		nc := Case[v1.PodSpec]{}
		if i/len(cs0) > k0 {
			cs0 = constructMapSliceVolume(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Volumes = c0.expected
		nc.dst.Volumes = c0.dst
		nc.src.Volumes = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructMapSliceContainer(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.InitContainers = c1.expected
		nc.dst.InitContainers = c1.dst
		nc.src.InitContainers = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructMapSliceContainer(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.Containers = c2.expected
		nc.dst.Containers = c2.dst
		nc.src.Containers = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructMapSliceEphemeralContainer(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.EphemeralContainers = c3.expected
		nc.dst.EphemeralContainers = c3.dst
		nc.src.EphemeralContainers = c3.src
		if i/len(cs4) > k4 {
			cs4 = constructRestartPolicy(NoLimit)
			k4 += 1
		}
		c4 := &cs4[i%len(cs4)]
		nc.expected.RestartPolicy = c4.expected
		nc.dst.RestartPolicy = c4.dst
		nc.src.RestartPolicy = c4.src
		if i/len(cs5) > k5 {
			cs5 = constructPointerInt64(NoLimit)
			k5 += 1
		}
		c5 := &cs5[i%len(cs5)]
		nc.expected.TerminationGracePeriodSeconds = c5.expected
		nc.dst.TerminationGracePeriodSeconds = c5.dst
		nc.src.TerminationGracePeriodSeconds = c5.src
		if i/len(cs6) > k6 {
			cs6 = constructPointerInt64(NoLimit)
			k6 += 1
		}
		c6 := &cs6[i%len(cs6)]
		nc.expected.ActiveDeadlineSeconds = c6.expected
		nc.dst.ActiveDeadlineSeconds = c6.dst
		nc.src.ActiveDeadlineSeconds = c6.src
		if i/len(cs7) > k7 {
			cs7 = constructDNSPolicy(NoLimit)
			k7 += 1
		}
		c7 := &cs7[i%len(cs7)]
		nc.expected.DNSPolicy = c7.expected
		nc.dst.DNSPolicy = c7.dst
		nc.src.DNSPolicy = c7.src
		if i/len(cs8) > k8 {
			cs8 = constructAtomicMapStringToString(NoLimit)
			k8 += 1
		}
		c8 := &cs8[i%len(cs8)]
		nc.expected.NodeSelector = c8.expected
		nc.dst.NodeSelector = c8.dst
		nc.src.NodeSelector = c8.src
		if i/len(cs9) > k9 {
			cs9 = constructString(NoLimit)
			k9 += 1
		}
		c9 := &cs9[i%len(cs9)]
		nc.expected.ServiceAccountName = c9.expected
		nc.dst.ServiceAccountName = c9.dst
		nc.src.ServiceAccountName = c9.src
		if i/len(cs10) > k10 {
			cs10 = constructString(NoLimit)
			k10 += 1
		}
		c10 := &cs10[i%len(cs10)]
		nc.expected.DeprecatedServiceAccount = c10.expected
		nc.dst.DeprecatedServiceAccount = c10.dst
		nc.src.DeprecatedServiceAccount = c10.src
		if i/len(cs11) > k11 {
			cs11 = constructPointerBool(NoLimit)
			k11 += 1
		}
		c11 := &cs11[i%len(cs11)]
		nc.expected.AutomountServiceAccountToken = c11.expected
		nc.dst.AutomountServiceAccountToken = c11.dst
		nc.src.AutomountServiceAccountToken = c11.src
		if i/len(cs12) > k12 {
			cs12 = constructString(NoLimit)
			k12 += 1
		}
		c12 := &cs12[i%len(cs12)]
		nc.expected.NodeName = c12.expected
		nc.dst.NodeName = c12.dst
		nc.src.NodeName = c12.src
		if i/len(cs13) > k13 {
			cs13 = constructBool(NoLimit)
			k13 += 1
		}
		c13 := &cs13[i%len(cs13)]
		nc.expected.HostNetwork = c13.expected
		nc.dst.HostNetwork = c13.dst
		nc.src.HostNetwork = c13.src
		if i/len(cs14) > k14 {
			cs14 = constructBool(NoLimit)
			k14 += 1
		}
		c14 := &cs14[i%len(cs14)]
		nc.expected.HostPID = c14.expected
		nc.dst.HostPID = c14.dst
		nc.src.HostPID = c14.src
		if i/len(cs15) > k15 {
			cs15 = constructBool(NoLimit)
			k15 += 1
		}
		c15 := &cs15[i%len(cs15)]
		nc.expected.HostIPC = c15.expected
		nc.dst.HostIPC = c15.dst
		nc.src.HostIPC = c15.src
		if i/len(cs16) > k16 {
			cs16 = constructPointerBool(NoLimit)
			k16 += 1
		}
		c16 := &cs16[i%len(cs16)]
		nc.expected.ShareProcessNamespace = c16.expected
		nc.dst.ShareProcessNamespace = c16.dst
		nc.src.ShareProcessNamespace = c16.src
		if i/len(cs17) > k17 {
			cs17 = constructPointerPodSecurityContext(NoLimit)
			k17 += 1
		}
		c17 := &cs17[i%len(cs17)]
		nc.expected.SecurityContext = c17.expected
		nc.dst.SecurityContext = c17.dst
		nc.src.SecurityContext = c17.src
		if i/len(cs18) > k18 {
			cs18 = constructMapSliceLocalObjectReference(NoLimit)
			k18 += 1
		}
		c18 := &cs18[i%len(cs18)]
		nc.expected.ImagePullSecrets = c18.expected
		nc.dst.ImagePullSecrets = c18.dst
		nc.src.ImagePullSecrets = c18.src
		if i/len(cs19) > k19 {
			cs19 = constructString(NoLimit)
			k19 += 1
		}
		c19 := &cs19[i%len(cs19)]
		nc.expected.Hostname = c19.expected
		nc.dst.Hostname = c19.dst
		nc.src.Hostname = c19.src
		if i/len(cs20) > k20 {
			cs20 = constructString(NoLimit)
			k20 += 1
		}
		c20 := &cs20[i%len(cs20)]
		nc.expected.Subdomain = c20.expected
		nc.dst.Subdomain = c20.dst
		nc.src.Subdomain = c20.src
		if i/len(cs21) > k21 {
			cs21 = constructPointerAffinity(NoLimit)
			k21 += 1
		}
		c21 := &cs21[i%len(cs21)]
		nc.expected.Affinity = c21.expected
		nc.dst.Affinity = c21.dst
		nc.src.Affinity = c21.src
		if i/len(cs22) > k22 {
			cs22 = constructString(NoLimit)
			k22 += 1
		}
		c22 := &cs22[i%len(cs22)]
		nc.expected.SchedulerName = c22.expected
		nc.dst.SchedulerName = c22.dst
		nc.src.SchedulerName = c22.src
		if i/len(cs23) > k23 {
			cs23 = constructAtomicSliceToleration(NoLimit)
			k23 += 1
		}
		c23 := &cs23[i%len(cs23)]
		nc.expected.Tolerations = c23.expected
		nc.dst.Tolerations = c23.dst
		nc.src.Tolerations = c23.src
		if i/len(cs24) > k24 {
			cs24 = constructMapSliceHostAlias(NoLimit)
			k24 += 1
		}
		c24 := &cs24[i%len(cs24)]
		nc.expected.HostAliases = c24.expected
		nc.dst.HostAliases = c24.dst
		nc.src.HostAliases = c24.src
		if i/len(cs25) > k25 {
			cs25 = constructString(NoLimit)
			k25 += 1
		}
		c25 := &cs25[i%len(cs25)]
		nc.expected.PriorityClassName = c25.expected
		nc.dst.PriorityClassName = c25.dst
		nc.src.PriorityClassName = c25.src
		if i/len(cs26) > k26 {
			cs26 = constructPointerInt32(NoLimit)
			k26 += 1
		}
		c26 := &cs26[i%len(cs26)]
		nc.expected.Priority = c26.expected
		nc.dst.Priority = c26.dst
		nc.src.Priority = c26.src
		if i/len(cs27) > k27 {
			cs27 = constructPointerPodDNSConfig(NoLimit)
			k27 += 1
		}
		c27 := &cs27[i%len(cs27)]
		nc.expected.DNSConfig = c27.expected
		nc.dst.DNSConfig = c27.dst
		nc.src.DNSConfig = c27.src
		if i/len(cs28) > k28 {
			cs28 = constructAtomicSlicePodReadinessGate(NoLimit)
			k28 += 1
		}
		c28 := &cs28[i%len(cs28)]
		nc.expected.ReadinessGates = c28.expected
		nc.dst.ReadinessGates = c28.dst
		nc.src.ReadinessGates = c28.src
		if i/len(cs29) > k29 {
			cs29 = constructPointerString(NoLimit)
			k29 += 1
		}
		c29 := &cs29[i%len(cs29)]
		nc.expected.RuntimeClassName = c29.expected
		nc.dst.RuntimeClassName = c29.dst
		nc.src.RuntimeClassName = c29.src
		if i/len(cs30) > k30 {
			cs30 = constructPointerBool(NoLimit)
			k30 += 1
		}
		c30 := &cs30[i%len(cs30)]
		nc.expected.EnableServiceLinks = c30.expected
		nc.dst.EnableServiceLinks = c30.dst
		nc.src.EnableServiceLinks = c30.src
		if i/len(cs31) > k31 {
			cs31 = constructPointerPreemptionPolicy(NoLimit)
			k31 += 1
		}
		c31 := &cs31[i%len(cs31)]
		nc.expected.PreemptionPolicy = c31.expected
		nc.dst.PreemptionPolicy = c31.dst
		nc.src.PreemptionPolicy = c31.src
		if i/len(cs32) > k32 {
			cs32 = constructResourceList(NoLimit)
			k32 += 1
		}
		c32 := &cs32[i%len(cs32)]
		nc.expected.Overhead = c32.expected
		nc.dst.Overhead = c32.dst
		nc.src.Overhead = c32.src
		if i/len(cs33) > k33 {
			cs33 = constructMapSliceTopologySpreadConstraint(NoLimit)
			k33 += 1
		}
		c33 := &cs33[i%len(cs33)]
		nc.expected.TopologySpreadConstraints = c33.expected
		nc.dst.TopologySpreadConstraints = c33.dst
		nc.src.TopologySpreadConstraints = c33.src
		if i/len(cs34) > k34 {
			cs34 = constructPointerBool(NoLimit)
			k34 += 1
		}
		c34 := &cs34[i%len(cs34)]
		nc.expected.SetHostnameAsFQDN = c34.expected
		nc.dst.SetHostnameAsFQDN = c34.dst
		nc.src.SetHostnameAsFQDN = c34.src
		if i/len(cs35) > k35 {
			cs35 = constructPointerPodOS(NoLimit)
			k35 += 1
		}
		c35 := &cs35[i%len(cs35)]
		nc.expected.OS = c35.expected
		nc.dst.OS = c35.dst
		nc.src.OS = c35.src
		if i/len(cs36) > k36 {
			cs36 = constructPointerBool(NoLimit)
			k36 += 1
		}
		c36 := &cs36[i%len(cs36)]
		nc.expected.HostUsers = c36.expected
		nc.dst.HostUsers = c36.dst
		nc.src.HostUsers = c36.src
		if i/len(cs37) > k37 {
			cs37 = constructMapSlicePodSchedulingGate(NoLimit)
			k37 += 1
		}
		c37 := &cs37[i%len(cs37)]
		nc.expected.SchedulingGates = c37.expected
		nc.dst.SchedulingGates = c37.dst
		nc.src.SchedulingGates = c37.src
		if i/len(cs38) > k38 {
			cs38 = constructMapSlicePodResourceClaim(NoLimit)
			k38 += 1
		}
		c38 := &cs38[i%len(cs38)]
		nc.expected.ResourceClaims = c38.expected
		nc.dst.ResourceClaims = c38.dst
		nc.src.ResourceClaims = c38.src
		if i/len(cs39) > k39 {
			cs39 = constructPointerResourceRequirements(NoLimit)
			k39 += 1
		}
		c39 := &cs39[i%len(cs39)]
		nc.expected.Resources = c39.expected
		nc.dst.Resources = c39.dst
		nc.src.Resources = c39.src
		cases = append(cases, nc)
	}
	return cases
}
func constructMapSliceVolume(p Policy) []Case[[]v1.Volume] {
	cases := []Case[[]v1.Volume]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructVolumeIgnore_name(NoLimit)
	var nc Case[[]v1.Volume]
	nc = Case[[]v1.Volume]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.expected)
		nc.dst = append(nc.dst, c.dst)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.Volume]{}
	srcs := []v1.Volume{}
	for i, c := range cs {
		switch i % 3 {
		case 0:
			nc.expected = append(nc.expected, c.expected)
			nc.dst = append(nc.dst, c.dst)
			nc.src = append(nc.src, c.src)
		case 1:
			nc.expected = append(nc.expected, c.dst)
			nc.dst = append(nc.dst, c.dst)
		case 2:
			srcs = append(srcs, c.src)
			nc.src = append(nc.src, c.src)
		}
	}
	nc.expected = append(nc.expected, srcs...)
	cases = append(cases, nc)
	nc = Case[[]v1.Volume]{}
	srcs = []v1.Volume{}
	for i, c := range cs {
		switch i % 2 {
		case 0:
			nc.expected = append(nc.expected, c.dst)
			nc.dst = append(nc.dst, c.dst)
		case 1:
			srcs = append(srcs, c.src)
			nc.src = append(nc.src, c.src)
		}
	}
	nc.expected = append(nc.expected, srcs...)
	cases = append(cases, nc)
	nc = Case[[]v1.Volume]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.src)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.Volume]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.dst)
		nc.dst = append(nc.dst, c.dst)
	}
	cases = append(cases, nc)
	return cases
}
func constructVolumeIgnore_name(p Policy) []Case[v1.Volume] {
	cases := []Case[v1.Volume]{}
	cs0 := constructString(NoNotEqual | NoZero | NoNil)
	cs1 := constructVolumeSource(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[v1.Volume]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoNotEqual | NoZero | NoNil)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Name = c0.expected
		nc.dst.Name = c0.dst
		nc.src.Name = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructVolumeSource(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.VolumeSource = c1.expected
		nc.dst.VolumeSource = c1.dst
		nc.src.VolumeSource = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructString(p Policy) []Case[string] {
	cases := []Case[string]{}
	if p&(NoZero) == 0 {
		cases = append(cases, Case[string]{expected: "", dst: "", src: ""})
	}
	if p&(NoNotEqual) == 0 {
		dst, src := randString(), randString()
		cases = append(cases, Case[string]{expected: src, dst: dst, src: src})
	}
	if p&(NoZero|NoNotEqual) == 0 {
		dst, src := randString(), randString()
		cases = append(cases, Case[string]{expected: dst, dst: dst, src: ""})
		cases = append(cases, Case[string]{expected: src, dst: "", src: src})
	}
	var val string
	val = randString()
	cases = append(cases, Case[string]{expected: val, dst: val, src: val})
	val = randString()
	cases = append(cases, Case[string]{expected: val, dst: val, src: val})
	val = randString()
	cases = append(cases, Case[string]{expected: val, dst: val, src: val})
	return cases
}
func constructVolumeSource(p Policy) []Case[v1.VolumeSource] {
	cases := []Case[v1.VolumeSource]{}
	cs0 := constructPointerHostPathVolumeSource(NoLimit)
	cs1 := constructPointerEmptyDirVolumeSource(NoLimit)
	cs2 := constructPointerGCEPersistentDiskVolumeSource(NoLimit)
	cs3 := constructPointerAWSElasticBlockStoreVolumeSource(NoLimit)
	cs4 := constructPointerGitRepoVolumeSource(NoLimit)
	cs5 := constructPointerSecretVolumeSource(NoLimit)
	cs6 := constructPointerNFSVolumeSource(NoLimit)
	cs7 := constructPointerISCSIVolumeSource(NoLimit)
	cs8 := constructPointerGlusterfsVolumeSource(NoLimit)
	cs9 := constructPointerPersistentVolumeClaimVolumeSource(NoLimit)
	cs10 := constructPointerRBDVolumeSource(NoLimit)
	cs11 := constructPointerFlexVolumeSource(NoLimit)
	cs12 := constructPointerCinderVolumeSource(NoLimit)
	cs13 := constructPointerCephFSVolumeSource(NoLimit)
	cs14 := constructPointerFlockerVolumeSource(NoLimit)
	cs15 := constructPointerDownwardAPIVolumeSource(NoLimit)
	cs16 := constructPointerFCVolumeSource(NoLimit)
	cs17 := constructPointerAzureFileVolumeSource(NoLimit)
	cs18 := constructPointerConfigMapVolumeSource(NoLimit)
	cs19 := constructPointerVsphereVirtualDiskVolumeSource(NoLimit)
	cs20 := constructPointerQuobyteVolumeSource(NoLimit)
	cs21 := constructPointerAzureDiskVolumeSource(NoLimit)
	cs22 := constructPointerPhotonPersistentDiskVolumeSource(NoLimit)
	cs23 := constructPointerProjectedVolumeSource(NoLimit)
	cs24 := constructPointerPortworxVolumeSource(NoLimit)
	cs25 := constructPointerScaleIOVolumeSource(NoLimit)
	cs26 := constructPointerStorageOSVolumeSource(NoLimit)
	cs27 := constructPointerCSIVolumeSource(NoLimit)
	cs28 := constructPointerEphemeralVolumeSource(NoLimit)
	cs29 := constructPointerImageVolumeSource(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
		len(cs4),
		len(cs5),
		len(cs6),
		len(cs7),
		len(cs8),
		len(cs9),
		len(cs10),
		len(cs11),
		len(cs12),
		len(cs13),
		len(cs14),
		len(cs15),
		len(cs16),
		len(cs17),
		len(cs18),
		len(cs19),
		len(cs20),
		len(cs21),
		len(cs22),
		len(cs23),
		len(cs24),
		len(cs25),
		len(cs26),
		len(cs27),
		len(cs28),
		len(cs29),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	k4 := 0
	k5 := 0
	k6 := 0
	k7 := 0
	k8 := 0
	k9 := 0
	k10 := 0
	k11 := 0
	k12 := 0
	k13 := 0
	k14 := 0
	k15 := 0
	k16 := 0
	k17 := 0
	k18 := 0
	k19 := 0
	k20 := 0
	k21 := 0
	k22 := 0
	k23 := 0
	k24 := 0
	k25 := 0
	k26 := 0
	k27 := 0
	k28 := 0
	k29 := 0
	for i := range maxCount {
		nc := Case[v1.VolumeSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructPointerHostPathVolumeSource(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.HostPath = c0.expected
		nc.dst.HostPath = c0.dst
		nc.src.HostPath = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructPointerEmptyDirVolumeSource(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.EmptyDir = c1.expected
		nc.dst.EmptyDir = c1.dst
		nc.src.EmptyDir = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructPointerGCEPersistentDiskVolumeSource(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.GCEPersistentDisk = c2.expected
		nc.dst.GCEPersistentDisk = c2.dst
		nc.src.GCEPersistentDisk = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructPointerAWSElasticBlockStoreVolumeSource(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.AWSElasticBlockStore = c3.expected
		nc.dst.AWSElasticBlockStore = c3.dst
		nc.src.AWSElasticBlockStore = c3.src
		if i/len(cs4) > k4 {
			cs4 = constructPointerGitRepoVolumeSource(NoLimit)
			k4 += 1
		}
		c4 := &cs4[i%len(cs4)]
		nc.expected.GitRepo = c4.expected
		nc.dst.GitRepo = c4.dst
		nc.src.GitRepo = c4.src
		if i/len(cs5) > k5 {
			cs5 = constructPointerSecretVolumeSource(NoLimit)
			k5 += 1
		}
		c5 := &cs5[i%len(cs5)]
		nc.expected.Secret = c5.expected
		nc.dst.Secret = c5.dst
		nc.src.Secret = c5.src
		if i/len(cs6) > k6 {
			cs6 = constructPointerNFSVolumeSource(NoLimit)
			k6 += 1
		}
		c6 := &cs6[i%len(cs6)]
		nc.expected.NFS = c6.expected
		nc.dst.NFS = c6.dst
		nc.src.NFS = c6.src
		if i/len(cs7) > k7 {
			cs7 = constructPointerISCSIVolumeSource(NoLimit)
			k7 += 1
		}
		c7 := &cs7[i%len(cs7)]
		nc.expected.ISCSI = c7.expected
		nc.dst.ISCSI = c7.dst
		nc.src.ISCSI = c7.src
		if i/len(cs8) > k8 {
			cs8 = constructPointerGlusterfsVolumeSource(NoLimit)
			k8 += 1
		}
		c8 := &cs8[i%len(cs8)]
		nc.expected.Glusterfs = c8.expected
		nc.dst.Glusterfs = c8.dst
		nc.src.Glusterfs = c8.src
		if i/len(cs9) > k9 {
			cs9 = constructPointerPersistentVolumeClaimVolumeSource(NoLimit)
			k9 += 1
		}
		c9 := &cs9[i%len(cs9)]
		nc.expected.PersistentVolumeClaim = c9.expected
		nc.dst.PersistentVolumeClaim = c9.dst
		nc.src.PersistentVolumeClaim = c9.src
		if i/len(cs10) > k10 {
			cs10 = constructPointerRBDVolumeSource(NoLimit)
			k10 += 1
		}
		c10 := &cs10[i%len(cs10)]
		nc.expected.RBD = c10.expected
		nc.dst.RBD = c10.dst
		nc.src.RBD = c10.src
		if i/len(cs11) > k11 {
			cs11 = constructPointerFlexVolumeSource(NoLimit)
			k11 += 1
		}
		c11 := &cs11[i%len(cs11)]
		nc.expected.FlexVolume = c11.expected
		nc.dst.FlexVolume = c11.dst
		nc.src.FlexVolume = c11.src
		if i/len(cs12) > k12 {
			cs12 = constructPointerCinderVolumeSource(NoLimit)
			k12 += 1
		}
		c12 := &cs12[i%len(cs12)]
		nc.expected.Cinder = c12.expected
		nc.dst.Cinder = c12.dst
		nc.src.Cinder = c12.src
		if i/len(cs13) > k13 {
			cs13 = constructPointerCephFSVolumeSource(NoLimit)
			k13 += 1
		}
		c13 := &cs13[i%len(cs13)]
		nc.expected.CephFS = c13.expected
		nc.dst.CephFS = c13.dst
		nc.src.CephFS = c13.src
		if i/len(cs14) > k14 {
			cs14 = constructPointerFlockerVolumeSource(NoLimit)
			k14 += 1
		}
		c14 := &cs14[i%len(cs14)]
		nc.expected.Flocker = c14.expected
		nc.dst.Flocker = c14.dst
		nc.src.Flocker = c14.src
		if i/len(cs15) > k15 {
			cs15 = constructPointerDownwardAPIVolumeSource(NoLimit)
			k15 += 1
		}
		c15 := &cs15[i%len(cs15)]
		nc.expected.DownwardAPI = c15.expected
		nc.dst.DownwardAPI = c15.dst
		nc.src.DownwardAPI = c15.src
		if i/len(cs16) > k16 {
			cs16 = constructPointerFCVolumeSource(NoLimit)
			k16 += 1
		}
		c16 := &cs16[i%len(cs16)]
		nc.expected.FC = c16.expected
		nc.dst.FC = c16.dst
		nc.src.FC = c16.src
		if i/len(cs17) > k17 {
			cs17 = constructPointerAzureFileVolumeSource(NoLimit)
			k17 += 1
		}
		c17 := &cs17[i%len(cs17)]
		nc.expected.AzureFile = c17.expected
		nc.dst.AzureFile = c17.dst
		nc.src.AzureFile = c17.src
		if i/len(cs18) > k18 {
			cs18 = constructPointerConfigMapVolumeSource(NoLimit)
			k18 += 1
		}
		c18 := &cs18[i%len(cs18)]
		nc.expected.ConfigMap = c18.expected
		nc.dst.ConfigMap = c18.dst
		nc.src.ConfigMap = c18.src
		if i/len(cs19) > k19 {
			cs19 = constructPointerVsphereVirtualDiskVolumeSource(NoLimit)
			k19 += 1
		}
		c19 := &cs19[i%len(cs19)]
		nc.expected.VsphereVolume = c19.expected
		nc.dst.VsphereVolume = c19.dst
		nc.src.VsphereVolume = c19.src
		if i/len(cs20) > k20 {
			cs20 = constructPointerQuobyteVolumeSource(NoLimit)
			k20 += 1
		}
		c20 := &cs20[i%len(cs20)]
		nc.expected.Quobyte = c20.expected
		nc.dst.Quobyte = c20.dst
		nc.src.Quobyte = c20.src
		if i/len(cs21) > k21 {
			cs21 = constructPointerAzureDiskVolumeSource(NoLimit)
			k21 += 1
		}
		c21 := &cs21[i%len(cs21)]
		nc.expected.AzureDisk = c21.expected
		nc.dst.AzureDisk = c21.dst
		nc.src.AzureDisk = c21.src
		if i/len(cs22) > k22 {
			cs22 = constructPointerPhotonPersistentDiskVolumeSource(NoLimit)
			k22 += 1
		}
		c22 := &cs22[i%len(cs22)]
		nc.expected.PhotonPersistentDisk = c22.expected
		nc.dst.PhotonPersistentDisk = c22.dst
		nc.src.PhotonPersistentDisk = c22.src
		if i/len(cs23) > k23 {
			cs23 = constructPointerProjectedVolumeSource(NoLimit)
			k23 += 1
		}
		c23 := &cs23[i%len(cs23)]
		nc.expected.Projected = c23.expected
		nc.dst.Projected = c23.dst
		nc.src.Projected = c23.src
		if i/len(cs24) > k24 {
			cs24 = constructPointerPortworxVolumeSource(NoLimit)
			k24 += 1
		}
		c24 := &cs24[i%len(cs24)]
		nc.expected.PortworxVolume = c24.expected
		nc.dst.PortworxVolume = c24.dst
		nc.src.PortworxVolume = c24.src
		if i/len(cs25) > k25 {
			cs25 = constructPointerScaleIOVolumeSource(NoLimit)
			k25 += 1
		}
		c25 := &cs25[i%len(cs25)]
		nc.expected.ScaleIO = c25.expected
		nc.dst.ScaleIO = c25.dst
		nc.src.ScaleIO = c25.src
		if i/len(cs26) > k26 {
			cs26 = constructPointerStorageOSVolumeSource(NoLimit)
			k26 += 1
		}
		c26 := &cs26[i%len(cs26)]
		nc.expected.StorageOS = c26.expected
		nc.dst.StorageOS = c26.dst
		nc.src.StorageOS = c26.src
		if i/len(cs27) > k27 {
			cs27 = constructPointerCSIVolumeSource(NoLimit)
			k27 += 1
		}
		c27 := &cs27[i%len(cs27)]
		nc.expected.CSI = c27.expected
		nc.dst.CSI = c27.dst
		nc.src.CSI = c27.src
		if i/len(cs28) > k28 {
			cs28 = constructPointerEphemeralVolumeSource(NoLimit)
			k28 += 1
		}
		c28 := &cs28[i%len(cs28)]
		nc.expected.Ephemeral = c28.expected
		nc.dst.Ephemeral = c28.dst
		nc.src.Ephemeral = c28.src
		if i/len(cs29) > k29 {
			cs29 = constructPointerImageVolumeSource(NoLimit)
			k29 += 1
		}
		c29 := &cs29[i%len(cs29)]
		nc.expected.Image = c29.expected
		nc.dst.Image = c29.dst
		nc.src.Image = c29.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerHostPathVolumeSource(p Policy) []Case[*v1.HostPathVolumeSource] {
	cases := []Case[*v1.HostPathVolumeSource]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructHostPathVolumeSource(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.HostPathVolumeSource]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructHostPathVolumeSource(p Policy) []Case[v1.HostPathVolumeSource] {
	cases := []Case[v1.HostPathVolumeSource]{}
	cs0 := constructString(NoLimit)
	cs1 := constructPointerHostPathType(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[v1.HostPathVolumeSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Path = c0.expected
		nc.dst.Path = c0.dst
		nc.src.Path = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructPointerHostPathType(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Type = c1.expected
		nc.dst.Type = c1.dst
		nc.src.Type = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerHostPathType(p Policy) []Case[*v1.HostPathType] {
	cases := []Case[*v1.HostPathType]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructHostPathType(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.HostPathType]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructHostPathType(p Policy) []Case[v1.HostPathType] {
	cases := []Case[v1.HostPathType]{}
	cs := constructString(p)
	for _, c := range cs {
		cases = append(cases, Case[v1.HostPathType]{
			expected: v1.HostPathType(c.expected),
			dst:      v1.HostPathType(c.dst),
			src:      v1.HostPathType(c.src),
		})
	}
	return cases
}
func constructPointerEmptyDirVolumeSource(p Policy) []Case[*v1.EmptyDirVolumeSource] {
	cases := []Case[*v1.EmptyDirVolumeSource]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructEmptyDirVolumeSource(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.EmptyDirVolumeSource]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructEmptyDirVolumeSource(p Policy) []Case[v1.EmptyDirVolumeSource] {
	cases := []Case[v1.EmptyDirVolumeSource]{}
	cs0 := constructStorageMedium(NoLimit)
	cs1 := constructPointerQuantity(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[v1.EmptyDirVolumeSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructStorageMedium(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Medium = c0.expected
		nc.dst.Medium = c0.dst
		nc.src.Medium = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructPointerQuantity(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.SizeLimit = c1.expected
		nc.dst.SizeLimit = c1.dst
		nc.src.SizeLimit = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructStorageMedium(p Policy) []Case[v1.StorageMedium] {
	cases := []Case[v1.StorageMedium]{}
	cs := constructString(p)
	for _, c := range cs {
		cases = append(cases, Case[v1.StorageMedium]{
			expected: v1.StorageMedium(c.expected),
			dst:      v1.StorageMedium(c.dst),
			src:      v1.StorageMedium(c.src),
		})
	}
	return cases
}
func constructPointerQuantity(p Policy) []Case[*resource.Quantity] {
	cases := []Case[*resource.Quantity]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructQuantity(p)
	for _, c := range cs {
		cases = append(cases, Case[*resource.Quantity]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructPointerGCEPersistentDiskVolumeSource(p Policy) []Case[*v1.GCEPersistentDiskVolumeSource] {
	cases := []Case[*v1.GCEPersistentDiskVolumeSource]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructGCEPersistentDiskVolumeSource(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.GCEPersistentDiskVolumeSource]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructGCEPersistentDiskVolumeSource(p Policy) []Case[v1.GCEPersistentDiskVolumeSource] {
	cases := []Case[v1.GCEPersistentDiskVolumeSource]{}
	cs0 := constructString(NoLimit)
	cs1 := constructString(NoLimit)
	cs2 := constructInt32(NoLimit)
	cs3 := constructBool(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	for i := range maxCount {
		nc := Case[v1.GCEPersistentDiskVolumeSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.PDName = c0.expected
		nc.dst.PDName = c0.dst
		nc.src.PDName = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.FSType = c1.expected
		nc.dst.FSType = c1.dst
		nc.src.FSType = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructInt32(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.Partition = c2.expected
		nc.dst.Partition = c2.dst
		nc.src.Partition = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructBool(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.ReadOnly = c3.expected
		nc.dst.ReadOnly = c3.dst
		nc.src.ReadOnly = c3.src
		cases = append(cases, nc)
	}
	return cases
}
func constructInt32(p Policy) []Case[int32] {
	cases := []Case[int32]{}
	if p&(NoZero) == 0 {
		cases = append(cases, Case[int32]{expected: 0, dst: 0, src: 0})
	}
	if p&(NoNotEqual) == 0 {
		if p&(NoNotEqual) == 0 {
			cases = append(cases, Case[int32]{expected: 1, dst: 2, src: 1})
			cases = append(cases, Case[int32]{expected: -1, dst: 2, src: -1})
			cases = append(cases, Case[int32]{expected: 1, dst: -2, src: 1})
			cases = append(cases, Case[int32]{expected: -1, dst: -2, src: -1})
		}
	}
	if p&(NoZero|NoNotEqual) == 0 {
		cases = append(cases, Case[int32]{expected: 1, dst: 1, src: 0})
		cases = append(cases, Case[int32]{expected: -1, dst: -1, src: 0})
		cases = append(cases, Case[int32]{expected: 1, dst: 0, src: 1})
		cases = append(cases, Case[int32]{expected: -1, dst: 0, src: -1})
	}
	cases = append(cases, Case[int32]{expected: 1, dst: 1, src: 1})
	cases = append(cases, Case[int32]{expected: -1, dst: -1, src: -1})
	return cases
}
func constructBool(p Policy) []Case[bool] {
	cases := []Case[bool]{}
	if p&(NoZero) == 0 {
		cases = append(cases, Case[bool]{expected: false, dst: false, src: false})
	}
	if p&(NoNotEqual) == 0 {
	}
	if p&(NoZero|NoNotEqual) == 0 {
	}
	cases = append(cases, Case[bool]{expected: false, dst: false, src: false})
	cases = append(cases, Case[bool]{expected: true, dst: true, src: true})
	return cases
}
func constructPointerAWSElasticBlockStoreVolumeSource(p Policy) []Case[*v1.AWSElasticBlockStoreVolumeSource] {
	cases := []Case[*v1.AWSElasticBlockStoreVolumeSource]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructAWSElasticBlockStoreVolumeSource(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.AWSElasticBlockStoreVolumeSource]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructAWSElasticBlockStoreVolumeSource(p Policy) []Case[v1.AWSElasticBlockStoreVolumeSource] {
	cases := []Case[v1.AWSElasticBlockStoreVolumeSource]{}
	cs0 := constructString(NoLimit)
	cs1 := constructString(NoLimit)
	cs2 := constructInt32(NoLimit)
	cs3 := constructBool(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	for i := range maxCount {
		nc := Case[v1.AWSElasticBlockStoreVolumeSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.VolumeID = c0.expected
		nc.dst.VolumeID = c0.dst
		nc.src.VolumeID = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.FSType = c1.expected
		nc.dst.FSType = c1.dst
		nc.src.FSType = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructInt32(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.Partition = c2.expected
		nc.dst.Partition = c2.dst
		nc.src.Partition = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructBool(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.ReadOnly = c3.expected
		nc.dst.ReadOnly = c3.dst
		nc.src.ReadOnly = c3.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerGitRepoVolumeSource(p Policy) []Case[*v1.GitRepoVolumeSource] {
	cases := []Case[*v1.GitRepoVolumeSource]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructGitRepoVolumeSource(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.GitRepoVolumeSource]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructGitRepoVolumeSource(p Policy) []Case[v1.GitRepoVolumeSource] {
	cases := []Case[v1.GitRepoVolumeSource]{}
	cs0 := constructString(NoLimit)
	cs1 := constructString(NoLimit)
	cs2 := constructString(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	for i := range maxCount {
		nc := Case[v1.GitRepoVolumeSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Repository = c0.expected
		nc.dst.Repository = c0.dst
		nc.src.Repository = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Revision = c1.expected
		nc.dst.Revision = c1.dst
		nc.src.Revision = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructString(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.Directory = c2.expected
		nc.dst.Directory = c2.dst
		nc.src.Directory = c2.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerSecretVolumeSource(p Policy) []Case[*v1.SecretVolumeSource] {
	cases := []Case[*v1.SecretVolumeSource]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructSecretVolumeSource(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.SecretVolumeSource]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructSecretVolumeSource(p Policy) []Case[v1.SecretVolumeSource] {
	cases := []Case[v1.SecretVolumeSource]{}
	cs0 := constructString(NoLimit)
	cs1 := constructAtomicSliceKeyToPath(NoLimit)
	cs2 := constructPointerInt32(NoLimit)
	cs3 := constructPointerBool(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	for i := range maxCount {
		nc := Case[v1.SecretVolumeSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.SecretName = c0.expected
		nc.dst.SecretName = c0.dst
		nc.src.SecretName = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructAtomicSliceKeyToPath(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Items = c1.expected
		nc.dst.Items = c1.dst
		nc.src.Items = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructPointerInt32(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.DefaultMode = c2.expected
		nc.dst.DefaultMode = c2.dst
		nc.src.DefaultMode = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructPointerBool(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.Optional = c3.expected
		nc.dst.Optional = c3.dst
		nc.src.Optional = c3.src
		cases = append(cases, nc)
	}
	return cases
}
func constructAtomicSliceKeyToPath(p Policy) []Case[[]v1.KeyToPath] {
	cases := []Case[[]v1.KeyToPath]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructKeyToPath(NoLimit)
	var nc Case[[]v1.KeyToPath]
	nc = Case[[]v1.KeyToPath]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.src)
		nc.dst = append(nc.dst, c.dst)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.KeyToPath]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.dst)
		nc.dst = append(nc.dst, c.dst)
	}
	nc.src = []v1.KeyToPath{}
	cases = append(cases, nc)
	return cases
}
func constructKeyToPath(p Policy) []Case[v1.KeyToPath] {
	cases := []Case[v1.KeyToPath]{}
	cs0 := constructString(NoLimit)
	cs1 := constructString(NoLimit)
	cs2 := constructPointerInt32(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	for i := range maxCount {
		nc := Case[v1.KeyToPath]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Key = c0.expected
		nc.dst.Key = c0.dst
		nc.src.Key = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Path = c1.expected
		nc.dst.Path = c1.dst
		nc.src.Path = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructPointerInt32(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.Mode = c2.expected
		nc.dst.Mode = c2.dst
		nc.src.Mode = c2.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerInt32(p Policy) []Case[*int32] {
	cases := []Case[*int32]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructInt32(p)
	for _, c := range cs {
		cases = append(cases, Case[*int32]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructPointerBool(p Policy) []Case[*bool] {
	cases := []Case[*bool]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructBool(p)
	for _, c := range cs {
		cases = append(cases, Case[*bool]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructPointerNFSVolumeSource(p Policy) []Case[*v1.NFSVolumeSource] {
	cases := []Case[*v1.NFSVolumeSource]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructNFSVolumeSource(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.NFSVolumeSource]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructNFSVolumeSource(p Policy) []Case[v1.NFSVolumeSource] {
	cases := []Case[v1.NFSVolumeSource]{}
	cs0 := constructString(NoLimit)
	cs1 := constructString(NoLimit)
	cs2 := constructBool(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	for i := range maxCount {
		nc := Case[v1.NFSVolumeSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Server = c0.expected
		nc.dst.Server = c0.dst
		nc.src.Server = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Path = c1.expected
		nc.dst.Path = c1.dst
		nc.src.Path = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructBool(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.ReadOnly = c2.expected
		nc.dst.ReadOnly = c2.dst
		nc.src.ReadOnly = c2.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerISCSIVolumeSource(p Policy) []Case[*v1.ISCSIVolumeSource] {
	cases := []Case[*v1.ISCSIVolumeSource]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructISCSIVolumeSource(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.ISCSIVolumeSource]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructISCSIVolumeSource(p Policy) []Case[v1.ISCSIVolumeSource] {
	cases := []Case[v1.ISCSIVolumeSource]{}
	cs0 := constructString(NoLimit)
	cs1 := constructString(NoLimit)
	cs2 := constructInt32(NoLimit)
	cs3 := constructString(NoLimit)
	cs4 := constructString(NoLimit)
	cs5 := constructBool(NoLimit)
	cs6 := constructAtomicSliceString(NoLimit)
	cs7 := constructBool(NoLimit)
	cs8 := constructBool(NoLimit)
	cs9 := constructAtomicPointerLocalObjectReference(NoLimit)
	cs10 := constructPointerString(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
		len(cs4),
		len(cs5),
		len(cs6),
		len(cs7),
		len(cs8),
		len(cs9),
		len(cs10),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	k4 := 0
	k5 := 0
	k6 := 0
	k7 := 0
	k8 := 0
	k9 := 0
	k10 := 0
	for i := range maxCount {
		nc := Case[v1.ISCSIVolumeSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.TargetPortal = c0.expected
		nc.dst.TargetPortal = c0.dst
		nc.src.TargetPortal = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.IQN = c1.expected
		nc.dst.IQN = c1.dst
		nc.src.IQN = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructInt32(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.Lun = c2.expected
		nc.dst.Lun = c2.dst
		nc.src.Lun = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructString(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.ISCSIInterface = c3.expected
		nc.dst.ISCSIInterface = c3.dst
		nc.src.ISCSIInterface = c3.src
		if i/len(cs4) > k4 {
			cs4 = constructString(NoLimit)
			k4 += 1
		}
		c4 := &cs4[i%len(cs4)]
		nc.expected.FSType = c4.expected
		nc.dst.FSType = c4.dst
		nc.src.FSType = c4.src
		if i/len(cs5) > k5 {
			cs5 = constructBool(NoLimit)
			k5 += 1
		}
		c5 := &cs5[i%len(cs5)]
		nc.expected.ReadOnly = c5.expected
		nc.dst.ReadOnly = c5.dst
		nc.src.ReadOnly = c5.src
		if i/len(cs6) > k6 {
			cs6 = constructAtomicSliceString(NoLimit)
			k6 += 1
		}
		c6 := &cs6[i%len(cs6)]
		nc.expected.Portals = c6.expected
		nc.dst.Portals = c6.dst
		nc.src.Portals = c6.src
		if i/len(cs7) > k7 {
			cs7 = constructBool(NoLimit)
			k7 += 1
		}
		c7 := &cs7[i%len(cs7)]
		nc.expected.DiscoveryCHAPAuth = c7.expected
		nc.dst.DiscoveryCHAPAuth = c7.dst
		nc.src.DiscoveryCHAPAuth = c7.src
		if i/len(cs8) > k8 {
			cs8 = constructBool(NoLimit)
			k8 += 1
		}
		c8 := &cs8[i%len(cs8)]
		nc.expected.SessionCHAPAuth = c8.expected
		nc.dst.SessionCHAPAuth = c8.dst
		nc.src.SessionCHAPAuth = c8.src
		if i/len(cs9) > k9 {
			cs9 = constructAtomicPointerLocalObjectReference(NoLimit)
			k9 += 1
		}
		c9 := &cs9[i%len(cs9)]
		nc.expected.SecretRef = c9.expected
		nc.dst.SecretRef = c9.dst
		nc.src.SecretRef = c9.src
		if i/len(cs10) > k10 {
			cs10 = constructPointerString(NoLimit)
			k10 += 1
		}
		c10 := &cs10[i%len(cs10)]
		nc.expected.InitiatorName = c10.expected
		nc.dst.InitiatorName = c10.dst
		nc.src.InitiatorName = c10.src
		cases = append(cases, nc)
	}
	return cases
}
func constructAtomicSliceString(p Policy) []Case[[]string] {
	cases := []Case[[]string]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructString(NoLimit)
	var nc Case[[]string]
	nc = Case[[]string]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.src)
		nc.dst = append(nc.dst, c.dst)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]string]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.dst)
		nc.dst = append(nc.dst, c.dst)
	}
	nc.src = []string{}
	cases = append(cases, nc)
	return cases
}
func constructAtomicPointerLocalObjectReference(p Policy) []Case[*v1.LocalObjectReference] {
	cases := []Case[*v1.LocalObjectReference]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructAtomicLocalObjectReference(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.LocalObjectReference]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructAtomicLocalObjectReference(p Policy) []Case[v1.LocalObjectReference] {
	cases := []Case[v1.LocalObjectReference]{}
	cs0 := constructString(NoLimit)
	maxCount := max(
		len(cs0),
	)
	k0 := 0
	for i := range maxCount {
		nc := Case[v1.LocalObjectReference]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Name = c0.src
		nc.dst.Name = c0.dst
		nc.src.Name = c0.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerString(p Policy) []Case[*string] {
	cases := []Case[*string]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructString(p)
	for _, c := range cs {
		cases = append(cases, Case[*string]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructPointerGlusterfsVolumeSource(p Policy) []Case[*v1.GlusterfsVolumeSource] {
	cases := []Case[*v1.GlusterfsVolumeSource]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructGlusterfsVolumeSource(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.GlusterfsVolumeSource]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructGlusterfsVolumeSource(p Policy) []Case[v1.GlusterfsVolumeSource] {
	cases := []Case[v1.GlusterfsVolumeSource]{}
	cs0 := constructString(NoLimit)
	cs1 := constructString(NoLimit)
	cs2 := constructBool(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	for i := range maxCount {
		nc := Case[v1.GlusterfsVolumeSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.EndpointsName = c0.expected
		nc.dst.EndpointsName = c0.dst
		nc.src.EndpointsName = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Path = c1.expected
		nc.dst.Path = c1.dst
		nc.src.Path = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructBool(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.ReadOnly = c2.expected
		nc.dst.ReadOnly = c2.dst
		nc.src.ReadOnly = c2.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerPersistentVolumeClaimVolumeSource(p Policy) []Case[*v1.PersistentVolumeClaimVolumeSource] {
	cases := []Case[*v1.PersistentVolumeClaimVolumeSource]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructPersistentVolumeClaimVolumeSource(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.PersistentVolumeClaimVolumeSource]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructPersistentVolumeClaimVolumeSource(p Policy) []Case[v1.PersistentVolumeClaimVolumeSource] {
	cases := []Case[v1.PersistentVolumeClaimVolumeSource]{}
	cs0 := constructString(NoLimit)
	cs1 := constructBool(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[v1.PersistentVolumeClaimVolumeSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.ClaimName = c0.expected
		nc.dst.ClaimName = c0.dst
		nc.src.ClaimName = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructBool(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.ReadOnly = c1.expected
		nc.dst.ReadOnly = c1.dst
		nc.src.ReadOnly = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerRBDVolumeSource(p Policy) []Case[*v1.RBDVolumeSource] {
	cases := []Case[*v1.RBDVolumeSource]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructRBDVolumeSource(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.RBDVolumeSource]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructRBDVolumeSource(p Policy) []Case[v1.RBDVolumeSource] {
	cases := []Case[v1.RBDVolumeSource]{}
	cs0 := constructAtomicSliceString(NoLimit)
	cs1 := constructString(NoLimit)
	cs2 := constructString(NoLimit)
	cs3 := constructString(NoLimit)
	cs4 := constructString(NoLimit)
	cs5 := constructString(NoLimit)
	cs6 := constructAtomicPointerLocalObjectReference(NoLimit)
	cs7 := constructBool(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
		len(cs4),
		len(cs5),
		len(cs6),
		len(cs7),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	k4 := 0
	k5 := 0
	k6 := 0
	k7 := 0
	for i := range maxCount {
		nc := Case[v1.RBDVolumeSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructAtomicSliceString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.CephMonitors = c0.expected
		nc.dst.CephMonitors = c0.dst
		nc.src.CephMonitors = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.RBDImage = c1.expected
		nc.dst.RBDImage = c1.dst
		nc.src.RBDImage = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructString(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.FSType = c2.expected
		nc.dst.FSType = c2.dst
		nc.src.FSType = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructString(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.RBDPool = c3.expected
		nc.dst.RBDPool = c3.dst
		nc.src.RBDPool = c3.src
		if i/len(cs4) > k4 {
			cs4 = constructString(NoLimit)
			k4 += 1
		}
		c4 := &cs4[i%len(cs4)]
		nc.expected.RadosUser = c4.expected
		nc.dst.RadosUser = c4.dst
		nc.src.RadosUser = c4.src
		if i/len(cs5) > k5 {
			cs5 = constructString(NoLimit)
			k5 += 1
		}
		c5 := &cs5[i%len(cs5)]
		nc.expected.Keyring = c5.expected
		nc.dst.Keyring = c5.dst
		nc.src.Keyring = c5.src
		if i/len(cs6) > k6 {
			cs6 = constructAtomicPointerLocalObjectReference(NoLimit)
			k6 += 1
		}
		c6 := &cs6[i%len(cs6)]
		nc.expected.SecretRef = c6.expected
		nc.dst.SecretRef = c6.dst
		nc.src.SecretRef = c6.src
		if i/len(cs7) > k7 {
			cs7 = constructBool(NoLimit)
			k7 += 1
		}
		c7 := &cs7[i%len(cs7)]
		nc.expected.ReadOnly = c7.expected
		nc.dst.ReadOnly = c7.dst
		nc.src.ReadOnly = c7.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerFlexVolumeSource(p Policy) []Case[*v1.FlexVolumeSource] {
	cases := []Case[*v1.FlexVolumeSource]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructFlexVolumeSource(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.FlexVolumeSource]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructFlexVolumeSource(p Policy) []Case[v1.FlexVolumeSource] {
	cases := []Case[v1.FlexVolumeSource]{}
	cs0 := constructString(NoLimit)
	cs1 := constructString(NoLimit)
	cs2 := constructAtomicPointerLocalObjectReference(NoLimit)
	cs3 := constructBool(NoLimit)
	cs4 := constructMapStringToString(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
		len(cs4),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	k4 := 0
	for i := range maxCount {
		nc := Case[v1.FlexVolumeSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Driver = c0.expected
		nc.dst.Driver = c0.dst
		nc.src.Driver = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.FSType = c1.expected
		nc.dst.FSType = c1.dst
		nc.src.FSType = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructAtomicPointerLocalObjectReference(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.SecretRef = c2.expected
		nc.dst.SecretRef = c2.dst
		nc.src.SecretRef = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructBool(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.ReadOnly = c3.expected
		nc.dst.ReadOnly = c3.dst
		nc.src.ReadOnly = c3.src
		if i/len(cs4) > k4 {
			cs4 = constructMapStringToString(NoLimit)
			k4 += 1
		}
		c4 := &cs4[i%len(cs4)]
		nc.expected.Options = c4.expected
		nc.dst.Options = c4.dst
		nc.src.Options = c4.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerCinderVolumeSource(p Policy) []Case[*v1.CinderVolumeSource] {
	cases := []Case[*v1.CinderVolumeSource]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructCinderVolumeSource(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.CinderVolumeSource]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructCinderVolumeSource(p Policy) []Case[v1.CinderVolumeSource] {
	cases := []Case[v1.CinderVolumeSource]{}
	cs0 := constructString(NoLimit)
	cs1 := constructString(NoLimit)
	cs2 := constructBool(NoLimit)
	cs3 := constructAtomicPointerLocalObjectReference(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	for i := range maxCount {
		nc := Case[v1.CinderVolumeSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.VolumeID = c0.expected
		nc.dst.VolumeID = c0.dst
		nc.src.VolumeID = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.FSType = c1.expected
		nc.dst.FSType = c1.dst
		nc.src.FSType = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructBool(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.ReadOnly = c2.expected
		nc.dst.ReadOnly = c2.dst
		nc.src.ReadOnly = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructAtomicPointerLocalObjectReference(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.SecretRef = c3.expected
		nc.dst.SecretRef = c3.dst
		nc.src.SecretRef = c3.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerCephFSVolumeSource(p Policy) []Case[*v1.CephFSVolumeSource] {
	cases := []Case[*v1.CephFSVolumeSource]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructCephFSVolumeSource(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.CephFSVolumeSource]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructCephFSVolumeSource(p Policy) []Case[v1.CephFSVolumeSource] {
	cases := []Case[v1.CephFSVolumeSource]{}
	cs0 := constructAtomicSliceString(NoLimit)
	cs1 := constructString(NoLimit)
	cs2 := constructString(NoLimit)
	cs3 := constructString(NoLimit)
	cs4 := constructAtomicPointerLocalObjectReference(NoLimit)
	cs5 := constructBool(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
		len(cs4),
		len(cs5),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	k4 := 0
	k5 := 0
	for i := range maxCount {
		nc := Case[v1.CephFSVolumeSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructAtomicSliceString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Monitors = c0.expected
		nc.dst.Monitors = c0.dst
		nc.src.Monitors = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Path = c1.expected
		nc.dst.Path = c1.dst
		nc.src.Path = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructString(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.User = c2.expected
		nc.dst.User = c2.dst
		nc.src.User = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructString(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.SecretFile = c3.expected
		nc.dst.SecretFile = c3.dst
		nc.src.SecretFile = c3.src
		if i/len(cs4) > k4 {
			cs4 = constructAtomicPointerLocalObjectReference(NoLimit)
			k4 += 1
		}
		c4 := &cs4[i%len(cs4)]
		nc.expected.SecretRef = c4.expected
		nc.dst.SecretRef = c4.dst
		nc.src.SecretRef = c4.src
		if i/len(cs5) > k5 {
			cs5 = constructBool(NoLimit)
			k5 += 1
		}
		c5 := &cs5[i%len(cs5)]
		nc.expected.ReadOnly = c5.expected
		nc.dst.ReadOnly = c5.dst
		nc.src.ReadOnly = c5.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerFlockerVolumeSource(p Policy) []Case[*v1.FlockerVolumeSource] {
	cases := []Case[*v1.FlockerVolumeSource]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructFlockerVolumeSource(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.FlockerVolumeSource]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructFlockerVolumeSource(p Policy) []Case[v1.FlockerVolumeSource] {
	cases := []Case[v1.FlockerVolumeSource]{}
	cs0 := constructString(NoLimit)
	cs1 := constructString(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[v1.FlockerVolumeSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.DatasetName = c0.expected
		nc.dst.DatasetName = c0.dst
		nc.src.DatasetName = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.DatasetUUID = c1.expected
		nc.dst.DatasetUUID = c1.dst
		nc.src.DatasetUUID = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerDownwardAPIVolumeSource(p Policy) []Case[*v1.DownwardAPIVolumeSource] {
	cases := []Case[*v1.DownwardAPIVolumeSource]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructDownwardAPIVolumeSource(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.DownwardAPIVolumeSource]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructDownwardAPIVolumeSource(p Policy) []Case[v1.DownwardAPIVolumeSource] {
	cases := []Case[v1.DownwardAPIVolumeSource]{}
	cs0 := constructAtomicSliceDownwardAPIVolumeFile(NoLimit)
	cs1 := constructPointerInt32(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[v1.DownwardAPIVolumeSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructAtomicSliceDownwardAPIVolumeFile(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Items = c0.expected
		nc.dst.Items = c0.dst
		nc.src.Items = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructPointerInt32(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.DefaultMode = c1.expected
		nc.dst.DefaultMode = c1.dst
		nc.src.DefaultMode = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructAtomicSliceDownwardAPIVolumeFile(p Policy) []Case[[]v1.DownwardAPIVolumeFile] {
	cases := []Case[[]v1.DownwardAPIVolumeFile]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructDownwardAPIVolumeFile(NoLimit)
	var nc Case[[]v1.DownwardAPIVolumeFile]
	nc = Case[[]v1.DownwardAPIVolumeFile]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.src)
		nc.dst = append(nc.dst, c.dst)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.DownwardAPIVolumeFile]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.dst)
		nc.dst = append(nc.dst, c.dst)
	}
	nc.src = []v1.DownwardAPIVolumeFile{}
	cases = append(cases, nc)
	return cases
}
func constructDownwardAPIVolumeFile(p Policy) []Case[v1.DownwardAPIVolumeFile] {
	cases := []Case[v1.DownwardAPIVolumeFile]{}
	cs0 := constructString(NoLimit)
	cs1 := constructAtomicPointerObjectFieldSelector(NoLimit)
	cs2 := constructAtomicPointerResourceFieldSelector(NoLimit)
	cs3 := constructPointerInt32(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	for i := range maxCount {
		nc := Case[v1.DownwardAPIVolumeFile]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Path = c0.expected
		nc.dst.Path = c0.dst
		nc.src.Path = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructAtomicPointerObjectFieldSelector(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.FieldRef = c1.expected
		nc.dst.FieldRef = c1.dst
		nc.src.FieldRef = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructAtomicPointerResourceFieldSelector(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.ResourceFieldRef = c2.expected
		nc.dst.ResourceFieldRef = c2.dst
		nc.src.ResourceFieldRef = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructPointerInt32(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.Mode = c3.expected
		nc.dst.Mode = c3.dst
		nc.src.Mode = c3.src
		cases = append(cases, nc)
	}
	return cases
}
func constructAtomicPointerObjectFieldSelector(p Policy) []Case[*v1.ObjectFieldSelector] {
	cases := []Case[*v1.ObjectFieldSelector]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructAtomicObjectFieldSelector(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.ObjectFieldSelector]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructAtomicObjectFieldSelector(p Policy) []Case[v1.ObjectFieldSelector] {
	cases := []Case[v1.ObjectFieldSelector]{}
	cs0 := constructString(NoLimit)
	cs1 := constructString(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[v1.ObjectFieldSelector]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.APIVersion = c0.src
		nc.dst.APIVersion = c0.dst
		nc.src.APIVersion = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.FieldPath = c1.src
		nc.dst.FieldPath = c1.dst
		nc.src.FieldPath = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructAtomicPointerResourceFieldSelector(p Policy) []Case[*v1.ResourceFieldSelector] {
	cases := []Case[*v1.ResourceFieldSelector]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructAtomicResourceFieldSelector(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.ResourceFieldSelector]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructAtomicResourceFieldSelector(p Policy) []Case[v1.ResourceFieldSelector] {
	cases := []Case[v1.ResourceFieldSelector]{}
	cs0 := constructString(NoLimit)
	cs1 := constructString(NoLimit)
	cs2 := constructQuantity(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	for i := range maxCount {
		nc := Case[v1.ResourceFieldSelector]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.ContainerName = c0.src
		nc.dst.ContainerName = c0.dst
		nc.src.ContainerName = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Resource = c1.src
		nc.dst.Resource = c1.dst
		nc.src.Resource = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructQuantity(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.Divisor = c2.src
		nc.dst.Divisor = c2.dst
		nc.src.Divisor = c2.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerFCVolumeSource(p Policy) []Case[*v1.FCVolumeSource] {
	cases := []Case[*v1.FCVolumeSource]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructFCVolumeSource(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.FCVolumeSource]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructFCVolumeSource(p Policy) []Case[v1.FCVolumeSource] {
	cases := []Case[v1.FCVolumeSource]{}
	cs0 := constructAtomicSliceString(NoLimit)
	cs1 := constructPointerInt32(NoLimit)
	cs2 := constructString(NoLimit)
	cs3 := constructBool(NoLimit)
	cs4 := constructAtomicSliceString(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
		len(cs4),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	k4 := 0
	for i := range maxCount {
		nc := Case[v1.FCVolumeSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructAtomicSliceString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.TargetWWNs = c0.expected
		nc.dst.TargetWWNs = c0.dst
		nc.src.TargetWWNs = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructPointerInt32(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Lun = c1.expected
		nc.dst.Lun = c1.dst
		nc.src.Lun = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructString(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.FSType = c2.expected
		nc.dst.FSType = c2.dst
		nc.src.FSType = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructBool(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.ReadOnly = c3.expected
		nc.dst.ReadOnly = c3.dst
		nc.src.ReadOnly = c3.src
		if i/len(cs4) > k4 {
			cs4 = constructAtomicSliceString(NoLimit)
			k4 += 1
		}
		c4 := &cs4[i%len(cs4)]
		nc.expected.WWIDs = c4.expected
		nc.dst.WWIDs = c4.dst
		nc.src.WWIDs = c4.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerAzureFileVolumeSource(p Policy) []Case[*v1.AzureFileVolumeSource] {
	cases := []Case[*v1.AzureFileVolumeSource]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructAzureFileVolumeSource(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.AzureFileVolumeSource]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructAzureFileVolumeSource(p Policy) []Case[v1.AzureFileVolumeSource] {
	cases := []Case[v1.AzureFileVolumeSource]{}
	cs0 := constructString(NoLimit)
	cs1 := constructString(NoLimit)
	cs2 := constructBool(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	for i := range maxCount {
		nc := Case[v1.AzureFileVolumeSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.SecretName = c0.expected
		nc.dst.SecretName = c0.dst
		nc.src.SecretName = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.ShareName = c1.expected
		nc.dst.ShareName = c1.dst
		nc.src.ShareName = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructBool(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.ReadOnly = c2.expected
		nc.dst.ReadOnly = c2.dst
		nc.src.ReadOnly = c2.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerConfigMapVolumeSource(p Policy) []Case[*v1.ConfigMapVolumeSource] {
	cases := []Case[*v1.ConfigMapVolumeSource]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructConfigMapVolumeSource(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.ConfigMapVolumeSource]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructConfigMapVolumeSource(p Policy) []Case[v1.ConfigMapVolumeSource] {
	cases := []Case[v1.ConfigMapVolumeSource]{}
	cs0 := constructAtomicLocalObjectReference(NoLimit)
	cs1 := constructAtomicSliceKeyToPath(NoLimit)
	cs2 := constructPointerInt32(NoLimit)
	cs3 := constructPointerBool(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	for i := range maxCount {
		nc := Case[v1.ConfigMapVolumeSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructAtomicLocalObjectReference(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.LocalObjectReference = c0.expected
		nc.dst.LocalObjectReference = c0.dst
		nc.src.LocalObjectReference = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructAtomicSliceKeyToPath(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Items = c1.expected
		nc.dst.Items = c1.dst
		nc.src.Items = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructPointerInt32(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.DefaultMode = c2.expected
		nc.dst.DefaultMode = c2.dst
		nc.src.DefaultMode = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructPointerBool(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.Optional = c3.expected
		nc.dst.Optional = c3.dst
		nc.src.Optional = c3.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerVsphereVirtualDiskVolumeSource(p Policy) []Case[*v1.VsphereVirtualDiskVolumeSource] {
	cases := []Case[*v1.VsphereVirtualDiskVolumeSource]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructVsphereVirtualDiskVolumeSource(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.VsphereVirtualDiskVolumeSource]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructVsphereVirtualDiskVolumeSource(p Policy) []Case[v1.VsphereVirtualDiskVolumeSource] {
	cases := []Case[v1.VsphereVirtualDiskVolumeSource]{}
	cs0 := constructString(NoLimit)
	cs1 := constructString(NoLimit)
	cs2 := constructString(NoLimit)
	cs3 := constructString(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	for i := range maxCount {
		nc := Case[v1.VsphereVirtualDiskVolumeSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.VolumePath = c0.expected
		nc.dst.VolumePath = c0.dst
		nc.src.VolumePath = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.FSType = c1.expected
		nc.dst.FSType = c1.dst
		nc.src.FSType = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructString(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.StoragePolicyName = c2.expected
		nc.dst.StoragePolicyName = c2.dst
		nc.src.StoragePolicyName = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructString(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.StoragePolicyID = c3.expected
		nc.dst.StoragePolicyID = c3.dst
		nc.src.StoragePolicyID = c3.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerQuobyteVolumeSource(p Policy) []Case[*v1.QuobyteVolumeSource] {
	cases := []Case[*v1.QuobyteVolumeSource]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructQuobyteVolumeSource(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.QuobyteVolumeSource]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructQuobyteVolumeSource(p Policy) []Case[v1.QuobyteVolumeSource] {
	cases := []Case[v1.QuobyteVolumeSource]{}
	cs0 := constructString(NoLimit)
	cs1 := constructString(NoLimit)
	cs2 := constructBool(NoLimit)
	cs3 := constructString(NoLimit)
	cs4 := constructString(NoLimit)
	cs5 := constructString(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
		len(cs4),
		len(cs5),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	k4 := 0
	k5 := 0
	for i := range maxCount {
		nc := Case[v1.QuobyteVolumeSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Registry = c0.expected
		nc.dst.Registry = c0.dst
		nc.src.Registry = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Volume = c1.expected
		nc.dst.Volume = c1.dst
		nc.src.Volume = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructBool(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.ReadOnly = c2.expected
		nc.dst.ReadOnly = c2.dst
		nc.src.ReadOnly = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructString(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.User = c3.expected
		nc.dst.User = c3.dst
		nc.src.User = c3.src
		if i/len(cs4) > k4 {
			cs4 = constructString(NoLimit)
			k4 += 1
		}
		c4 := &cs4[i%len(cs4)]
		nc.expected.Group = c4.expected
		nc.dst.Group = c4.dst
		nc.src.Group = c4.src
		if i/len(cs5) > k5 {
			cs5 = constructString(NoLimit)
			k5 += 1
		}
		c5 := &cs5[i%len(cs5)]
		nc.expected.Tenant = c5.expected
		nc.dst.Tenant = c5.dst
		nc.src.Tenant = c5.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerAzureDiskVolumeSource(p Policy) []Case[*v1.AzureDiskVolumeSource] {
	cases := []Case[*v1.AzureDiskVolumeSource]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructAzureDiskVolumeSource(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.AzureDiskVolumeSource]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructAzureDiskVolumeSource(p Policy) []Case[v1.AzureDiskVolumeSource] {
	cases := []Case[v1.AzureDiskVolumeSource]{}
	cs0 := constructString(NoLimit)
	cs1 := constructString(NoLimit)
	cs2 := constructPointerAzureDataDiskCachingMode(NoLimit)
	cs3 := constructPointerString(NoLimit)
	cs4 := constructPointerBool(NoLimit)
	cs5 := constructPointerAzureDataDiskKind(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
		len(cs4),
		len(cs5),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	k4 := 0
	k5 := 0
	for i := range maxCount {
		nc := Case[v1.AzureDiskVolumeSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.DiskName = c0.expected
		nc.dst.DiskName = c0.dst
		nc.src.DiskName = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.DataDiskURI = c1.expected
		nc.dst.DataDiskURI = c1.dst
		nc.src.DataDiskURI = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructPointerAzureDataDiskCachingMode(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.CachingMode = c2.expected
		nc.dst.CachingMode = c2.dst
		nc.src.CachingMode = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructPointerString(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.FSType = c3.expected
		nc.dst.FSType = c3.dst
		nc.src.FSType = c3.src
		if i/len(cs4) > k4 {
			cs4 = constructPointerBool(NoLimit)
			k4 += 1
		}
		c4 := &cs4[i%len(cs4)]
		nc.expected.ReadOnly = c4.expected
		nc.dst.ReadOnly = c4.dst
		nc.src.ReadOnly = c4.src
		if i/len(cs5) > k5 {
			cs5 = constructPointerAzureDataDiskKind(NoLimit)
			k5 += 1
		}
		c5 := &cs5[i%len(cs5)]
		nc.expected.Kind = c5.expected
		nc.dst.Kind = c5.dst
		nc.src.Kind = c5.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerAzureDataDiskCachingMode(p Policy) []Case[*v1.AzureDataDiskCachingMode] {
	cases := []Case[*v1.AzureDataDiskCachingMode]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructAzureDataDiskCachingMode(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.AzureDataDiskCachingMode]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructAzureDataDiskCachingMode(p Policy) []Case[v1.AzureDataDiskCachingMode] {
	cases := []Case[v1.AzureDataDiskCachingMode]{}
	cs := constructString(p)
	for _, c := range cs {
		cases = append(cases, Case[v1.AzureDataDiskCachingMode]{
			expected: v1.AzureDataDiskCachingMode(c.expected),
			dst:      v1.AzureDataDiskCachingMode(c.dst),
			src:      v1.AzureDataDiskCachingMode(c.src),
		})
	}
	return cases
}
func constructPointerAzureDataDiskKind(p Policy) []Case[*v1.AzureDataDiskKind] {
	cases := []Case[*v1.AzureDataDiskKind]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructAzureDataDiskKind(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.AzureDataDiskKind]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructAzureDataDiskKind(p Policy) []Case[v1.AzureDataDiskKind] {
	cases := []Case[v1.AzureDataDiskKind]{}
	cs := constructString(p)
	for _, c := range cs {
		cases = append(cases, Case[v1.AzureDataDiskKind]{
			expected: v1.AzureDataDiskKind(c.expected),
			dst:      v1.AzureDataDiskKind(c.dst),
			src:      v1.AzureDataDiskKind(c.src),
		})
	}
	return cases
}
func constructPointerPhotonPersistentDiskVolumeSource(p Policy) []Case[*v1.PhotonPersistentDiskVolumeSource] {
	cases := []Case[*v1.PhotonPersistentDiskVolumeSource]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructPhotonPersistentDiskVolumeSource(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.PhotonPersistentDiskVolumeSource]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructPhotonPersistentDiskVolumeSource(p Policy) []Case[v1.PhotonPersistentDiskVolumeSource] {
	cases := []Case[v1.PhotonPersistentDiskVolumeSource]{}
	cs0 := constructString(NoLimit)
	cs1 := constructString(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[v1.PhotonPersistentDiskVolumeSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.PdID = c0.expected
		nc.dst.PdID = c0.dst
		nc.src.PdID = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.FSType = c1.expected
		nc.dst.FSType = c1.dst
		nc.src.FSType = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerProjectedVolumeSource(p Policy) []Case[*v1.ProjectedVolumeSource] {
	cases := []Case[*v1.ProjectedVolumeSource]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructProjectedVolumeSource(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.ProjectedVolumeSource]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructProjectedVolumeSource(p Policy) []Case[v1.ProjectedVolumeSource] {
	cases := []Case[v1.ProjectedVolumeSource]{}
	cs0 := constructAtomicSliceVolumeProjection(NoLimit)
	cs1 := constructPointerInt32(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[v1.ProjectedVolumeSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructAtomicSliceVolumeProjection(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Sources = c0.expected
		nc.dst.Sources = c0.dst
		nc.src.Sources = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructPointerInt32(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.DefaultMode = c1.expected
		nc.dst.DefaultMode = c1.dst
		nc.src.DefaultMode = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructAtomicSliceVolumeProjection(p Policy) []Case[[]v1.VolumeProjection] {
	cases := []Case[[]v1.VolumeProjection]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructVolumeProjection(NoLimit)
	var nc Case[[]v1.VolumeProjection]
	nc = Case[[]v1.VolumeProjection]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.src)
		nc.dst = append(nc.dst, c.dst)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.VolumeProjection]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.dst)
		nc.dst = append(nc.dst, c.dst)
	}
	nc.src = []v1.VolumeProjection{}
	cases = append(cases, nc)
	return cases
}
func constructVolumeProjection(p Policy) []Case[v1.VolumeProjection] {
	cases := []Case[v1.VolumeProjection]{}
	cs0 := constructPointerSecretProjection(NoLimit)
	cs1 := constructPointerDownwardAPIProjection(NoLimit)
	cs2 := constructPointerConfigMapProjection(NoLimit)
	cs3 := constructPointerServiceAccountTokenProjection(NoLimit)
	cs4 := constructPointerClusterTrustBundleProjection(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
		len(cs4),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	k4 := 0
	for i := range maxCount {
		nc := Case[v1.VolumeProjection]{}
		if i/len(cs0) > k0 {
			cs0 = constructPointerSecretProjection(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Secret = c0.expected
		nc.dst.Secret = c0.dst
		nc.src.Secret = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructPointerDownwardAPIProjection(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.DownwardAPI = c1.expected
		nc.dst.DownwardAPI = c1.dst
		nc.src.DownwardAPI = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructPointerConfigMapProjection(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.ConfigMap = c2.expected
		nc.dst.ConfigMap = c2.dst
		nc.src.ConfigMap = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructPointerServiceAccountTokenProjection(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.ServiceAccountToken = c3.expected
		nc.dst.ServiceAccountToken = c3.dst
		nc.src.ServiceAccountToken = c3.src
		if i/len(cs4) > k4 {
			cs4 = constructPointerClusterTrustBundleProjection(NoLimit)
			k4 += 1
		}
		c4 := &cs4[i%len(cs4)]
		nc.expected.ClusterTrustBundle = c4.expected
		nc.dst.ClusterTrustBundle = c4.dst
		nc.src.ClusterTrustBundle = c4.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerSecretProjection(p Policy) []Case[*v1.SecretProjection] {
	cases := []Case[*v1.SecretProjection]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructSecretProjection(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.SecretProjection]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructSecretProjection(p Policy) []Case[v1.SecretProjection] {
	cases := []Case[v1.SecretProjection]{}
	cs0 := constructAtomicLocalObjectReference(NoLimit)
	cs1 := constructAtomicSliceKeyToPath(NoLimit)
	cs2 := constructPointerBool(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	for i := range maxCount {
		nc := Case[v1.SecretProjection]{}
		if i/len(cs0) > k0 {
			cs0 = constructAtomicLocalObjectReference(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.LocalObjectReference = c0.expected
		nc.dst.LocalObjectReference = c0.dst
		nc.src.LocalObjectReference = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructAtomicSliceKeyToPath(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Items = c1.expected
		nc.dst.Items = c1.dst
		nc.src.Items = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructPointerBool(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.Optional = c2.expected
		nc.dst.Optional = c2.dst
		nc.src.Optional = c2.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerDownwardAPIProjection(p Policy) []Case[*v1.DownwardAPIProjection] {
	cases := []Case[*v1.DownwardAPIProjection]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructDownwardAPIProjection(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.DownwardAPIProjection]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructDownwardAPIProjection(p Policy) []Case[v1.DownwardAPIProjection] {
	cases := []Case[v1.DownwardAPIProjection]{}
	cs0 := constructAtomicSliceDownwardAPIVolumeFile(NoLimit)
	maxCount := max(
		len(cs0),
	)
	k0 := 0
	for i := range maxCount {
		nc := Case[v1.DownwardAPIProjection]{}
		if i/len(cs0) > k0 {
			cs0 = constructAtomicSliceDownwardAPIVolumeFile(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Items = c0.expected
		nc.dst.Items = c0.dst
		nc.src.Items = c0.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerConfigMapProjection(p Policy) []Case[*v1.ConfigMapProjection] {
	cases := []Case[*v1.ConfigMapProjection]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructConfigMapProjection(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.ConfigMapProjection]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructConfigMapProjection(p Policy) []Case[v1.ConfigMapProjection] {
	cases := []Case[v1.ConfigMapProjection]{}
	cs0 := constructAtomicLocalObjectReference(NoLimit)
	cs1 := constructAtomicSliceKeyToPath(NoLimit)
	cs2 := constructPointerBool(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	for i := range maxCount {
		nc := Case[v1.ConfigMapProjection]{}
		if i/len(cs0) > k0 {
			cs0 = constructAtomicLocalObjectReference(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.LocalObjectReference = c0.expected
		nc.dst.LocalObjectReference = c0.dst
		nc.src.LocalObjectReference = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructAtomicSliceKeyToPath(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Items = c1.expected
		nc.dst.Items = c1.dst
		nc.src.Items = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructPointerBool(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.Optional = c2.expected
		nc.dst.Optional = c2.dst
		nc.src.Optional = c2.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerServiceAccountTokenProjection(p Policy) []Case[*v1.ServiceAccountTokenProjection] {
	cases := []Case[*v1.ServiceAccountTokenProjection]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructServiceAccountTokenProjection(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.ServiceAccountTokenProjection]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructServiceAccountTokenProjection(p Policy) []Case[v1.ServiceAccountTokenProjection] {
	cases := []Case[v1.ServiceAccountTokenProjection]{}
	cs0 := constructString(NoLimit)
	cs1 := constructPointerInt64(NoLimit)
	cs2 := constructString(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	for i := range maxCount {
		nc := Case[v1.ServiceAccountTokenProjection]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Audience = c0.expected
		nc.dst.Audience = c0.dst
		nc.src.Audience = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructPointerInt64(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.ExpirationSeconds = c1.expected
		nc.dst.ExpirationSeconds = c1.dst
		nc.src.ExpirationSeconds = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructString(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.Path = c2.expected
		nc.dst.Path = c2.dst
		nc.src.Path = c2.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerInt64(p Policy) []Case[*int64] {
	cases := []Case[*int64]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructInt64(p)
	for _, c := range cs {
		cases = append(cases, Case[*int64]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructInt64(p Policy) []Case[int64] {
	cases := []Case[int64]{}
	if p&(NoZero) == 0 {
		cases = append(cases, Case[int64]{expected: 0, dst: 0, src: 0})
	}
	if p&(NoNotEqual) == 0 {
		if p&(NoNotEqual) == 0 {
			cases = append(cases, Case[int64]{expected: 1, dst: 2, src: 1})
			cases = append(cases, Case[int64]{expected: -1, dst: 2, src: -1})
			cases = append(cases, Case[int64]{expected: 1, dst: -2, src: 1})
			cases = append(cases, Case[int64]{expected: -1, dst: -2, src: -1})
		}
	}
	if p&(NoZero|NoNotEqual) == 0 {
		cases = append(cases, Case[int64]{expected: 1, dst: 1, src: 0})
		cases = append(cases, Case[int64]{expected: -1, dst: -1, src: 0})
		cases = append(cases, Case[int64]{expected: 1, dst: 0, src: 1})
		cases = append(cases, Case[int64]{expected: -1, dst: 0, src: -1})
	}
	cases = append(cases, Case[int64]{expected: 1, dst: 1, src: 1})
	cases = append(cases, Case[int64]{expected: -1, dst: -1, src: -1})
	return cases
}
func constructPointerClusterTrustBundleProjection(p Policy) []Case[*v1.ClusterTrustBundleProjection] {
	cases := []Case[*v1.ClusterTrustBundleProjection]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructClusterTrustBundleProjection(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.ClusterTrustBundleProjection]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructClusterTrustBundleProjection(p Policy) []Case[v1.ClusterTrustBundleProjection] {
	cases := []Case[v1.ClusterTrustBundleProjection]{}
	cs0 := constructPointerString(NoLimit)
	cs1 := constructPointerString(NoLimit)
	cs2 := constructPointerLabelSelector(NoLimit)
	cs3 := constructPointerBool(NoLimit)
	cs4 := constructString(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
		len(cs4),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	k4 := 0
	for i := range maxCount {
		nc := Case[v1.ClusterTrustBundleProjection]{}
		if i/len(cs0) > k0 {
			cs0 = constructPointerString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Name = c0.expected
		nc.dst.Name = c0.dst
		nc.src.Name = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructPointerString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.SignerName = c1.expected
		nc.dst.SignerName = c1.dst
		nc.src.SignerName = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructPointerLabelSelector(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.LabelSelector = c2.expected
		nc.dst.LabelSelector = c2.dst
		nc.src.LabelSelector = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructPointerBool(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.Optional = c3.expected
		nc.dst.Optional = c3.dst
		nc.src.Optional = c3.src
		if i/len(cs4) > k4 {
			cs4 = constructString(NoLimit)
			k4 += 1
		}
		c4 := &cs4[i%len(cs4)]
		nc.expected.Path = c4.expected
		nc.dst.Path = c4.dst
		nc.src.Path = c4.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerLabelSelector(p Policy) []Case[*metav1.LabelSelector] {
	cases := []Case[*metav1.LabelSelector]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructLabelSelector(p)
	for _, c := range cs {
		cases = append(cases, Case[*metav1.LabelSelector]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructLabelSelector(p Policy) []Case[metav1.LabelSelector] {
	cases := []Case[metav1.LabelSelector]{}
	cs0 := constructMapStringToString(NoLimit)
	cs1 := constructAtomicSliceLabelSelectorRequirement(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[metav1.LabelSelector]{}
		if i/len(cs0) > k0 {
			cs0 = constructMapStringToString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.MatchLabels = c0.expected
		nc.dst.MatchLabels = c0.dst
		nc.src.MatchLabels = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructAtomicSliceLabelSelectorRequirement(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.MatchExpressions = c1.expected
		nc.dst.MatchExpressions = c1.dst
		nc.src.MatchExpressions = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructAtomicSliceLabelSelectorRequirement(p Policy) []Case[[]metav1.LabelSelectorRequirement] {
	cases := []Case[[]metav1.LabelSelectorRequirement]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructLabelSelectorRequirement(NoLimit)
	var nc Case[[]metav1.LabelSelectorRequirement]
	nc = Case[[]metav1.LabelSelectorRequirement]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.src)
		nc.dst = append(nc.dst, c.dst)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]metav1.LabelSelectorRequirement]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.dst)
		nc.dst = append(nc.dst, c.dst)
	}
	nc.src = []metav1.LabelSelectorRequirement{}
	cases = append(cases, nc)
	return cases
}
func constructLabelSelectorRequirement(p Policy) []Case[metav1.LabelSelectorRequirement] {
	cases := []Case[metav1.LabelSelectorRequirement]{}
	cs0 := constructString(NoLimit)
	cs1 := constructLabelSelectorOperator(NoLimit)
	cs2 := constructAtomicSliceString(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	for i := range maxCount {
		nc := Case[metav1.LabelSelectorRequirement]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Key = c0.expected
		nc.dst.Key = c0.dst
		nc.src.Key = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructLabelSelectorOperator(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Operator = c1.expected
		nc.dst.Operator = c1.dst
		nc.src.Operator = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructAtomicSliceString(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.Values = c2.expected
		nc.dst.Values = c2.dst
		nc.src.Values = c2.src
		cases = append(cases, nc)
	}
	return cases
}
func constructLabelSelectorOperator(p Policy) []Case[metav1.LabelSelectorOperator] {
	cases := []Case[metav1.LabelSelectorOperator]{}
	cs := constructString(p)
	for _, c := range cs {
		cases = append(cases, Case[metav1.LabelSelectorOperator]{
			expected: metav1.LabelSelectorOperator(c.expected),
			dst:      metav1.LabelSelectorOperator(c.dst),
			src:      metav1.LabelSelectorOperator(c.src),
		})
	}
	return cases
}
func constructPointerPortworxVolumeSource(p Policy) []Case[*v1.PortworxVolumeSource] {
	cases := []Case[*v1.PortworxVolumeSource]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructPortworxVolumeSource(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.PortworxVolumeSource]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructPortworxVolumeSource(p Policy) []Case[v1.PortworxVolumeSource] {
	cases := []Case[v1.PortworxVolumeSource]{}
	cs0 := constructString(NoLimit)
	cs1 := constructString(NoLimit)
	cs2 := constructBool(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	for i := range maxCount {
		nc := Case[v1.PortworxVolumeSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.VolumeID = c0.expected
		nc.dst.VolumeID = c0.dst
		nc.src.VolumeID = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.FSType = c1.expected
		nc.dst.FSType = c1.dst
		nc.src.FSType = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructBool(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.ReadOnly = c2.expected
		nc.dst.ReadOnly = c2.dst
		nc.src.ReadOnly = c2.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerScaleIOVolumeSource(p Policy) []Case[*v1.ScaleIOVolumeSource] {
	cases := []Case[*v1.ScaleIOVolumeSource]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructScaleIOVolumeSource(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.ScaleIOVolumeSource]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructScaleIOVolumeSource(p Policy) []Case[v1.ScaleIOVolumeSource] {
	cases := []Case[v1.ScaleIOVolumeSource]{}
	cs0 := constructString(NoLimit)
	cs1 := constructString(NoLimit)
	cs2 := constructAtomicPointerLocalObjectReference(NoLimit)
	cs3 := constructBool(NoLimit)
	cs4 := constructString(NoLimit)
	cs5 := constructString(NoLimit)
	cs6 := constructString(NoLimit)
	cs7 := constructString(NoLimit)
	cs8 := constructString(NoLimit)
	cs9 := constructBool(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
		len(cs4),
		len(cs5),
		len(cs6),
		len(cs7),
		len(cs8),
		len(cs9),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	k4 := 0
	k5 := 0
	k6 := 0
	k7 := 0
	k8 := 0
	k9 := 0
	for i := range maxCount {
		nc := Case[v1.ScaleIOVolumeSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Gateway = c0.expected
		nc.dst.Gateway = c0.dst
		nc.src.Gateway = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.System = c1.expected
		nc.dst.System = c1.dst
		nc.src.System = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructAtomicPointerLocalObjectReference(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.SecretRef = c2.expected
		nc.dst.SecretRef = c2.dst
		nc.src.SecretRef = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructBool(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.SSLEnabled = c3.expected
		nc.dst.SSLEnabled = c3.dst
		nc.src.SSLEnabled = c3.src
		if i/len(cs4) > k4 {
			cs4 = constructString(NoLimit)
			k4 += 1
		}
		c4 := &cs4[i%len(cs4)]
		nc.expected.ProtectionDomain = c4.expected
		nc.dst.ProtectionDomain = c4.dst
		nc.src.ProtectionDomain = c4.src
		if i/len(cs5) > k5 {
			cs5 = constructString(NoLimit)
			k5 += 1
		}
		c5 := &cs5[i%len(cs5)]
		nc.expected.StoragePool = c5.expected
		nc.dst.StoragePool = c5.dst
		nc.src.StoragePool = c5.src
		if i/len(cs6) > k6 {
			cs6 = constructString(NoLimit)
			k6 += 1
		}
		c6 := &cs6[i%len(cs6)]
		nc.expected.StorageMode = c6.expected
		nc.dst.StorageMode = c6.dst
		nc.src.StorageMode = c6.src
		if i/len(cs7) > k7 {
			cs7 = constructString(NoLimit)
			k7 += 1
		}
		c7 := &cs7[i%len(cs7)]
		nc.expected.VolumeName = c7.expected
		nc.dst.VolumeName = c7.dst
		nc.src.VolumeName = c7.src
		if i/len(cs8) > k8 {
			cs8 = constructString(NoLimit)
			k8 += 1
		}
		c8 := &cs8[i%len(cs8)]
		nc.expected.FSType = c8.expected
		nc.dst.FSType = c8.dst
		nc.src.FSType = c8.src
		if i/len(cs9) > k9 {
			cs9 = constructBool(NoLimit)
			k9 += 1
		}
		c9 := &cs9[i%len(cs9)]
		nc.expected.ReadOnly = c9.expected
		nc.dst.ReadOnly = c9.dst
		nc.src.ReadOnly = c9.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerStorageOSVolumeSource(p Policy) []Case[*v1.StorageOSVolumeSource] {
	cases := []Case[*v1.StorageOSVolumeSource]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructStorageOSVolumeSource(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.StorageOSVolumeSource]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructStorageOSVolumeSource(p Policy) []Case[v1.StorageOSVolumeSource] {
	cases := []Case[v1.StorageOSVolumeSource]{}
	cs0 := constructString(NoLimit)
	cs1 := constructString(NoLimit)
	cs2 := constructString(NoLimit)
	cs3 := constructBool(NoLimit)
	cs4 := constructAtomicPointerLocalObjectReference(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
		len(cs4),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	k4 := 0
	for i := range maxCount {
		nc := Case[v1.StorageOSVolumeSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.VolumeName = c0.expected
		nc.dst.VolumeName = c0.dst
		nc.src.VolumeName = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.VolumeNamespace = c1.expected
		nc.dst.VolumeNamespace = c1.dst
		nc.src.VolumeNamespace = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructString(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.FSType = c2.expected
		nc.dst.FSType = c2.dst
		nc.src.FSType = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructBool(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.ReadOnly = c3.expected
		nc.dst.ReadOnly = c3.dst
		nc.src.ReadOnly = c3.src
		if i/len(cs4) > k4 {
			cs4 = constructAtomicPointerLocalObjectReference(NoLimit)
			k4 += 1
		}
		c4 := &cs4[i%len(cs4)]
		nc.expected.SecretRef = c4.expected
		nc.dst.SecretRef = c4.dst
		nc.src.SecretRef = c4.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerCSIVolumeSource(p Policy) []Case[*v1.CSIVolumeSource] {
	cases := []Case[*v1.CSIVolumeSource]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructCSIVolumeSource(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.CSIVolumeSource]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructCSIVolumeSource(p Policy) []Case[v1.CSIVolumeSource] {
	cases := []Case[v1.CSIVolumeSource]{}
	cs0 := constructString(NoLimit)
	cs1 := constructPointerBool(NoLimit)
	cs2 := constructPointerString(NoLimit)
	cs3 := constructMapStringToString(NoLimit)
	cs4 := constructAtomicPointerLocalObjectReference(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
		len(cs4),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	k4 := 0
	for i := range maxCount {
		nc := Case[v1.CSIVolumeSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Driver = c0.expected
		nc.dst.Driver = c0.dst
		nc.src.Driver = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructPointerBool(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.ReadOnly = c1.expected
		nc.dst.ReadOnly = c1.dst
		nc.src.ReadOnly = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructPointerString(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.FSType = c2.expected
		nc.dst.FSType = c2.dst
		nc.src.FSType = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructMapStringToString(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.VolumeAttributes = c3.expected
		nc.dst.VolumeAttributes = c3.dst
		nc.src.VolumeAttributes = c3.src
		if i/len(cs4) > k4 {
			cs4 = constructAtomicPointerLocalObjectReference(NoLimit)
			k4 += 1
		}
		c4 := &cs4[i%len(cs4)]
		nc.expected.NodePublishSecretRef = c4.expected
		nc.dst.NodePublishSecretRef = c4.dst
		nc.src.NodePublishSecretRef = c4.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerEphemeralVolumeSource(p Policy) []Case[*v1.EphemeralVolumeSource] {
	cases := []Case[*v1.EphemeralVolumeSource]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructEphemeralVolumeSource(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.EphemeralVolumeSource]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructEphemeralVolumeSource(p Policy) []Case[v1.EphemeralVolumeSource] {
	cases := []Case[v1.EphemeralVolumeSource]{}
	cs0 := constructPointerPersistentVolumeClaimTemplate(NoLimit)
	maxCount := max(
		len(cs0),
	)
	k0 := 0
	for i := range maxCount {
		nc := Case[v1.EphemeralVolumeSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructPointerPersistentVolumeClaimTemplate(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.VolumeClaimTemplate = c0.expected
		nc.dst.VolumeClaimTemplate = c0.dst
		nc.src.VolumeClaimTemplate = c0.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerPersistentVolumeClaimTemplate(p Policy) []Case[*v1.PersistentVolumeClaimTemplate] {
	cases := []Case[*v1.PersistentVolumeClaimTemplate]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructPersistentVolumeClaimTemplate(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.PersistentVolumeClaimTemplate]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructPersistentVolumeClaimTemplate(p Policy) []Case[v1.PersistentVolumeClaimTemplate] {
	cases := []Case[v1.PersistentVolumeClaimTemplate]{}
	cs0 := constructObjectMeta(NoLimit)
	cs1 := constructPersistentVolumeClaimSpec(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[v1.PersistentVolumeClaimTemplate]{}
		if i/len(cs0) > k0 {
			cs0 = constructObjectMeta(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.ObjectMeta = c0.expected
		nc.dst.ObjectMeta = c0.dst
		nc.src.ObjectMeta = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructPersistentVolumeClaimSpec(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Spec = c1.expected
		nc.dst.Spec = c1.dst
		nc.src.Spec = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPersistentVolumeClaimSpec(p Policy) []Case[v1.PersistentVolumeClaimSpec] {
	cases := []Case[v1.PersistentVolumeClaimSpec]{}
	cs0 := constructAtomicSlicePersistentVolumeAccessMode(NoLimit)
	cs1 := constructPointerLabelSelector(NoLimit)
	cs2 := constructVolumeResourceRequirements(NoLimit)
	cs3 := constructString(NoLimit)
	cs4 := constructPointerString(NoLimit)
	cs5 := constructPointerPersistentVolumeMode(NoLimit)
	cs6 := constructAtomicPointerTypedLocalObjectReference(NoLimit)
	cs7 := constructPointerTypedObjectReference(NoLimit)
	cs8 := constructPointerString(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
		len(cs4),
		len(cs5),
		len(cs6),
		len(cs7),
		len(cs8),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	k4 := 0
	k5 := 0
	k6 := 0
	k7 := 0
	k8 := 0
	for i := range maxCount {
		nc := Case[v1.PersistentVolumeClaimSpec]{}
		if i/len(cs0) > k0 {
			cs0 = constructAtomicSlicePersistentVolumeAccessMode(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.AccessModes = c0.expected
		nc.dst.AccessModes = c0.dst
		nc.src.AccessModes = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructPointerLabelSelector(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Selector = c1.expected
		nc.dst.Selector = c1.dst
		nc.src.Selector = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructVolumeResourceRequirements(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.Resources = c2.expected
		nc.dst.Resources = c2.dst
		nc.src.Resources = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructString(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.VolumeName = c3.expected
		nc.dst.VolumeName = c3.dst
		nc.src.VolumeName = c3.src
		if i/len(cs4) > k4 {
			cs4 = constructPointerString(NoLimit)
			k4 += 1
		}
		c4 := &cs4[i%len(cs4)]
		nc.expected.StorageClassName = c4.expected
		nc.dst.StorageClassName = c4.dst
		nc.src.StorageClassName = c4.src
		if i/len(cs5) > k5 {
			cs5 = constructPointerPersistentVolumeMode(NoLimit)
			k5 += 1
		}
		c5 := &cs5[i%len(cs5)]
		nc.expected.VolumeMode = c5.expected
		nc.dst.VolumeMode = c5.dst
		nc.src.VolumeMode = c5.src
		if i/len(cs6) > k6 {
			cs6 = constructAtomicPointerTypedLocalObjectReference(NoLimit)
			k6 += 1
		}
		c6 := &cs6[i%len(cs6)]
		nc.expected.DataSource = c6.expected
		nc.dst.DataSource = c6.dst
		nc.src.DataSource = c6.src
		if i/len(cs7) > k7 {
			cs7 = constructPointerTypedObjectReference(NoLimit)
			k7 += 1
		}
		c7 := &cs7[i%len(cs7)]
		nc.expected.DataSourceRef = c7.expected
		nc.dst.DataSourceRef = c7.dst
		nc.src.DataSourceRef = c7.src
		if i/len(cs8) > k8 {
			cs8 = constructPointerString(NoLimit)
			k8 += 1
		}
		c8 := &cs8[i%len(cs8)]
		nc.expected.VolumeAttributesClassName = c8.expected
		nc.dst.VolumeAttributesClassName = c8.dst
		nc.src.VolumeAttributesClassName = c8.src
		cases = append(cases, nc)
	}
	return cases
}
func constructAtomicSlicePersistentVolumeAccessMode(p Policy) []Case[[]v1.PersistentVolumeAccessMode] {
	cases := []Case[[]v1.PersistentVolumeAccessMode]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructPersistentVolumeAccessMode(NoLimit)
	var nc Case[[]v1.PersistentVolumeAccessMode]
	nc = Case[[]v1.PersistentVolumeAccessMode]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.src)
		nc.dst = append(nc.dst, c.dst)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.PersistentVolumeAccessMode]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.dst)
		nc.dst = append(nc.dst, c.dst)
	}
	nc.src = []v1.PersistentVolumeAccessMode{}
	cases = append(cases, nc)
	return cases
}
func constructPersistentVolumeAccessMode(p Policy) []Case[v1.PersistentVolumeAccessMode] {
	cases := []Case[v1.PersistentVolumeAccessMode]{}
	cs := constructString(p)
	for _, c := range cs {
		cases = append(cases, Case[v1.PersistentVolumeAccessMode]{
			expected: v1.PersistentVolumeAccessMode(c.expected),
			dst:      v1.PersistentVolumeAccessMode(c.dst),
			src:      v1.PersistentVolumeAccessMode(c.src),
		})
	}
	return cases
}
func constructVolumeResourceRequirements(p Policy) []Case[v1.VolumeResourceRequirements] {
	cases := []Case[v1.VolumeResourceRequirements]{}
	cs0 := constructResourceList(NoLimit)
	cs1 := constructResourceList(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[v1.VolumeResourceRequirements]{}
		if i/len(cs0) > k0 {
			cs0 = constructResourceList(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Limits = c0.expected
		nc.dst.Limits = c0.dst
		nc.src.Limits = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructResourceList(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Requests = c1.expected
		nc.dst.Requests = c1.dst
		nc.src.Requests = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructResourceList(p Policy) []Case[v1.ResourceList] {
	cases := []Case[v1.ResourceList]{}
	cs := constructMapResourceNameToQuantity(p)
	for _, c := range cs {
		cases = append(cases, Case[v1.ResourceList]{
			expected: v1.ResourceList(c.expected),
			dst:      v1.ResourceList(c.dst),
			src:      v1.ResourceList(c.src),
		})
	}
	return cases
}
func constructMapResourceNameToQuantity(p Policy) []Case[map[v1.ResourceName]resource.Quantity] {
	cases := []Case[map[v1.ResourceName]resource.Quantity]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	keys := constructResourceName(NoNil | NoZero | NoNotEqual)
	vals := constructQuantity(NoLimit)
	keyIndex := 0
	var nc Case[map[v1.ResourceName]resource.Quantity]
	for _, val := range vals {
		keyIndex += 1
		if keyIndex >= len(keys) {
			keys = constructResourceName(NoNil | NoZero | NoNotEqual)
			keyIndex = 0
		}
		key := keys[keyIndex]
		nc = Case[map[v1.ResourceName]resource.Quantity]{}
		nc.expected = make(map[v1.ResourceName]resource.Quantity)
		nc.dst = make(map[v1.ResourceName]resource.Quantity)
		nc.src = make(map[v1.ResourceName]resource.Quantity)
		nc.expected[key.expected] = val.expected
		nc.dst[key.expected] = val.dst
		nc.src[key.expected] = val.src
	}
	cases = append(cases, nc)
	for i, val := range vals {
		keyIndex += 1
		if keyIndex >= len(keys) {
			keys = constructResourceName(NoNil | NoZero | NoNotEqual)
			keyIndex = 0
		}
		key := keys[keyIndex]
		nc = Case[map[v1.ResourceName]resource.Quantity]{}
		nc.expected = make(map[v1.ResourceName]resource.Quantity)
		nc.dst = make(map[v1.ResourceName]resource.Quantity)
		nc.src = make(map[v1.ResourceName]resource.Quantity)
		switch i % 3 {
		case 0:
			nc.expected[key.expected] = val.expected
			nc.dst[key.expected] = val.dst
			nc.src[key.expected] = val.src
		case 1:
			nc.expected[key.expected] = val.dst
			nc.dst[key.expected] = val.dst
		case 2:
			nc.expected[key.expected] = val.src
			nc.src[key.expected] = val.src
		}
	}
	cases = append(cases, nc)
	for i, val := range vals {
		keyIndex += 1
		if keyIndex >= len(keys) {
			keys = constructResourceName(NoNil | NoZero | NoNotEqual)
			keyIndex = 0
		}
		key := keys[keyIndex]
		nc = Case[map[v1.ResourceName]resource.Quantity]{}
		nc.expected = make(map[v1.ResourceName]resource.Quantity)
		nc.dst = make(map[v1.ResourceName]resource.Quantity)
		nc.src = make(map[v1.ResourceName]resource.Quantity)
		switch i % 2 {
		case 0:
			nc.expected[key.expected] = val.dst
			nc.dst[key.expected] = val.dst
		case 1:
			nc.expected[key.expected] = val.src
			nc.src[key.expected] = val.src
		}
	}
	cases = append(cases, nc)
	for _, val := range vals {
		keyIndex += 1
		if keyIndex >= len(keys) {
			keys = constructResourceName(NoNil | NoZero | NoNotEqual)
			keyIndex = 0
		}
		key := keys[keyIndex]
		nc = Case[map[v1.ResourceName]resource.Quantity]{}
		nc.expected = make(map[v1.ResourceName]resource.Quantity)
		nc.dst = make(map[v1.ResourceName]resource.Quantity)
		nc.src = make(map[v1.ResourceName]resource.Quantity)
		nc.expected[key.expected] = val.src
		nc.src[key.expected] = val.src
	}
	cases = append(cases, nc)
	for _, val := range vals {
		keyIndex += 1
		if keyIndex >= len(keys) {
			keys = constructResourceName(NoNil | NoZero | NoNotEqual)
			keyIndex = 0
		}
		key := keys[keyIndex]
		nc = Case[map[v1.ResourceName]resource.Quantity]{}
		nc.expected = make(map[v1.ResourceName]resource.Quantity)
		nc.dst = make(map[v1.ResourceName]resource.Quantity)
		nc.src = make(map[v1.ResourceName]resource.Quantity)
		nc.expected[key.expected] = val.dst
		nc.dst[key.expected] = val.dst
	}
	cases = append(cases, nc)
	return cases
}
func constructPointerPersistentVolumeMode(p Policy) []Case[*v1.PersistentVolumeMode] {
	cases := []Case[*v1.PersistentVolumeMode]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructPersistentVolumeMode(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.PersistentVolumeMode]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructPersistentVolumeMode(p Policy) []Case[v1.PersistentVolumeMode] {
	cases := []Case[v1.PersistentVolumeMode]{}
	cs := constructString(p)
	for _, c := range cs {
		cases = append(cases, Case[v1.PersistentVolumeMode]{
			expected: v1.PersistentVolumeMode(c.expected),
			dst:      v1.PersistentVolumeMode(c.dst),
			src:      v1.PersistentVolumeMode(c.src),
		})
	}
	return cases
}
func constructAtomicPointerTypedLocalObjectReference(p Policy) []Case[*v1.TypedLocalObjectReference] {
	cases := []Case[*v1.TypedLocalObjectReference]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructAtomicTypedLocalObjectReference(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.TypedLocalObjectReference]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructAtomicTypedLocalObjectReference(p Policy) []Case[v1.TypedLocalObjectReference] {
	cases := []Case[v1.TypedLocalObjectReference]{}
	cs0 := constructPointerString(NoLimit)
	cs1 := constructString(NoLimit)
	cs2 := constructString(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	for i := range maxCount {
		nc := Case[v1.TypedLocalObjectReference]{}
		if i/len(cs0) > k0 {
			cs0 = constructPointerString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.APIGroup = c0.src
		nc.dst.APIGroup = c0.dst
		nc.src.APIGroup = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Kind = c1.src
		nc.dst.Kind = c1.dst
		nc.src.Kind = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructString(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.Name = c2.src
		nc.dst.Name = c2.dst
		nc.src.Name = c2.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerTypedObjectReference(p Policy) []Case[*v1.TypedObjectReference] {
	cases := []Case[*v1.TypedObjectReference]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructTypedObjectReference(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.TypedObjectReference]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructTypedObjectReference(p Policy) []Case[v1.TypedObjectReference] {
	cases := []Case[v1.TypedObjectReference]{}
	cs0 := constructPointerString(NoLimit)
	cs1 := constructString(NoLimit)
	cs2 := constructString(NoLimit)
	cs3 := constructPointerString(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	for i := range maxCount {
		nc := Case[v1.TypedObjectReference]{}
		if i/len(cs0) > k0 {
			cs0 = constructPointerString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.APIGroup = c0.expected
		nc.dst.APIGroup = c0.dst
		nc.src.APIGroup = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Kind = c1.expected
		nc.dst.Kind = c1.dst
		nc.src.Kind = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructString(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.Name = c2.expected
		nc.dst.Name = c2.dst
		nc.src.Name = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructPointerString(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.Namespace = c3.expected
		nc.dst.Namespace = c3.dst
		nc.src.Namespace = c3.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerImageVolumeSource(p Policy) []Case[*v1.ImageVolumeSource] {
	cases := []Case[*v1.ImageVolumeSource]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructImageVolumeSource(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.ImageVolumeSource]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructImageVolumeSource(p Policy) []Case[v1.ImageVolumeSource] {
	cases := []Case[v1.ImageVolumeSource]{}
	cs0 := constructString(NoLimit)
	cs1 := constructPullPolicy(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[v1.ImageVolumeSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Reference = c0.expected
		nc.dst.Reference = c0.dst
		nc.src.Reference = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructPullPolicy(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.PullPolicy = c1.expected
		nc.dst.PullPolicy = c1.dst
		nc.src.PullPolicy = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPullPolicy(p Policy) []Case[v1.PullPolicy] {
	cases := []Case[v1.PullPolicy]{}
	cs := constructString(p)
	for _, c := range cs {
		cases = append(cases, Case[v1.PullPolicy]{
			expected: v1.PullPolicy(c.expected),
			dst:      v1.PullPolicy(c.dst),
			src:      v1.PullPolicy(c.src),
		})
	}
	return cases
}
func constructMapSliceContainer(p Policy) []Case[[]v1.Container] {
	cases := []Case[[]v1.Container]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructContainerIgnore_name(NoLimit)
	var nc Case[[]v1.Container]
	nc = Case[[]v1.Container]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.expected)
		nc.dst = append(nc.dst, c.dst)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.Container]{}
	srcs := []v1.Container{}
	for i, c := range cs {
		switch i % 3 {
		case 0:
			nc.expected = append(nc.expected, c.expected)
			nc.dst = append(nc.dst, c.dst)
			nc.src = append(nc.src, c.src)
		case 1:
			nc.expected = append(nc.expected, c.dst)
			nc.dst = append(nc.dst, c.dst)
		case 2:
			srcs = append(srcs, c.src)
			nc.src = append(nc.src, c.src)
		}
	}
	nc.expected = append(nc.expected, srcs...)
	cases = append(cases, nc)
	nc = Case[[]v1.Container]{}
	srcs = []v1.Container{}
	for i, c := range cs {
		switch i % 2 {
		case 0:
			nc.expected = append(nc.expected, c.dst)
			nc.dst = append(nc.dst, c.dst)
		case 1:
			srcs = append(srcs, c.src)
			nc.src = append(nc.src, c.src)
		}
	}
	nc.expected = append(nc.expected, srcs...)
	cases = append(cases, nc)
	nc = Case[[]v1.Container]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.src)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.Container]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.dst)
		nc.dst = append(nc.dst, c.dst)
	}
	cases = append(cases, nc)
	return cases
}
func constructContainerIgnore_name(p Policy) []Case[v1.Container] {
	cases := []Case[v1.Container]{}
	cs0 := constructString(NoNotEqual | NoZero | NoNil)
	cs1 := constructString(NoLimit)
	cs2 := constructAtomicSliceString(NoLimit)
	cs3 := constructAtomicSliceString(NoLimit)
	cs4 := constructString(NoLimit)
	cs5 := constructMapSliceContainerPort(NoLimit)
	cs6 := constructAtomicSliceEnvFromSource(NoLimit)
	cs7 := constructMapSliceEnvVar(NoLimit)
	cs8 := constructResourceRequirements(NoLimit)
	cs9 := constructAtomicSliceContainerResizePolicy(NoLimit)
	cs10 := constructPointerContainerRestartPolicy(NoLimit)
	cs11 := constructMapSliceVolumeMount(NoLimit)
	cs12 := constructMapSliceVolumeDevice(NoLimit)
	cs13 := constructPointerProbe(NoLimit)
	cs14 := constructPointerProbe(NoLimit)
	cs15 := constructPointerProbe(NoLimit)
	cs16 := constructPointerLifecycle(NoLimit)
	cs17 := constructString(NoLimit)
	cs18 := constructTerminationMessagePolicy(NoLimit)
	cs19 := constructPullPolicy(NoLimit)
	cs20 := constructPointerSecurityContext(NoLimit)
	cs21 := constructBool(NoLimit)
	cs22 := constructBool(NoLimit)
	cs23 := constructBool(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
		len(cs4),
		len(cs5),
		len(cs6),
		len(cs7),
		len(cs8),
		len(cs9),
		len(cs10),
		len(cs11),
		len(cs12),
		len(cs13),
		len(cs14),
		len(cs15),
		len(cs16),
		len(cs17),
		len(cs18),
		len(cs19),
		len(cs20),
		len(cs21),
		len(cs22),
		len(cs23),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	k4 := 0
	k5 := 0
	k6 := 0
	k7 := 0
	k8 := 0
	k9 := 0
	k10 := 0
	k11 := 0
	k12 := 0
	k13 := 0
	k14 := 0
	k15 := 0
	k16 := 0
	k17 := 0
	k18 := 0
	k19 := 0
	k20 := 0
	k21 := 0
	k22 := 0
	k23 := 0
	for i := range maxCount {
		nc := Case[v1.Container]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoNotEqual | NoZero | NoNil)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Name = c0.expected
		nc.dst.Name = c0.dst
		nc.src.Name = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Image = c1.expected
		nc.dst.Image = c1.dst
		nc.src.Image = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructAtomicSliceString(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.Command = c2.expected
		nc.dst.Command = c2.dst
		nc.src.Command = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructAtomicSliceString(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.Args = c3.expected
		nc.dst.Args = c3.dst
		nc.src.Args = c3.src
		if i/len(cs4) > k4 {
			cs4 = constructString(NoLimit)
			k4 += 1
		}
		c4 := &cs4[i%len(cs4)]
		nc.expected.WorkingDir = c4.expected
		nc.dst.WorkingDir = c4.dst
		nc.src.WorkingDir = c4.src
		if i/len(cs5) > k5 {
			cs5 = constructMapSliceContainerPort(NoLimit)
			k5 += 1
		}
		c5 := &cs5[i%len(cs5)]
		nc.expected.Ports = c5.expected
		nc.dst.Ports = c5.dst
		nc.src.Ports = c5.src
		if i/len(cs6) > k6 {
			cs6 = constructAtomicSliceEnvFromSource(NoLimit)
			k6 += 1
		}
		c6 := &cs6[i%len(cs6)]
		nc.expected.EnvFrom = c6.expected
		nc.dst.EnvFrom = c6.dst
		nc.src.EnvFrom = c6.src
		if i/len(cs7) > k7 {
			cs7 = constructMapSliceEnvVar(NoLimit)
			k7 += 1
		}
		c7 := &cs7[i%len(cs7)]
		nc.expected.Env = c7.expected
		nc.dst.Env = c7.dst
		nc.src.Env = c7.src
		if i/len(cs8) > k8 {
			cs8 = constructResourceRequirements(NoLimit)
			k8 += 1
		}
		c8 := &cs8[i%len(cs8)]
		nc.expected.Resources = c8.expected
		nc.dst.Resources = c8.dst
		nc.src.Resources = c8.src
		if i/len(cs9) > k9 {
			cs9 = constructAtomicSliceContainerResizePolicy(NoLimit)
			k9 += 1
		}
		c9 := &cs9[i%len(cs9)]
		nc.expected.ResizePolicy = c9.expected
		nc.dst.ResizePolicy = c9.dst
		nc.src.ResizePolicy = c9.src
		if i/len(cs10) > k10 {
			cs10 = constructPointerContainerRestartPolicy(NoLimit)
			k10 += 1
		}
		c10 := &cs10[i%len(cs10)]
		nc.expected.RestartPolicy = c10.expected
		nc.dst.RestartPolicy = c10.dst
		nc.src.RestartPolicy = c10.src
		if i/len(cs11) > k11 {
			cs11 = constructMapSliceVolumeMount(NoLimit)
			k11 += 1
		}
		c11 := &cs11[i%len(cs11)]
		nc.expected.VolumeMounts = c11.expected
		nc.dst.VolumeMounts = c11.dst
		nc.src.VolumeMounts = c11.src
		if i/len(cs12) > k12 {
			cs12 = constructMapSliceVolumeDevice(NoLimit)
			k12 += 1
		}
		c12 := &cs12[i%len(cs12)]
		nc.expected.VolumeDevices = c12.expected
		nc.dst.VolumeDevices = c12.dst
		nc.src.VolumeDevices = c12.src
		if i/len(cs13) > k13 {
			cs13 = constructPointerProbe(NoLimit)
			k13 += 1
		}
		c13 := &cs13[i%len(cs13)]
		nc.expected.LivenessProbe = c13.expected
		nc.dst.LivenessProbe = c13.dst
		nc.src.LivenessProbe = c13.src
		if i/len(cs14) > k14 {
			cs14 = constructPointerProbe(NoLimit)
			k14 += 1
		}
		c14 := &cs14[i%len(cs14)]
		nc.expected.ReadinessProbe = c14.expected
		nc.dst.ReadinessProbe = c14.dst
		nc.src.ReadinessProbe = c14.src
		if i/len(cs15) > k15 {
			cs15 = constructPointerProbe(NoLimit)
			k15 += 1
		}
		c15 := &cs15[i%len(cs15)]
		nc.expected.StartupProbe = c15.expected
		nc.dst.StartupProbe = c15.dst
		nc.src.StartupProbe = c15.src
		if i/len(cs16) > k16 {
			cs16 = constructPointerLifecycle(NoLimit)
			k16 += 1
		}
		c16 := &cs16[i%len(cs16)]
		nc.expected.Lifecycle = c16.expected
		nc.dst.Lifecycle = c16.dst
		nc.src.Lifecycle = c16.src
		if i/len(cs17) > k17 {
			cs17 = constructString(NoLimit)
			k17 += 1
		}
		c17 := &cs17[i%len(cs17)]
		nc.expected.TerminationMessagePath = c17.expected
		nc.dst.TerminationMessagePath = c17.dst
		nc.src.TerminationMessagePath = c17.src
		if i/len(cs18) > k18 {
			cs18 = constructTerminationMessagePolicy(NoLimit)
			k18 += 1
		}
		c18 := &cs18[i%len(cs18)]
		nc.expected.TerminationMessagePolicy = c18.expected
		nc.dst.TerminationMessagePolicy = c18.dst
		nc.src.TerminationMessagePolicy = c18.src
		if i/len(cs19) > k19 {
			cs19 = constructPullPolicy(NoLimit)
			k19 += 1
		}
		c19 := &cs19[i%len(cs19)]
		nc.expected.ImagePullPolicy = c19.expected
		nc.dst.ImagePullPolicy = c19.dst
		nc.src.ImagePullPolicy = c19.src
		if i/len(cs20) > k20 {
			cs20 = constructPointerSecurityContext(NoLimit)
			k20 += 1
		}
		c20 := &cs20[i%len(cs20)]
		nc.expected.SecurityContext = c20.expected
		nc.dst.SecurityContext = c20.dst
		nc.src.SecurityContext = c20.src
		if i/len(cs21) > k21 {
			cs21 = constructBool(NoLimit)
			k21 += 1
		}
		c21 := &cs21[i%len(cs21)]
		nc.expected.Stdin = c21.expected
		nc.dst.Stdin = c21.dst
		nc.src.Stdin = c21.src
		if i/len(cs22) > k22 {
			cs22 = constructBool(NoLimit)
			k22 += 1
		}
		c22 := &cs22[i%len(cs22)]
		nc.expected.StdinOnce = c22.expected
		nc.dst.StdinOnce = c22.dst
		nc.src.StdinOnce = c22.src
		if i/len(cs23) > k23 {
			cs23 = constructBool(NoLimit)
			k23 += 1
		}
		c23 := &cs23[i%len(cs23)]
		nc.expected.TTY = c23.expected
		nc.dst.TTY = c23.dst
		nc.src.TTY = c23.src
		cases = append(cases, nc)
	}
	return cases
}
func constructMapSliceContainerPort(p Policy) []Case[[]v1.ContainerPort] {
	cases := []Case[[]v1.ContainerPort]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructContainerPortIgnore_containerPort_protocol(NoLimit)
	var nc Case[[]v1.ContainerPort]
	nc = Case[[]v1.ContainerPort]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.expected)
		nc.dst = append(nc.dst, c.dst)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.ContainerPort]{}
	srcs := []v1.ContainerPort{}
	for i, c := range cs {
		switch i % 3 {
		case 0:
			nc.expected = append(nc.expected, c.expected)
			nc.dst = append(nc.dst, c.dst)
			nc.src = append(nc.src, c.src)
		case 1:
			nc.expected = append(nc.expected, c.dst)
			nc.dst = append(nc.dst, c.dst)
		case 2:
			srcs = append(srcs, c.src)
			nc.src = append(nc.src, c.src)
		}
	}
	nc.expected = append(nc.expected, srcs...)
	cases = append(cases, nc)
	nc = Case[[]v1.ContainerPort]{}
	srcs = []v1.ContainerPort{}
	for i, c := range cs {
		switch i % 2 {
		case 0:
			nc.expected = append(nc.expected, c.dst)
			nc.dst = append(nc.dst, c.dst)
		case 1:
			srcs = append(srcs, c.src)
			nc.src = append(nc.src, c.src)
		}
	}
	nc.expected = append(nc.expected, srcs...)
	cases = append(cases, nc)
	nc = Case[[]v1.ContainerPort]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.src)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.ContainerPort]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.dst)
		nc.dst = append(nc.dst, c.dst)
	}
	cases = append(cases, nc)
	return cases
}
func constructContainerPortIgnore_containerPort_protocol(p Policy) []Case[v1.ContainerPort] {
	cases := []Case[v1.ContainerPort]{}
	cs0 := constructString(NoLimit)
	cs1 := constructInt32(NoLimit)
	cs2 := constructInt32(NoNotEqual | NoZero | NoNil)
	cs3 := constructProtocol(NoNotEqual | NoZero | NoNil)
	cs4 := constructString(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
		len(cs4),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	k4 := 0
	for i := range maxCount {
		nc := Case[v1.ContainerPort]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Name = c0.expected
		nc.dst.Name = c0.dst
		nc.src.Name = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructInt32(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.HostPort = c1.expected
		nc.dst.HostPort = c1.dst
		nc.src.HostPort = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructInt32(NoNotEqual | NoZero | NoNil)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.ContainerPort = c2.expected
		nc.dst.ContainerPort = c2.dst
		nc.src.ContainerPort = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructProtocol(NoNotEqual | NoZero | NoNil)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.Protocol = c3.expected
		nc.dst.Protocol = c3.dst
		nc.src.Protocol = c3.src
		if i/len(cs4) > k4 {
			cs4 = constructString(NoLimit)
			k4 += 1
		}
		c4 := &cs4[i%len(cs4)]
		nc.expected.HostIP = c4.expected
		nc.dst.HostIP = c4.dst
		nc.src.HostIP = c4.src
		cases = append(cases, nc)
	}
	return cases
}
func constructProtocol(p Policy) []Case[v1.Protocol] {
	cases := []Case[v1.Protocol]{}
	cs := constructString(p)
	for _, c := range cs {
		cases = append(cases, Case[v1.Protocol]{
			expected: v1.Protocol(c.expected),
			dst:      v1.Protocol(c.dst),
			src:      v1.Protocol(c.src),
		})
	}
	return cases
}
func constructAtomicSliceEnvFromSource(p Policy) []Case[[]v1.EnvFromSource] {
	cases := []Case[[]v1.EnvFromSource]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructEnvFromSource(NoLimit)
	var nc Case[[]v1.EnvFromSource]
	nc = Case[[]v1.EnvFromSource]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.src)
		nc.dst = append(nc.dst, c.dst)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.EnvFromSource]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.dst)
		nc.dst = append(nc.dst, c.dst)
	}
	nc.src = []v1.EnvFromSource{}
	cases = append(cases, nc)
	return cases
}
func constructEnvFromSource(p Policy) []Case[v1.EnvFromSource] {
	cases := []Case[v1.EnvFromSource]{}
	cs0 := constructString(NoLimit)
	cs1 := constructPointerConfigMapEnvSource(NoLimit)
	cs2 := constructPointerSecretEnvSource(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	for i := range maxCount {
		nc := Case[v1.EnvFromSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Prefix = c0.expected
		nc.dst.Prefix = c0.dst
		nc.src.Prefix = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructPointerConfigMapEnvSource(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.ConfigMapRef = c1.expected
		nc.dst.ConfigMapRef = c1.dst
		nc.src.ConfigMapRef = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructPointerSecretEnvSource(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.SecretRef = c2.expected
		nc.dst.SecretRef = c2.dst
		nc.src.SecretRef = c2.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerConfigMapEnvSource(p Policy) []Case[*v1.ConfigMapEnvSource] {
	cases := []Case[*v1.ConfigMapEnvSource]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructConfigMapEnvSource(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.ConfigMapEnvSource]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructConfigMapEnvSource(p Policy) []Case[v1.ConfigMapEnvSource] {
	cases := []Case[v1.ConfigMapEnvSource]{}
	cs0 := constructAtomicLocalObjectReference(NoLimit)
	cs1 := constructPointerBool(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[v1.ConfigMapEnvSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructAtomicLocalObjectReference(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.LocalObjectReference = c0.expected
		nc.dst.LocalObjectReference = c0.dst
		nc.src.LocalObjectReference = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructPointerBool(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Optional = c1.expected
		nc.dst.Optional = c1.dst
		nc.src.Optional = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerSecretEnvSource(p Policy) []Case[*v1.SecretEnvSource] {
	cases := []Case[*v1.SecretEnvSource]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructSecretEnvSource(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.SecretEnvSource]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructSecretEnvSource(p Policy) []Case[v1.SecretEnvSource] {
	cases := []Case[v1.SecretEnvSource]{}
	cs0 := constructAtomicLocalObjectReference(NoLimit)
	cs1 := constructPointerBool(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[v1.SecretEnvSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructAtomicLocalObjectReference(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.LocalObjectReference = c0.expected
		nc.dst.LocalObjectReference = c0.dst
		nc.src.LocalObjectReference = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructPointerBool(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Optional = c1.expected
		nc.dst.Optional = c1.dst
		nc.src.Optional = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructMapSliceEnvVar(p Policy) []Case[[]v1.EnvVar] {
	cases := []Case[[]v1.EnvVar]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructEnvVarIgnore_name(NoLimit)
	var nc Case[[]v1.EnvVar]
	nc = Case[[]v1.EnvVar]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.expected)
		nc.dst = append(nc.dst, c.dst)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.EnvVar]{}
	srcs := []v1.EnvVar{}
	for i, c := range cs {
		switch i % 3 {
		case 0:
			nc.expected = append(nc.expected, c.expected)
			nc.dst = append(nc.dst, c.dst)
			nc.src = append(nc.src, c.src)
		case 1:
			nc.expected = append(nc.expected, c.dst)
			nc.dst = append(nc.dst, c.dst)
		case 2:
			srcs = append(srcs, c.src)
			nc.src = append(nc.src, c.src)
		}
	}
	nc.expected = append(nc.expected, srcs...)
	cases = append(cases, nc)
	nc = Case[[]v1.EnvVar]{}
	srcs = []v1.EnvVar{}
	for i, c := range cs {
		switch i % 2 {
		case 0:
			nc.expected = append(nc.expected, c.dst)
			nc.dst = append(nc.dst, c.dst)
		case 1:
			srcs = append(srcs, c.src)
			nc.src = append(nc.src, c.src)
		}
	}
	nc.expected = append(nc.expected, srcs...)
	cases = append(cases, nc)
	nc = Case[[]v1.EnvVar]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.src)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.EnvVar]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.dst)
		nc.dst = append(nc.dst, c.dst)
	}
	cases = append(cases, nc)
	return cases
}
func constructEnvVarIgnore_name(p Policy) []Case[v1.EnvVar] {
	cases := []Case[v1.EnvVar]{}
	cs0 := constructString(NoNotEqual | NoZero | NoNil)
	cs1 := constructString(NoLimit)
	cs2 := constructPointerEnvVarSource(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	for i := range maxCount {
		nc := Case[v1.EnvVar]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoNotEqual | NoZero | NoNil)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Name = c0.expected
		nc.dst.Name = c0.dst
		nc.src.Name = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Value = c1.expected
		nc.dst.Value = c1.dst
		nc.src.Value = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructPointerEnvVarSource(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.ValueFrom = c2.expected
		nc.dst.ValueFrom = c2.dst
		nc.src.ValueFrom = c2.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerEnvVarSource(p Policy) []Case[*v1.EnvVarSource] {
	cases := []Case[*v1.EnvVarSource]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructEnvVarSource(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.EnvVarSource]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructEnvVarSource(p Policy) []Case[v1.EnvVarSource] {
	cases := []Case[v1.EnvVarSource]{}
	cs0 := constructAtomicPointerObjectFieldSelector(NoLimit)
	cs1 := constructAtomicPointerResourceFieldSelector(NoLimit)
	cs2 := constructAtomicPointerConfigMapKeySelector(NoLimit)
	cs3 := constructAtomicPointerSecretKeySelector(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	for i := range maxCount {
		nc := Case[v1.EnvVarSource]{}
		if i/len(cs0) > k0 {
			cs0 = constructAtomicPointerObjectFieldSelector(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.FieldRef = c0.expected
		nc.dst.FieldRef = c0.dst
		nc.src.FieldRef = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructAtomicPointerResourceFieldSelector(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.ResourceFieldRef = c1.expected
		nc.dst.ResourceFieldRef = c1.dst
		nc.src.ResourceFieldRef = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructAtomicPointerConfigMapKeySelector(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.ConfigMapKeyRef = c2.expected
		nc.dst.ConfigMapKeyRef = c2.dst
		nc.src.ConfigMapKeyRef = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructAtomicPointerSecretKeySelector(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.SecretKeyRef = c3.expected
		nc.dst.SecretKeyRef = c3.dst
		nc.src.SecretKeyRef = c3.src
		cases = append(cases, nc)
	}
	return cases
}
func constructAtomicPointerConfigMapKeySelector(p Policy) []Case[*v1.ConfigMapKeySelector] {
	cases := []Case[*v1.ConfigMapKeySelector]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructAtomicConfigMapKeySelector(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.ConfigMapKeySelector]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructAtomicConfigMapKeySelector(p Policy) []Case[v1.ConfigMapKeySelector] {
	cases := []Case[v1.ConfigMapKeySelector]{}
	cs0 := constructAtomicLocalObjectReference(NoLimit)
	cs1 := constructString(NoLimit)
	cs2 := constructPointerBool(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	for i := range maxCount {
		nc := Case[v1.ConfigMapKeySelector]{}
		if i/len(cs0) > k0 {
			cs0 = constructAtomicLocalObjectReference(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.LocalObjectReference = c0.src
		nc.dst.LocalObjectReference = c0.dst
		nc.src.LocalObjectReference = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Key = c1.src
		nc.dst.Key = c1.dst
		nc.src.Key = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructPointerBool(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.Optional = c2.src
		nc.dst.Optional = c2.dst
		nc.src.Optional = c2.src
		cases = append(cases, nc)
	}
	return cases
}
func constructAtomicPointerSecretKeySelector(p Policy) []Case[*v1.SecretKeySelector] {
	cases := []Case[*v1.SecretKeySelector]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructAtomicSecretKeySelector(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.SecretKeySelector]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructAtomicSecretKeySelector(p Policy) []Case[v1.SecretKeySelector] {
	cases := []Case[v1.SecretKeySelector]{}
	cs0 := constructAtomicLocalObjectReference(NoLimit)
	cs1 := constructString(NoLimit)
	cs2 := constructPointerBool(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	for i := range maxCount {
		nc := Case[v1.SecretKeySelector]{}
		if i/len(cs0) > k0 {
			cs0 = constructAtomicLocalObjectReference(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.LocalObjectReference = c0.src
		nc.dst.LocalObjectReference = c0.dst
		nc.src.LocalObjectReference = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Key = c1.src
		nc.dst.Key = c1.dst
		nc.src.Key = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructPointerBool(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.Optional = c2.src
		nc.dst.Optional = c2.dst
		nc.src.Optional = c2.src
		cases = append(cases, nc)
	}
	return cases
}
func constructResourceRequirements(p Policy) []Case[v1.ResourceRequirements] {
	cases := []Case[v1.ResourceRequirements]{}
	cs0 := constructResourceList(NoLimit)
	cs1 := constructResourceList(NoLimit)
	cs2 := constructMapSliceResourceClaim(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	for i := range maxCount {
		nc := Case[v1.ResourceRequirements]{}
		if i/len(cs0) > k0 {
			cs0 = constructResourceList(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Limits = c0.expected
		nc.dst.Limits = c0.dst
		nc.src.Limits = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructResourceList(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Requests = c1.expected
		nc.dst.Requests = c1.dst
		nc.src.Requests = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructMapSliceResourceClaim(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.Claims = c2.expected
		nc.dst.Claims = c2.dst
		nc.src.Claims = c2.src
		cases = append(cases, nc)
	}
	return cases
}
func constructMapSliceResourceClaim(p Policy) []Case[[]v1.ResourceClaim] {
	cases := []Case[[]v1.ResourceClaim]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructResourceClaimIgnore_name(NoLimit)
	var nc Case[[]v1.ResourceClaim]
	nc = Case[[]v1.ResourceClaim]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.expected)
		nc.dst = append(nc.dst, c.dst)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.ResourceClaim]{}
	srcs := []v1.ResourceClaim{}
	for i, c := range cs {
		switch i % 3 {
		case 0:
			nc.expected = append(nc.expected, c.expected)
			nc.dst = append(nc.dst, c.dst)
			nc.src = append(nc.src, c.src)
		case 1:
			nc.expected = append(nc.expected, c.dst)
			nc.dst = append(nc.dst, c.dst)
		case 2:
			srcs = append(srcs, c.src)
			nc.src = append(nc.src, c.src)
		}
	}
	nc.expected = append(nc.expected, srcs...)
	cases = append(cases, nc)
	nc = Case[[]v1.ResourceClaim]{}
	srcs = []v1.ResourceClaim{}
	for i, c := range cs {
		switch i % 2 {
		case 0:
			nc.expected = append(nc.expected, c.dst)
			nc.dst = append(nc.dst, c.dst)
		case 1:
			srcs = append(srcs, c.src)
			nc.src = append(nc.src, c.src)
		}
	}
	nc.expected = append(nc.expected, srcs...)
	cases = append(cases, nc)
	nc = Case[[]v1.ResourceClaim]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.src)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.ResourceClaim]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.dst)
		nc.dst = append(nc.dst, c.dst)
	}
	cases = append(cases, nc)
	return cases
}
func constructResourceClaimIgnore_name(p Policy) []Case[v1.ResourceClaim] {
	cases := []Case[v1.ResourceClaim]{}
	cs0 := constructString(NoNotEqual | NoZero | NoNil)
	cs1 := constructString(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[v1.ResourceClaim]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoNotEqual | NoZero | NoNil)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Name = c0.expected
		nc.dst.Name = c0.dst
		nc.src.Name = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Request = c1.expected
		nc.dst.Request = c1.dst
		nc.src.Request = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructAtomicSliceContainerResizePolicy(p Policy) []Case[[]v1.ContainerResizePolicy] {
	cases := []Case[[]v1.ContainerResizePolicy]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructContainerResizePolicy(NoLimit)
	var nc Case[[]v1.ContainerResizePolicy]
	nc = Case[[]v1.ContainerResizePolicy]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.src)
		nc.dst = append(nc.dst, c.dst)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.ContainerResizePolicy]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.dst)
		nc.dst = append(nc.dst, c.dst)
	}
	nc.src = []v1.ContainerResizePolicy{}
	cases = append(cases, nc)
	return cases
}
func constructContainerResizePolicy(p Policy) []Case[v1.ContainerResizePolicy] {
	cases := []Case[v1.ContainerResizePolicy]{}
	cs0 := constructResourceName(NoLimit)
	cs1 := constructResourceResizeRestartPolicy(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[v1.ContainerResizePolicy]{}
		if i/len(cs0) > k0 {
			cs0 = constructResourceName(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.ResourceName = c0.expected
		nc.dst.ResourceName = c0.dst
		nc.src.ResourceName = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructResourceResizeRestartPolicy(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.RestartPolicy = c1.expected
		nc.dst.RestartPolicy = c1.dst
		nc.src.RestartPolicy = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructResourceName(p Policy) []Case[v1.ResourceName] {
	cases := []Case[v1.ResourceName]{}
	cs := constructString(p)
	for _, c := range cs {
		cases = append(cases, Case[v1.ResourceName]{
			expected: v1.ResourceName(c.expected),
			dst:      v1.ResourceName(c.dst),
			src:      v1.ResourceName(c.src),
		})
	}
	return cases
}
func constructResourceResizeRestartPolicy(p Policy) []Case[v1.ResourceResizeRestartPolicy] {
	cases := []Case[v1.ResourceResizeRestartPolicy]{}
	cs := constructString(p)
	for _, c := range cs {
		cases = append(cases, Case[v1.ResourceResizeRestartPolicy]{
			expected: v1.ResourceResizeRestartPolicy(c.expected),
			dst:      v1.ResourceResizeRestartPolicy(c.dst),
			src:      v1.ResourceResizeRestartPolicy(c.src),
		})
	}
	return cases
}
func constructPointerContainerRestartPolicy(p Policy) []Case[*v1.ContainerRestartPolicy] {
	cases := []Case[*v1.ContainerRestartPolicy]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructContainerRestartPolicy(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.ContainerRestartPolicy]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructContainerRestartPolicy(p Policy) []Case[v1.ContainerRestartPolicy] {
	cases := []Case[v1.ContainerRestartPolicy]{}
	cs := constructString(p)
	for _, c := range cs {
		cases = append(cases, Case[v1.ContainerRestartPolicy]{
			expected: v1.ContainerRestartPolicy(c.expected),
			dst:      v1.ContainerRestartPolicy(c.dst),
			src:      v1.ContainerRestartPolicy(c.src),
		})
	}
	return cases
}
func constructMapSliceVolumeMount(p Policy) []Case[[]v1.VolumeMount] {
	cases := []Case[[]v1.VolumeMount]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructVolumeMountIgnore_mountPath(NoLimit)
	var nc Case[[]v1.VolumeMount]
	nc = Case[[]v1.VolumeMount]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.expected)
		nc.dst = append(nc.dst, c.dst)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.VolumeMount]{}
	srcs := []v1.VolumeMount{}
	for i, c := range cs {
		switch i % 3 {
		case 0:
			nc.expected = append(nc.expected, c.expected)
			nc.dst = append(nc.dst, c.dst)
			nc.src = append(nc.src, c.src)
		case 1:
			nc.expected = append(nc.expected, c.dst)
			nc.dst = append(nc.dst, c.dst)
		case 2:
			srcs = append(srcs, c.src)
			nc.src = append(nc.src, c.src)
		}
	}
	nc.expected = append(nc.expected, srcs...)
	cases = append(cases, nc)
	nc = Case[[]v1.VolumeMount]{}
	srcs = []v1.VolumeMount{}
	for i, c := range cs {
		switch i % 2 {
		case 0:
			nc.expected = append(nc.expected, c.dst)
			nc.dst = append(nc.dst, c.dst)
		case 1:
			srcs = append(srcs, c.src)
			nc.src = append(nc.src, c.src)
		}
	}
	nc.expected = append(nc.expected, srcs...)
	cases = append(cases, nc)
	nc = Case[[]v1.VolumeMount]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.src)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.VolumeMount]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.dst)
		nc.dst = append(nc.dst, c.dst)
	}
	cases = append(cases, nc)
	return cases
}
func constructVolumeMountIgnore_mountPath(p Policy) []Case[v1.VolumeMount] {
	cases := []Case[v1.VolumeMount]{}
	cs0 := constructString(NoLimit)
	cs1 := constructBool(NoLimit)
	cs2 := constructPointerRecursiveReadOnlyMode(NoLimit)
	cs3 := constructString(NoNotEqual | NoZero | NoNil)
	cs4 := constructString(NoLimit)
	cs5 := constructPointerMountPropagationMode(NoLimit)
	cs6 := constructString(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
		len(cs4),
		len(cs5),
		len(cs6),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	k4 := 0
	k5 := 0
	k6 := 0
	for i := range maxCount {
		nc := Case[v1.VolumeMount]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Name = c0.expected
		nc.dst.Name = c0.dst
		nc.src.Name = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructBool(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.ReadOnly = c1.expected
		nc.dst.ReadOnly = c1.dst
		nc.src.ReadOnly = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructPointerRecursiveReadOnlyMode(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.RecursiveReadOnly = c2.expected
		nc.dst.RecursiveReadOnly = c2.dst
		nc.src.RecursiveReadOnly = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructString(NoNotEqual | NoZero | NoNil)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.MountPath = c3.expected
		nc.dst.MountPath = c3.dst
		nc.src.MountPath = c3.src
		if i/len(cs4) > k4 {
			cs4 = constructString(NoLimit)
			k4 += 1
		}
		c4 := &cs4[i%len(cs4)]
		nc.expected.SubPath = c4.expected
		nc.dst.SubPath = c4.dst
		nc.src.SubPath = c4.src
		if i/len(cs5) > k5 {
			cs5 = constructPointerMountPropagationMode(NoLimit)
			k5 += 1
		}
		c5 := &cs5[i%len(cs5)]
		nc.expected.MountPropagation = c5.expected
		nc.dst.MountPropagation = c5.dst
		nc.src.MountPropagation = c5.src
		if i/len(cs6) > k6 {
			cs6 = constructString(NoLimit)
			k6 += 1
		}
		c6 := &cs6[i%len(cs6)]
		nc.expected.SubPathExpr = c6.expected
		nc.dst.SubPathExpr = c6.dst
		nc.src.SubPathExpr = c6.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerRecursiveReadOnlyMode(p Policy) []Case[*v1.RecursiveReadOnlyMode] {
	cases := []Case[*v1.RecursiveReadOnlyMode]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructRecursiveReadOnlyMode(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.RecursiveReadOnlyMode]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructRecursiveReadOnlyMode(p Policy) []Case[v1.RecursiveReadOnlyMode] {
	cases := []Case[v1.RecursiveReadOnlyMode]{}
	cs := constructString(p)
	for _, c := range cs {
		cases = append(cases, Case[v1.RecursiveReadOnlyMode]{
			expected: v1.RecursiveReadOnlyMode(c.expected),
			dst:      v1.RecursiveReadOnlyMode(c.dst),
			src:      v1.RecursiveReadOnlyMode(c.src),
		})
	}
	return cases
}
func constructPointerMountPropagationMode(p Policy) []Case[*v1.MountPropagationMode] {
	cases := []Case[*v1.MountPropagationMode]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructMountPropagationMode(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.MountPropagationMode]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructMountPropagationMode(p Policy) []Case[v1.MountPropagationMode] {
	cases := []Case[v1.MountPropagationMode]{}
	cs := constructString(p)
	for _, c := range cs {
		cases = append(cases, Case[v1.MountPropagationMode]{
			expected: v1.MountPropagationMode(c.expected),
			dst:      v1.MountPropagationMode(c.dst),
			src:      v1.MountPropagationMode(c.src),
		})
	}
	return cases
}
func constructMapSliceVolumeDevice(p Policy) []Case[[]v1.VolumeDevice] {
	cases := []Case[[]v1.VolumeDevice]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructVolumeDeviceIgnore_devicePath(NoLimit)
	var nc Case[[]v1.VolumeDevice]
	nc = Case[[]v1.VolumeDevice]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.expected)
		nc.dst = append(nc.dst, c.dst)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.VolumeDevice]{}
	srcs := []v1.VolumeDevice{}
	for i, c := range cs {
		switch i % 3 {
		case 0:
			nc.expected = append(nc.expected, c.expected)
			nc.dst = append(nc.dst, c.dst)
			nc.src = append(nc.src, c.src)
		case 1:
			nc.expected = append(nc.expected, c.dst)
			nc.dst = append(nc.dst, c.dst)
		case 2:
			srcs = append(srcs, c.src)
			nc.src = append(nc.src, c.src)
		}
	}
	nc.expected = append(nc.expected, srcs...)
	cases = append(cases, nc)
	nc = Case[[]v1.VolumeDevice]{}
	srcs = []v1.VolumeDevice{}
	for i, c := range cs {
		switch i % 2 {
		case 0:
			nc.expected = append(nc.expected, c.dst)
			nc.dst = append(nc.dst, c.dst)
		case 1:
			srcs = append(srcs, c.src)
			nc.src = append(nc.src, c.src)
		}
	}
	nc.expected = append(nc.expected, srcs...)
	cases = append(cases, nc)
	nc = Case[[]v1.VolumeDevice]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.src)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.VolumeDevice]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.dst)
		nc.dst = append(nc.dst, c.dst)
	}
	cases = append(cases, nc)
	return cases
}
func constructVolumeDeviceIgnore_devicePath(p Policy) []Case[v1.VolumeDevice] {
	cases := []Case[v1.VolumeDevice]{}
	cs0 := constructString(NoLimit)
	cs1 := constructString(NoNotEqual | NoZero | NoNil)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[v1.VolumeDevice]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Name = c0.expected
		nc.dst.Name = c0.dst
		nc.src.Name = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoNotEqual | NoZero | NoNil)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.DevicePath = c1.expected
		nc.dst.DevicePath = c1.dst
		nc.src.DevicePath = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerProbe(p Policy) []Case[*v1.Probe] {
	cases := []Case[*v1.Probe]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructProbe(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.Probe]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructProbe(p Policy) []Case[v1.Probe] {
	cases := []Case[v1.Probe]{}
	cs0 := constructProbeHandler(NoLimit)
	cs1 := constructInt32(NoLimit)
	cs2 := constructInt32(NoLimit)
	cs3 := constructInt32(NoLimit)
	cs4 := constructInt32(NoLimit)
	cs5 := constructInt32(NoLimit)
	cs6 := constructPointerInt64(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
		len(cs4),
		len(cs5),
		len(cs6),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	k4 := 0
	k5 := 0
	k6 := 0
	for i := range maxCount {
		nc := Case[v1.Probe]{}
		if i/len(cs0) > k0 {
			cs0 = constructProbeHandler(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.ProbeHandler = c0.expected
		nc.dst.ProbeHandler = c0.dst
		nc.src.ProbeHandler = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructInt32(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.InitialDelaySeconds = c1.expected
		nc.dst.InitialDelaySeconds = c1.dst
		nc.src.InitialDelaySeconds = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructInt32(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.TimeoutSeconds = c2.expected
		nc.dst.TimeoutSeconds = c2.dst
		nc.src.TimeoutSeconds = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructInt32(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.PeriodSeconds = c3.expected
		nc.dst.PeriodSeconds = c3.dst
		nc.src.PeriodSeconds = c3.src
		if i/len(cs4) > k4 {
			cs4 = constructInt32(NoLimit)
			k4 += 1
		}
		c4 := &cs4[i%len(cs4)]
		nc.expected.SuccessThreshold = c4.expected
		nc.dst.SuccessThreshold = c4.dst
		nc.src.SuccessThreshold = c4.src
		if i/len(cs5) > k5 {
			cs5 = constructInt32(NoLimit)
			k5 += 1
		}
		c5 := &cs5[i%len(cs5)]
		nc.expected.FailureThreshold = c5.expected
		nc.dst.FailureThreshold = c5.dst
		nc.src.FailureThreshold = c5.src
		if i/len(cs6) > k6 {
			cs6 = constructPointerInt64(NoLimit)
			k6 += 1
		}
		c6 := &cs6[i%len(cs6)]
		nc.expected.TerminationGracePeriodSeconds = c6.expected
		nc.dst.TerminationGracePeriodSeconds = c6.dst
		nc.src.TerminationGracePeriodSeconds = c6.src
		cases = append(cases, nc)
	}
	return cases
}
func constructProbeHandler(p Policy) []Case[v1.ProbeHandler] {
	cases := []Case[v1.ProbeHandler]{}
	cs0 := constructPointerExecAction(NoLimit)
	cs1 := constructPointerHTTPGetAction(NoLimit)
	cs2 := constructPointerTCPSocketAction(NoLimit)
	cs3 := constructPointerGRPCAction(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	for i := range maxCount {
		nc := Case[v1.ProbeHandler]{}
		if i/len(cs0) > k0 {
			cs0 = constructPointerExecAction(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Exec = c0.expected
		nc.dst.Exec = c0.dst
		nc.src.Exec = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructPointerHTTPGetAction(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.HTTPGet = c1.expected
		nc.dst.HTTPGet = c1.dst
		nc.src.HTTPGet = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructPointerTCPSocketAction(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.TCPSocket = c2.expected
		nc.dst.TCPSocket = c2.dst
		nc.src.TCPSocket = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructPointerGRPCAction(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.GRPC = c3.expected
		nc.dst.GRPC = c3.dst
		nc.src.GRPC = c3.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerExecAction(p Policy) []Case[*v1.ExecAction] {
	cases := []Case[*v1.ExecAction]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructExecAction(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.ExecAction]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructExecAction(p Policy) []Case[v1.ExecAction] {
	cases := []Case[v1.ExecAction]{}
	cs0 := constructAtomicSliceString(NoLimit)
	maxCount := max(
		len(cs0),
	)
	k0 := 0
	for i := range maxCount {
		nc := Case[v1.ExecAction]{}
		if i/len(cs0) > k0 {
			cs0 = constructAtomicSliceString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Command = c0.expected
		nc.dst.Command = c0.dst
		nc.src.Command = c0.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerHTTPGetAction(p Policy) []Case[*v1.HTTPGetAction] {
	cases := []Case[*v1.HTTPGetAction]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructHTTPGetAction(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.HTTPGetAction]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructHTTPGetAction(p Policy) []Case[v1.HTTPGetAction] {
	cases := []Case[v1.HTTPGetAction]{}
	cs0 := constructString(NoLimit)
	cs1 := constructIntOrString(NoLimit)
	cs2 := constructString(NoLimit)
	cs3 := constructURIScheme(NoLimit)
	cs4 := constructAtomicSliceHTTPHeader(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
		len(cs4),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	k4 := 0
	for i := range maxCount {
		nc := Case[v1.HTTPGetAction]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Path = c0.expected
		nc.dst.Path = c0.dst
		nc.src.Path = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructIntOrString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Port = c1.expected
		nc.dst.Port = c1.dst
		nc.src.Port = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructString(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.Host = c2.expected
		nc.dst.Host = c2.dst
		nc.src.Host = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructURIScheme(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.Scheme = c3.expected
		nc.dst.Scheme = c3.dst
		nc.src.Scheme = c3.src
		if i/len(cs4) > k4 {
			cs4 = constructAtomicSliceHTTPHeader(NoLimit)
			k4 += 1
		}
		c4 := &cs4[i%len(cs4)]
		nc.expected.HTTPHeaders = c4.expected
		nc.dst.HTTPHeaders = c4.dst
		nc.src.HTTPHeaders = c4.src
		cases = append(cases, nc)
	}
	return cases
}
func constructIntOrString(p Policy) []Case[intstr.IntOrString] {
	cases := []Case[intstr.IntOrString]{}
	cs0 := constructType(NoLimit)
	cs1 := constructInt32(NoLimit)
	cs2 := constructString(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	for i := range maxCount {
		nc := Case[intstr.IntOrString]{}
		if i/len(cs0) > k0 {
			cs0 = constructType(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Type = c0.expected
		nc.dst.Type = c0.dst
		nc.src.Type = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructInt32(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.IntVal = c1.expected
		nc.dst.IntVal = c1.dst
		nc.src.IntVal = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructString(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.StrVal = c2.expected
		nc.dst.StrVal = c2.dst
		nc.src.StrVal = c2.src
		cases = append(cases, nc)
	}
	return cases
}
func constructType(p Policy) []Case[intstr.Type] {
	cases := []Case[intstr.Type]{}
	cs := constructInt64(p)
	for _, c := range cs {
		cases = append(cases, Case[intstr.Type]{
			expected: intstr.Type(c.expected),
			dst:      intstr.Type(c.dst),
			src:      intstr.Type(c.src),
		})
	}
	return cases
}
func constructURIScheme(p Policy) []Case[v1.URIScheme] {
	cases := []Case[v1.URIScheme]{}
	cs := constructString(p)
	for _, c := range cs {
		cases = append(cases, Case[v1.URIScheme]{
			expected: v1.URIScheme(c.expected),
			dst:      v1.URIScheme(c.dst),
			src:      v1.URIScheme(c.src),
		})
	}
	return cases
}
func constructAtomicSliceHTTPHeader(p Policy) []Case[[]v1.HTTPHeader] {
	cases := []Case[[]v1.HTTPHeader]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructHTTPHeader(NoLimit)
	var nc Case[[]v1.HTTPHeader]
	nc = Case[[]v1.HTTPHeader]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.src)
		nc.dst = append(nc.dst, c.dst)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.HTTPHeader]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.dst)
		nc.dst = append(nc.dst, c.dst)
	}
	nc.src = []v1.HTTPHeader{}
	cases = append(cases, nc)
	return cases
}
func constructHTTPHeader(p Policy) []Case[v1.HTTPHeader] {
	cases := []Case[v1.HTTPHeader]{}
	cs0 := constructString(NoLimit)
	cs1 := constructString(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[v1.HTTPHeader]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Name = c0.expected
		nc.dst.Name = c0.dst
		nc.src.Name = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Value = c1.expected
		nc.dst.Value = c1.dst
		nc.src.Value = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerTCPSocketAction(p Policy) []Case[*v1.TCPSocketAction] {
	cases := []Case[*v1.TCPSocketAction]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructTCPSocketAction(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.TCPSocketAction]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructTCPSocketAction(p Policy) []Case[v1.TCPSocketAction] {
	cases := []Case[v1.TCPSocketAction]{}
	cs0 := constructIntOrString(NoLimit)
	cs1 := constructString(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[v1.TCPSocketAction]{}
		if i/len(cs0) > k0 {
			cs0 = constructIntOrString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Port = c0.expected
		nc.dst.Port = c0.dst
		nc.src.Port = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Host = c1.expected
		nc.dst.Host = c1.dst
		nc.src.Host = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerGRPCAction(p Policy) []Case[*v1.GRPCAction] {
	cases := []Case[*v1.GRPCAction]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructGRPCAction(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.GRPCAction]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructGRPCAction(p Policy) []Case[v1.GRPCAction] {
	cases := []Case[v1.GRPCAction]{}
	cs0 := constructInt32(NoLimit)
	cs1 := constructPointerString(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[v1.GRPCAction]{}
		if i/len(cs0) > k0 {
			cs0 = constructInt32(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Port = c0.expected
		nc.dst.Port = c0.dst
		nc.src.Port = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructPointerString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Service = c1.expected
		nc.dst.Service = c1.dst
		nc.src.Service = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerLifecycle(p Policy) []Case[*v1.Lifecycle] {
	cases := []Case[*v1.Lifecycle]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructLifecycle(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.Lifecycle]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructLifecycle(p Policy) []Case[v1.Lifecycle] {
	cases := []Case[v1.Lifecycle]{}
	cs0 := constructPointerLifecycleHandler(NoLimit)
	cs1 := constructPointerLifecycleHandler(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[v1.Lifecycle]{}
		if i/len(cs0) > k0 {
			cs0 = constructPointerLifecycleHandler(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.PostStart = c0.expected
		nc.dst.PostStart = c0.dst
		nc.src.PostStart = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructPointerLifecycleHandler(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.PreStop = c1.expected
		nc.dst.PreStop = c1.dst
		nc.src.PreStop = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerLifecycleHandler(p Policy) []Case[*v1.LifecycleHandler] {
	cases := []Case[*v1.LifecycleHandler]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructLifecycleHandler(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.LifecycleHandler]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructLifecycleHandler(p Policy) []Case[v1.LifecycleHandler] {
	cases := []Case[v1.LifecycleHandler]{}
	cs0 := constructPointerExecAction(NoLimit)
	cs1 := constructPointerHTTPGetAction(NoLimit)
	cs2 := constructPointerTCPSocketAction(NoLimit)
	cs3 := constructPointerSleepAction(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	for i := range maxCount {
		nc := Case[v1.LifecycleHandler]{}
		if i/len(cs0) > k0 {
			cs0 = constructPointerExecAction(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Exec = c0.expected
		nc.dst.Exec = c0.dst
		nc.src.Exec = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructPointerHTTPGetAction(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.HTTPGet = c1.expected
		nc.dst.HTTPGet = c1.dst
		nc.src.HTTPGet = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructPointerTCPSocketAction(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.TCPSocket = c2.expected
		nc.dst.TCPSocket = c2.dst
		nc.src.TCPSocket = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructPointerSleepAction(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.Sleep = c3.expected
		nc.dst.Sleep = c3.dst
		nc.src.Sleep = c3.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerSleepAction(p Policy) []Case[*v1.SleepAction] {
	cases := []Case[*v1.SleepAction]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructSleepAction(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.SleepAction]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructSleepAction(p Policy) []Case[v1.SleepAction] {
	cases := []Case[v1.SleepAction]{}
	cs0 := constructInt64(NoLimit)
	maxCount := max(
		len(cs0),
	)
	k0 := 0
	for i := range maxCount {
		nc := Case[v1.SleepAction]{}
		if i/len(cs0) > k0 {
			cs0 = constructInt64(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Seconds = c0.expected
		nc.dst.Seconds = c0.dst
		nc.src.Seconds = c0.src
		cases = append(cases, nc)
	}
	return cases
}
func constructTerminationMessagePolicy(p Policy) []Case[v1.TerminationMessagePolicy] {
	cases := []Case[v1.TerminationMessagePolicy]{}
	cs := constructString(p)
	for _, c := range cs {
		cases = append(cases, Case[v1.TerminationMessagePolicy]{
			expected: v1.TerminationMessagePolicy(c.expected),
			dst:      v1.TerminationMessagePolicy(c.dst),
			src:      v1.TerminationMessagePolicy(c.src),
		})
	}
	return cases
}
func constructPointerSecurityContext(p Policy) []Case[*v1.SecurityContext] {
	cases := []Case[*v1.SecurityContext]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructSecurityContext(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.SecurityContext]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructSecurityContext(p Policy) []Case[v1.SecurityContext] {
	cases := []Case[v1.SecurityContext]{}
	cs0 := constructPointerCapabilities(NoLimit)
	cs1 := constructPointerBool(NoLimit)
	cs2 := constructPointerSELinuxOptions(NoLimit)
	cs3 := constructPointerWindowsSecurityContextOptions(NoLimit)
	cs4 := constructPointerInt64(NoLimit)
	cs5 := constructPointerInt64(NoLimit)
	cs6 := constructPointerBool(NoLimit)
	cs7 := constructPointerBool(NoLimit)
	cs8 := constructPointerBool(NoLimit)
	cs9 := constructPointerProcMountType(NoLimit)
	cs10 := constructPointerSeccompProfile(NoLimit)
	cs11 := constructPointerAppArmorProfile(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
		len(cs4),
		len(cs5),
		len(cs6),
		len(cs7),
		len(cs8),
		len(cs9),
		len(cs10),
		len(cs11),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	k4 := 0
	k5 := 0
	k6 := 0
	k7 := 0
	k8 := 0
	k9 := 0
	k10 := 0
	k11 := 0
	for i := range maxCount {
		nc := Case[v1.SecurityContext]{}
		if i/len(cs0) > k0 {
			cs0 = constructPointerCapabilities(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Capabilities = c0.expected
		nc.dst.Capabilities = c0.dst
		nc.src.Capabilities = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructPointerBool(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Privileged = c1.expected
		nc.dst.Privileged = c1.dst
		nc.src.Privileged = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructPointerSELinuxOptions(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.SELinuxOptions = c2.expected
		nc.dst.SELinuxOptions = c2.dst
		nc.src.SELinuxOptions = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructPointerWindowsSecurityContextOptions(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.WindowsOptions = c3.expected
		nc.dst.WindowsOptions = c3.dst
		nc.src.WindowsOptions = c3.src
		if i/len(cs4) > k4 {
			cs4 = constructPointerInt64(NoLimit)
			k4 += 1
		}
		c4 := &cs4[i%len(cs4)]
		nc.expected.RunAsUser = c4.expected
		nc.dst.RunAsUser = c4.dst
		nc.src.RunAsUser = c4.src
		if i/len(cs5) > k5 {
			cs5 = constructPointerInt64(NoLimit)
			k5 += 1
		}
		c5 := &cs5[i%len(cs5)]
		nc.expected.RunAsGroup = c5.expected
		nc.dst.RunAsGroup = c5.dst
		nc.src.RunAsGroup = c5.src
		if i/len(cs6) > k6 {
			cs6 = constructPointerBool(NoLimit)
			k6 += 1
		}
		c6 := &cs6[i%len(cs6)]
		nc.expected.RunAsNonRoot = c6.expected
		nc.dst.RunAsNonRoot = c6.dst
		nc.src.RunAsNonRoot = c6.src
		if i/len(cs7) > k7 {
			cs7 = constructPointerBool(NoLimit)
			k7 += 1
		}
		c7 := &cs7[i%len(cs7)]
		nc.expected.ReadOnlyRootFilesystem = c7.expected
		nc.dst.ReadOnlyRootFilesystem = c7.dst
		nc.src.ReadOnlyRootFilesystem = c7.src
		if i/len(cs8) > k8 {
			cs8 = constructPointerBool(NoLimit)
			k8 += 1
		}
		c8 := &cs8[i%len(cs8)]
		nc.expected.AllowPrivilegeEscalation = c8.expected
		nc.dst.AllowPrivilegeEscalation = c8.dst
		nc.src.AllowPrivilegeEscalation = c8.src
		if i/len(cs9) > k9 {
			cs9 = constructPointerProcMountType(NoLimit)
			k9 += 1
		}
		c9 := &cs9[i%len(cs9)]
		nc.expected.ProcMount = c9.expected
		nc.dst.ProcMount = c9.dst
		nc.src.ProcMount = c9.src
		if i/len(cs10) > k10 {
			cs10 = constructPointerSeccompProfile(NoLimit)
			k10 += 1
		}
		c10 := &cs10[i%len(cs10)]
		nc.expected.SeccompProfile = c10.expected
		nc.dst.SeccompProfile = c10.dst
		nc.src.SeccompProfile = c10.src
		if i/len(cs11) > k11 {
			cs11 = constructPointerAppArmorProfile(NoLimit)
			k11 += 1
		}
		c11 := &cs11[i%len(cs11)]
		nc.expected.AppArmorProfile = c11.expected
		nc.dst.AppArmorProfile = c11.dst
		nc.src.AppArmorProfile = c11.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerCapabilities(p Policy) []Case[*v1.Capabilities] {
	cases := []Case[*v1.Capabilities]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructCapabilities(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.Capabilities]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructCapabilities(p Policy) []Case[v1.Capabilities] {
	cases := []Case[v1.Capabilities]{}
	cs0 := constructAtomicSliceCapability(NoLimit)
	cs1 := constructAtomicSliceCapability(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[v1.Capabilities]{}
		if i/len(cs0) > k0 {
			cs0 = constructAtomicSliceCapability(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Add = c0.expected
		nc.dst.Add = c0.dst
		nc.src.Add = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructAtomicSliceCapability(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Drop = c1.expected
		nc.dst.Drop = c1.dst
		nc.src.Drop = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructAtomicSliceCapability(p Policy) []Case[[]v1.Capability] {
	cases := []Case[[]v1.Capability]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructCapability(NoLimit)
	var nc Case[[]v1.Capability]
	nc = Case[[]v1.Capability]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.src)
		nc.dst = append(nc.dst, c.dst)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.Capability]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.dst)
		nc.dst = append(nc.dst, c.dst)
	}
	nc.src = []v1.Capability{}
	cases = append(cases, nc)
	return cases
}
func constructCapability(p Policy) []Case[v1.Capability] {
	cases := []Case[v1.Capability]{}
	cs := constructString(p)
	for _, c := range cs {
		cases = append(cases, Case[v1.Capability]{
			expected: v1.Capability(c.expected),
			dst:      v1.Capability(c.dst),
			src:      v1.Capability(c.src),
		})
	}
	return cases
}
func constructPointerSELinuxOptions(p Policy) []Case[*v1.SELinuxOptions] {
	cases := []Case[*v1.SELinuxOptions]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructSELinuxOptions(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.SELinuxOptions]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructSELinuxOptions(p Policy) []Case[v1.SELinuxOptions] {
	cases := []Case[v1.SELinuxOptions]{}
	cs0 := constructString(NoLimit)
	cs1 := constructString(NoLimit)
	cs2 := constructString(NoLimit)
	cs3 := constructString(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	for i := range maxCount {
		nc := Case[v1.SELinuxOptions]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.User = c0.expected
		nc.dst.User = c0.dst
		nc.src.User = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Role = c1.expected
		nc.dst.Role = c1.dst
		nc.src.Role = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructString(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.Type = c2.expected
		nc.dst.Type = c2.dst
		nc.src.Type = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructString(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.Level = c3.expected
		nc.dst.Level = c3.dst
		nc.src.Level = c3.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerWindowsSecurityContextOptions(p Policy) []Case[*v1.WindowsSecurityContextOptions] {
	cases := []Case[*v1.WindowsSecurityContextOptions]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructWindowsSecurityContextOptions(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.WindowsSecurityContextOptions]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructWindowsSecurityContextOptions(p Policy) []Case[v1.WindowsSecurityContextOptions] {
	cases := []Case[v1.WindowsSecurityContextOptions]{}
	cs0 := constructPointerString(NoLimit)
	cs1 := constructPointerString(NoLimit)
	cs2 := constructPointerString(NoLimit)
	cs3 := constructPointerBool(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	for i := range maxCount {
		nc := Case[v1.WindowsSecurityContextOptions]{}
		if i/len(cs0) > k0 {
			cs0 = constructPointerString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.GMSACredentialSpecName = c0.expected
		nc.dst.GMSACredentialSpecName = c0.dst
		nc.src.GMSACredentialSpecName = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructPointerString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.GMSACredentialSpec = c1.expected
		nc.dst.GMSACredentialSpec = c1.dst
		nc.src.GMSACredentialSpec = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructPointerString(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.RunAsUserName = c2.expected
		nc.dst.RunAsUserName = c2.dst
		nc.src.RunAsUserName = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructPointerBool(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.HostProcess = c3.expected
		nc.dst.HostProcess = c3.dst
		nc.src.HostProcess = c3.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerProcMountType(p Policy) []Case[*v1.ProcMountType] {
	cases := []Case[*v1.ProcMountType]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructProcMountType(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.ProcMountType]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructProcMountType(p Policy) []Case[v1.ProcMountType] {
	cases := []Case[v1.ProcMountType]{}
	cs := constructString(p)
	for _, c := range cs {
		cases = append(cases, Case[v1.ProcMountType]{
			expected: v1.ProcMountType(c.expected),
			dst:      v1.ProcMountType(c.dst),
			src:      v1.ProcMountType(c.src),
		})
	}
	return cases
}
func constructPointerSeccompProfile(p Policy) []Case[*v1.SeccompProfile] {
	cases := []Case[*v1.SeccompProfile]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructSeccompProfile(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.SeccompProfile]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructSeccompProfile(p Policy) []Case[v1.SeccompProfile] {
	cases := []Case[v1.SeccompProfile]{}
	cs0 := constructSeccompProfileType(NoLimit)
	cs1 := constructPointerString(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[v1.SeccompProfile]{}
		if i/len(cs0) > k0 {
			cs0 = constructSeccompProfileType(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Type = c0.expected
		nc.dst.Type = c0.dst
		nc.src.Type = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructPointerString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.LocalhostProfile = c1.expected
		nc.dst.LocalhostProfile = c1.dst
		nc.src.LocalhostProfile = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructSeccompProfileType(p Policy) []Case[v1.SeccompProfileType] {
	cases := []Case[v1.SeccompProfileType]{}
	cs := constructString(p)
	for _, c := range cs {
		cases = append(cases, Case[v1.SeccompProfileType]{
			expected: v1.SeccompProfileType(c.expected),
			dst:      v1.SeccompProfileType(c.dst),
			src:      v1.SeccompProfileType(c.src),
		})
	}
	return cases
}
func constructPointerAppArmorProfile(p Policy) []Case[*v1.AppArmorProfile] {
	cases := []Case[*v1.AppArmorProfile]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructAppArmorProfile(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.AppArmorProfile]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructAppArmorProfile(p Policy) []Case[v1.AppArmorProfile] {
	cases := []Case[v1.AppArmorProfile]{}
	cs0 := constructAppArmorProfileType(NoLimit)
	cs1 := constructPointerString(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[v1.AppArmorProfile]{}
		if i/len(cs0) > k0 {
			cs0 = constructAppArmorProfileType(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Type = c0.expected
		nc.dst.Type = c0.dst
		nc.src.Type = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructPointerString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.LocalhostProfile = c1.expected
		nc.dst.LocalhostProfile = c1.dst
		nc.src.LocalhostProfile = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructAppArmorProfileType(p Policy) []Case[v1.AppArmorProfileType] {
	cases := []Case[v1.AppArmorProfileType]{}
	cs := constructString(p)
	for _, c := range cs {
		cases = append(cases, Case[v1.AppArmorProfileType]{
			expected: v1.AppArmorProfileType(c.expected),
			dst:      v1.AppArmorProfileType(c.dst),
			src:      v1.AppArmorProfileType(c.src),
		})
	}
	return cases
}
func constructMapSliceEphemeralContainer(p Policy) []Case[[]v1.EphemeralContainer] {
	cases := []Case[[]v1.EphemeralContainer]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructEphemeralContainerIgnore_name(NoLimit)
	var nc Case[[]v1.EphemeralContainer]
	nc = Case[[]v1.EphemeralContainer]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.expected)
		nc.dst = append(nc.dst, c.dst)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.EphemeralContainer]{}
	srcs := []v1.EphemeralContainer{}
	for i, c := range cs {
		switch i % 3 {
		case 0:
			nc.expected = append(nc.expected, c.expected)
			nc.dst = append(nc.dst, c.dst)
			nc.src = append(nc.src, c.src)
		case 1:
			nc.expected = append(nc.expected, c.dst)
			nc.dst = append(nc.dst, c.dst)
		case 2:
			srcs = append(srcs, c.src)
			nc.src = append(nc.src, c.src)
		}
	}
	nc.expected = append(nc.expected, srcs...)
	cases = append(cases, nc)
	nc = Case[[]v1.EphemeralContainer]{}
	srcs = []v1.EphemeralContainer{}
	for i, c := range cs {
		switch i % 2 {
		case 0:
			nc.expected = append(nc.expected, c.dst)
			nc.dst = append(nc.dst, c.dst)
		case 1:
			srcs = append(srcs, c.src)
			nc.src = append(nc.src, c.src)
		}
	}
	nc.expected = append(nc.expected, srcs...)
	cases = append(cases, nc)
	nc = Case[[]v1.EphemeralContainer]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.src)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.EphemeralContainer]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.dst)
		nc.dst = append(nc.dst, c.dst)
	}
	cases = append(cases, nc)
	return cases
}
func constructEphemeralContainerIgnore_name(p Policy) []Case[v1.EphemeralContainer] {
	cases := []Case[v1.EphemeralContainer]{}
	cs0 := constructEphemeralContainerCommonIgnore_name(NoNotEqual | NoZero | NoNil)
	cs1 := constructString(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[v1.EphemeralContainer]{}
		if i/len(cs0) > k0 {
			cs0 = constructEphemeralContainerCommonIgnore_name(NoNotEqual | NoZero | NoNil)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.EphemeralContainerCommon = c0.expected
		nc.dst.EphemeralContainerCommon = c0.dst
		nc.src.EphemeralContainerCommon = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.TargetContainerName = c1.expected
		nc.dst.TargetContainerName = c1.dst
		nc.src.TargetContainerName = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructEphemeralContainerCommonIgnore_name(p Policy) []Case[v1.EphemeralContainerCommon] {
	cases := []Case[v1.EphemeralContainerCommon]{}
	cs0 := constructString(NoNotEqual | NoZero | NoNil)
	cs1 := constructString(NoLimit)
	cs2 := constructAtomicSliceString(NoLimit)
	cs3 := constructAtomicSliceString(NoLimit)
	cs4 := constructString(NoLimit)
	cs5 := constructMapSliceContainerPort(NoLimit)
	cs6 := constructAtomicSliceEnvFromSource(NoLimit)
	cs7 := constructMapSliceEnvVar(NoLimit)
	cs8 := constructResourceRequirements(NoLimit)
	cs9 := constructAtomicSliceContainerResizePolicy(NoLimit)
	cs10 := constructPointerContainerRestartPolicy(NoLimit)
	cs11 := constructMapSliceVolumeMount(NoLimit)
	cs12 := constructMapSliceVolumeDevice(NoLimit)
	cs13 := constructPointerProbe(NoLimit)
	cs14 := constructPointerProbe(NoLimit)
	cs15 := constructPointerProbe(NoLimit)
	cs16 := constructPointerLifecycle(NoLimit)
	cs17 := constructString(NoLimit)
	cs18 := constructTerminationMessagePolicy(NoLimit)
	cs19 := constructPullPolicy(NoLimit)
	cs20 := constructPointerSecurityContext(NoLimit)
	cs21 := constructBool(NoLimit)
	cs22 := constructBool(NoLimit)
	cs23 := constructBool(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
		len(cs4),
		len(cs5),
		len(cs6),
		len(cs7),
		len(cs8),
		len(cs9),
		len(cs10),
		len(cs11),
		len(cs12),
		len(cs13),
		len(cs14),
		len(cs15),
		len(cs16),
		len(cs17),
		len(cs18),
		len(cs19),
		len(cs20),
		len(cs21),
		len(cs22),
		len(cs23),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	k4 := 0
	k5 := 0
	k6 := 0
	k7 := 0
	k8 := 0
	k9 := 0
	k10 := 0
	k11 := 0
	k12 := 0
	k13 := 0
	k14 := 0
	k15 := 0
	k16 := 0
	k17 := 0
	k18 := 0
	k19 := 0
	k20 := 0
	k21 := 0
	k22 := 0
	k23 := 0
	for i := range maxCount {
		nc := Case[v1.EphemeralContainerCommon]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoNotEqual | NoZero | NoNil)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Name = c0.expected
		nc.dst.Name = c0.dst
		nc.src.Name = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Image = c1.expected
		nc.dst.Image = c1.dst
		nc.src.Image = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructAtomicSliceString(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.Command = c2.expected
		nc.dst.Command = c2.dst
		nc.src.Command = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructAtomicSliceString(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.Args = c3.expected
		nc.dst.Args = c3.dst
		nc.src.Args = c3.src
		if i/len(cs4) > k4 {
			cs4 = constructString(NoLimit)
			k4 += 1
		}
		c4 := &cs4[i%len(cs4)]
		nc.expected.WorkingDir = c4.expected
		nc.dst.WorkingDir = c4.dst
		nc.src.WorkingDir = c4.src
		if i/len(cs5) > k5 {
			cs5 = constructMapSliceContainerPort(NoLimit)
			k5 += 1
		}
		c5 := &cs5[i%len(cs5)]
		nc.expected.Ports = c5.expected
		nc.dst.Ports = c5.dst
		nc.src.Ports = c5.src
		if i/len(cs6) > k6 {
			cs6 = constructAtomicSliceEnvFromSource(NoLimit)
			k6 += 1
		}
		c6 := &cs6[i%len(cs6)]
		nc.expected.EnvFrom = c6.expected
		nc.dst.EnvFrom = c6.dst
		nc.src.EnvFrom = c6.src
		if i/len(cs7) > k7 {
			cs7 = constructMapSliceEnvVar(NoLimit)
			k7 += 1
		}
		c7 := &cs7[i%len(cs7)]
		nc.expected.Env = c7.expected
		nc.dst.Env = c7.dst
		nc.src.Env = c7.src
		if i/len(cs8) > k8 {
			cs8 = constructResourceRequirements(NoLimit)
			k8 += 1
		}
		c8 := &cs8[i%len(cs8)]
		nc.expected.Resources = c8.expected
		nc.dst.Resources = c8.dst
		nc.src.Resources = c8.src
		if i/len(cs9) > k9 {
			cs9 = constructAtomicSliceContainerResizePolicy(NoLimit)
			k9 += 1
		}
		c9 := &cs9[i%len(cs9)]
		nc.expected.ResizePolicy = c9.expected
		nc.dst.ResizePolicy = c9.dst
		nc.src.ResizePolicy = c9.src
		if i/len(cs10) > k10 {
			cs10 = constructPointerContainerRestartPolicy(NoLimit)
			k10 += 1
		}
		c10 := &cs10[i%len(cs10)]
		nc.expected.RestartPolicy = c10.expected
		nc.dst.RestartPolicy = c10.dst
		nc.src.RestartPolicy = c10.src
		if i/len(cs11) > k11 {
			cs11 = constructMapSliceVolumeMount(NoLimit)
			k11 += 1
		}
		c11 := &cs11[i%len(cs11)]
		nc.expected.VolumeMounts = c11.expected
		nc.dst.VolumeMounts = c11.dst
		nc.src.VolumeMounts = c11.src
		if i/len(cs12) > k12 {
			cs12 = constructMapSliceVolumeDevice(NoLimit)
			k12 += 1
		}
		c12 := &cs12[i%len(cs12)]
		nc.expected.VolumeDevices = c12.expected
		nc.dst.VolumeDevices = c12.dst
		nc.src.VolumeDevices = c12.src
		if i/len(cs13) > k13 {
			cs13 = constructPointerProbe(NoLimit)
			k13 += 1
		}
		c13 := &cs13[i%len(cs13)]
		nc.expected.LivenessProbe = c13.expected
		nc.dst.LivenessProbe = c13.dst
		nc.src.LivenessProbe = c13.src
		if i/len(cs14) > k14 {
			cs14 = constructPointerProbe(NoLimit)
			k14 += 1
		}
		c14 := &cs14[i%len(cs14)]
		nc.expected.ReadinessProbe = c14.expected
		nc.dst.ReadinessProbe = c14.dst
		nc.src.ReadinessProbe = c14.src
		if i/len(cs15) > k15 {
			cs15 = constructPointerProbe(NoLimit)
			k15 += 1
		}
		c15 := &cs15[i%len(cs15)]
		nc.expected.StartupProbe = c15.expected
		nc.dst.StartupProbe = c15.dst
		nc.src.StartupProbe = c15.src
		if i/len(cs16) > k16 {
			cs16 = constructPointerLifecycle(NoLimit)
			k16 += 1
		}
		c16 := &cs16[i%len(cs16)]
		nc.expected.Lifecycle = c16.expected
		nc.dst.Lifecycle = c16.dst
		nc.src.Lifecycle = c16.src
		if i/len(cs17) > k17 {
			cs17 = constructString(NoLimit)
			k17 += 1
		}
		c17 := &cs17[i%len(cs17)]
		nc.expected.TerminationMessagePath = c17.expected
		nc.dst.TerminationMessagePath = c17.dst
		nc.src.TerminationMessagePath = c17.src
		if i/len(cs18) > k18 {
			cs18 = constructTerminationMessagePolicy(NoLimit)
			k18 += 1
		}
		c18 := &cs18[i%len(cs18)]
		nc.expected.TerminationMessagePolicy = c18.expected
		nc.dst.TerminationMessagePolicy = c18.dst
		nc.src.TerminationMessagePolicy = c18.src
		if i/len(cs19) > k19 {
			cs19 = constructPullPolicy(NoLimit)
			k19 += 1
		}
		c19 := &cs19[i%len(cs19)]
		nc.expected.ImagePullPolicy = c19.expected
		nc.dst.ImagePullPolicy = c19.dst
		nc.src.ImagePullPolicy = c19.src
		if i/len(cs20) > k20 {
			cs20 = constructPointerSecurityContext(NoLimit)
			k20 += 1
		}
		c20 := &cs20[i%len(cs20)]
		nc.expected.SecurityContext = c20.expected
		nc.dst.SecurityContext = c20.dst
		nc.src.SecurityContext = c20.src
		if i/len(cs21) > k21 {
			cs21 = constructBool(NoLimit)
			k21 += 1
		}
		c21 := &cs21[i%len(cs21)]
		nc.expected.Stdin = c21.expected
		nc.dst.Stdin = c21.dst
		nc.src.Stdin = c21.src
		if i/len(cs22) > k22 {
			cs22 = constructBool(NoLimit)
			k22 += 1
		}
		c22 := &cs22[i%len(cs22)]
		nc.expected.StdinOnce = c22.expected
		nc.dst.StdinOnce = c22.dst
		nc.src.StdinOnce = c22.src
		if i/len(cs23) > k23 {
			cs23 = constructBool(NoLimit)
			k23 += 1
		}
		c23 := &cs23[i%len(cs23)]
		nc.expected.TTY = c23.expected
		nc.dst.TTY = c23.dst
		nc.src.TTY = c23.src
		cases = append(cases, nc)
	}
	return cases
}
func constructRestartPolicy(p Policy) []Case[v1.RestartPolicy] {
	cases := []Case[v1.RestartPolicy]{}
	cs := constructString(p)
	for _, c := range cs {
		cases = append(cases, Case[v1.RestartPolicy]{
			expected: v1.RestartPolicy(c.expected),
			dst:      v1.RestartPolicy(c.dst),
			src:      v1.RestartPolicy(c.src),
		})
	}
	return cases
}
func constructDNSPolicy(p Policy) []Case[v1.DNSPolicy] {
	cases := []Case[v1.DNSPolicy]{}
	cs := constructString(p)
	for _, c := range cs {
		cases = append(cases, Case[v1.DNSPolicy]{
			expected: v1.DNSPolicy(c.expected),
			dst:      v1.DNSPolicy(c.dst),
			src:      v1.DNSPolicy(c.src),
		})
	}
	return cases
}
func constructAtomicMapStringToString(p Policy) []Case[map[string]string] {
	cases := []Case[map[string]string]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	keys := constructString(NoNil | NoZero | NoNotEqual)
	vals := constructString(NoLimit)
	keyIndex := 0
	var nc Case[map[string]string]
	for _, val := range vals {
		keyIndex += 1
		if keyIndex >= len(keys) {
			keys = constructString(NoNil | NoZero | NoNotEqual)
			keyIndex = 0
		}
		key := keys[keyIndex]
		nc = Case[map[string]string]{}
		nc.expected = make(map[string]string)
		nc.dst = make(map[string]string)
		nc.src = make(map[string]string)
		nc.expected[key.expected] = val.src
		nc.dst[key.expected] = val.dst
		nc.src[key.expected] = val.src
	}
	cases = append(cases, nc)
	for _, val := range vals {
		keyIndex += 1
		if keyIndex >= len(keys) {
			keys = constructString(NoNil | NoZero | NoNotEqual)
			keyIndex = 0
		}
		key := keys[keyIndex]
		nc = Case[map[string]string]{}
		nc.expected = make(map[string]string)
		nc.dst = make(map[string]string)
		nc.src = make(map[string]string)
		nc.expected[key.expected] = val.dst
		nc.dst[key.expected] = val.dst
	}
	cases = append(cases, nc)
	return cases
}
func constructPointerPodSecurityContext(p Policy) []Case[*v1.PodSecurityContext] {
	cases := []Case[*v1.PodSecurityContext]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructPodSecurityContext(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.PodSecurityContext]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructPodSecurityContext(p Policy) []Case[v1.PodSecurityContext] {
	cases := []Case[v1.PodSecurityContext]{}
	cs0 := constructPointerSELinuxOptions(NoLimit)
	cs1 := constructPointerWindowsSecurityContextOptions(NoLimit)
	cs2 := constructPointerInt64(NoLimit)
	cs3 := constructPointerInt64(NoLimit)
	cs4 := constructPointerBool(NoLimit)
	cs5 := constructAtomicSliceInt64(NoLimit)
	cs6 := constructPointerSupplementalGroupsPolicy(NoLimit)
	cs7 := constructPointerInt64(NoLimit)
	cs8 := constructAtomicSliceSysctl(NoLimit)
	cs9 := constructPointerPodFSGroupChangePolicy(NoLimit)
	cs10 := constructPointerSeccompProfile(NoLimit)
	cs11 := constructPointerAppArmorProfile(NoLimit)
	cs12 := constructPointerPodSELinuxChangePolicy(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
		len(cs4),
		len(cs5),
		len(cs6),
		len(cs7),
		len(cs8),
		len(cs9),
		len(cs10),
		len(cs11),
		len(cs12),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	k4 := 0
	k5 := 0
	k6 := 0
	k7 := 0
	k8 := 0
	k9 := 0
	k10 := 0
	k11 := 0
	k12 := 0
	for i := range maxCount {
		nc := Case[v1.PodSecurityContext]{}
		if i/len(cs0) > k0 {
			cs0 = constructPointerSELinuxOptions(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.SELinuxOptions = c0.expected
		nc.dst.SELinuxOptions = c0.dst
		nc.src.SELinuxOptions = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructPointerWindowsSecurityContextOptions(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.WindowsOptions = c1.expected
		nc.dst.WindowsOptions = c1.dst
		nc.src.WindowsOptions = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructPointerInt64(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.RunAsUser = c2.expected
		nc.dst.RunAsUser = c2.dst
		nc.src.RunAsUser = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructPointerInt64(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.RunAsGroup = c3.expected
		nc.dst.RunAsGroup = c3.dst
		nc.src.RunAsGroup = c3.src
		if i/len(cs4) > k4 {
			cs4 = constructPointerBool(NoLimit)
			k4 += 1
		}
		c4 := &cs4[i%len(cs4)]
		nc.expected.RunAsNonRoot = c4.expected
		nc.dst.RunAsNonRoot = c4.dst
		nc.src.RunAsNonRoot = c4.src
		if i/len(cs5) > k5 {
			cs5 = constructAtomicSliceInt64(NoLimit)
			k5 += 1
		}
		c5 := &cs5[i%len(cs5)]
		nc.expected.SupplementalGroups = c5.expected
		nc.dst.SupplementalGroups = c5.dst
		nc.src.SupplementalGroups = c5.src
		if i/len(cs6) > k6 {
			cs6 = constructPointerSupplementalGroupsPolicy(NoLimit)
			k6 += 1
		}
		c6 := &cs6[i%len(cs6)]
		nc.expected.SupplementalGroupsPolicy = c6.expected
		nc.dst.SupplementalGroupsPolicy = c6.dst
		nc.src.SupplementalGroupsPolicy = c6.src
		if i/len(cs7) > k7 {
			cs7 = constructPointerInt64(NoLimit)
			k7 += 1
		}
		c7 := &cs7[i%len(cs7)]
		nc.expected.FSGroup = c7.expected
		nc.dst.FSGroup = c7.dst
		nc.src.FSGroup = c7.src
		if i/len(cs8) > k8 {
			cs8 = constructAtomicSliceSysctl(NoLimit)
			k8 += 1
		}
		c8 := &cs8[i%len(cs8)]
		nc.expected.Sysctls = c8.expected
		nc.dst.Sysctls = c8.dst
		nc.src.Sysctls = c8.src
		if i/len(cs9) > k9 {
			cs9 = constructPointerPodFSGroupChangePolicy(NoLimit)
			k9 += 1
		}
		c9 := &cs9[i%len(cs9)]
		nc.expected.FSGroupChangePolicy = c9.expected
		nc.dst.FSGroupChangePolicy = c9.dst
		nc.src.FSGroupChangePolicy = c9.src
		if i/len(cs10) > k10 {
			cs10 = constructPointerSeccompProfile(NoLimit)
			k10 += 1
		}
		c10 := &cs10[i%len(cs10)]
		nc.expected.SeccompProfile = c10.expected
		nc.dst.SeccompProfile = c10.dst
		nc.src.SeccompProfile = c10.src
		if i/len(cs11) > k11 {
			cs11 = constructPointerAppArmorProfile(NoLimit)
			k11 += 1
		}
		c11 := &cs11[i%len(cs11)]
		nc.expected.AppArmorProfile = c11.expected
		nc.dst.AppArmorProfile = c11.dst
		nc.src.AppArmorProfile = c11.src
		if i/len(cs12) > k12 {
			cs12 = constructPointerPodSELinuxChangePolicy(NoLimit)
			k12 += 1
		}
		c12 := &cs12[i%len(cs12)]
		nc.expected.SELinuxChangePolicy = c12.expected
		nc.dst.SELinuxChangePolicy = c12.dst
		nc.src.SELinuxChangePolicy = c12.src
		cases = append(cases, nc)
	}
	return cases
}
func constructAtomicSliceInt64(p Policy) []Case[[]int64] {
	cases := []Case[[]int64]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructInt64(NoLimit)
	var nc Case[[]int64]
	nc = Case[[]int64]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.src)
		nc.dst = append(nc.dst, c.dst)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]int64]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.dst)
		nc.dst = append(nc.dst, c.dst)
	}
	nc.src = []int64{}
	cases = append(cases, nc)
	return cases
}
func constructPointerSupplementalGroupsPolicy(p Policy) []Case[*v1.SupplementalGroupsPolicy] {
	cases := []Case[*v1.SupplementalGroupsPolicy]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructSupplementalGroupsPolicy(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.SupplementalGroupsPolicy]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructSupplementalGroupsPolicy(p Policy) []Case[v1.SupplementalGroupsPolicy] {
	cases := []Case[v1.SupplementalGroupsPolicy]{}
	cs := constructString(p)
	for _, c := range cs {
		cases = append(cases, Case[v1.SupplementalGroupsPolicy]{
			expected: v1.SupplementalGroupsPolicy(c.expected),
			dst:      v1.SupplementalGroupsPolicy(c.dst),
			src:      v1.SupplementalGroupsPolicy(c.src),
		})
	}
	return cases
}
func constructAtomicSliceSysctl(p Policy) []Case[[]v1.Sysctl] {
	cases := []Case[[]v1.Sysctl]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructSysctl(NoLimit)
	var nc Case[[]v1.Sysctl]
	nc = Case[[]v1.Sysctl]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.src)
		nc.dst = append(nc.dst, c.dst)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.Sysctl]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.dst)
		nc.dst = append(nc.dst, c.dst)
	}
	nc.src = []v1.Sysctl{}
	cases = append(cases, nc)
	return cases
}
func constructSysctl(p Policy) []Case[v1.Sysctl] {
	cases := []Case[v1.Sysctl]{}
	cs0 := constructString(NoLimit)
	cs1 := constructString(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[v1.Sysctl]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Name = c0.expected
		nc.dst.Name = c0.dst
		nc.src.Name = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Value = c1.expected
		nc.dst.Value = c1.dst
		nc.src.Value = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerPodFSGroupChangePolicy(p Policy) []Case[*v1.PodFSGroupChangePolicy] {
	cases := []Case[*v1.PodFSGroupChangePolicy]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructPodFSGroupChangePolicy(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.PodFSGroupChangePolicy]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructPodFSGroupChangePolicy(p Policy) []Case[v1.PodFSGroupChangePolicy] {
	cases := []Case[v1.PodFSGroupChangePolicy]{}
	cs := constructString(p)
	for _, c := range cs {
		cases = append(cases, Case[v1.PodFSGroupChangePolicy]{
			expected: v1.PodFSGroupChangePolicy(c.expected),
			dst:      v1.PodFSGroupChangePolicy(c.dst),
			src:      v1.PodFSGroupChangePolicy(c.src),
		})
	}
	return cases
}
func constructPointerPodSELinuxChangePolicy(p Policy) []Case[*v1.PodSELinuxChangePolicy] {
	cases := []Case[*v1.PodSELinuxChangePolicy]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructPodSELinuxChangePolicy(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.PodSELinuxChangePolicy]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructPodSELinuxChangePolicy(p Policy) []Case[v1.PodSELinuxChangePolicy] {
	cases := []Case[v1.PodSELinuxChangePolicy]{}
	cs := constructString(p)
	for _, c := range cs {
		cases = append(cases, Case[v1.PodSELinuxChangePolicy]{
			expected: v1.PodSELinuxChangePolicy(c.expected),
			dst:      v1.PodSELinuxChangePolicy(c.dst),
			src:      v1.PodSELinuxChangePolicy(c.src),
		})
	}
	return cases
}
func constructMapSliceLocalObjectReference(p Policy) []Case[[]v1.LocalObjectReference] {
	cases := []Case[[]v1.LocalObjectReference]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructAtomicLocalObjectReferenceIgnore_name(NoLimit)
	var nc Case[[]v1.LocalObjectReference]
	nc = Case[[]v1.LocalObjectReference]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.expected)
		nc.dst = append(nc.dst, c.dst)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.LocalObjectReference]{}
	srcs := []v1.LocalObjectReference{}
	for i, c := range cs {
		switch i % 3 {
		case 0:
			nc.expected = append(nc.expected, c.expected)
			nc.dst = append(nc.dst, c.dst)
			nc.src = append(nc.src, c.src)
		case 1:
			nc.expected = append(nc.expected, c.dst)
			nc.dst = append(nc.dst, c.dst)
		case 2:
			srcs = append(srcs, c.src)
			nc.src = append(nc.src, c.src)
		}
	}
	nc.expected = append(nc.expected, srcs...)
	cases = append(cases, nc)
	nc = Case[[]v1.LocalObjectReference]{}
	srcs = []v1.LocalObjectReference{}
	for i, c := range cs {
		switch i % 2 {
		case 0:
			nc.expected = append(nc.expected, c.dst)
			nc.dst = append(nc.dst, c.dst)
		case 1:
			srcs = append(srcs, c.src)
			nc.src = append(nc.src, c.src)
		}
	}
	nc.expected = append(nc.expected, srcs...)
	cases = append(cases, nc)
	nc = Case[[]v1.LocalObjectReference]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.src)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.LocalObjectReference]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.dst)
		nc.dst = append(nc.dst, c.dst)
	}
	cases = append(cases, nc)
	return cases
}
func constructAtomicLocalObjectReferenceIgnore_name(p Policy) []Case[v1.LocalObjectReference] {
	cases := []Case[v1.LocalObjectReference]{}
	cs0 := constructString(NoNotEqual | NoZero | NoNil)
	maxCount := max(
		len(cs0),
	)
	k0 := 0
	for i := range maxCount {
		nc := Case[v1.LocalObjectReference]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoNotEqual | NoZero | NoNil)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Name = c0.src
		nc.dst.Name = c0.dst
		nc.src.Name = c0.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerAffinity(p Policy) []Case[*v1.Affinity] {
	cases := []Case[*v1.Affinity]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructAffinity(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.Affinity]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructAffinity(p Policy) []Case[v1.Affinity] {
	cases := []Case[v1.Affinity]{}
	cs0 := constructPointerNodeAffinity(NoLimit)
	cs1 := constructPointerPodAffinity(NoLimit)
	cs2 := constructPointerPodAntiAffinity(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	for i := range maxCount {
		nc := Case[v1.Affinity]{}
		if i/len(cs0) > k0 {
			cs0 = constructPointerNodeAffinity(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.NodeAffinity = c0.expected
		nc.dst.NodeAffinity = c0.dst
		nc.src.NodeAffinity = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructPointerPodAffinity(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.PodAffinity = c1.expected
		nc.dst.PodAffinity = c1.dst
		nc.src.PodAffinity = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructPointerPodAntiAffinity(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.PodAntiAffinity = c2.expected
		nc.dst.PodAntiAffinity = c2.dst
		nc.src.PodAntiAffinity = c2.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerNodeAffinity(p Policy) []Case[*v1.NodeAffinity] {
	cases := []Case[*v1.NodeAffinity]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructNodeAffinity(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.NodeAffinity]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructNodeAffinity(p Policy) []Case[v1.NodeAffinity] {
	cases := []Case[v1.NodeAffinity]{}
	cs0 := constructAtomicPointerNodeSelector(NoLimit)
	cs1 := constructAtomicSlicePreferredSchedulingTerm(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[v1.NodeAffinity]{}
		if i/len(cs0) > k0 {
			cs0 = constructAtomicPointerNodeSelector(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.RequiredDuringSchedulingIgnoredDuringExecution = c0.expected
		nc.dst.RequiredDuringSchedulingIgnoredDuringExecution = c0.dst
		nc.src.RequiredDuringSchedulingIgnoredDuringExecution = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructAtomicSlicePreferredSchedulingTerm(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.PreferredDuringSchedulingIgnoredDuringExecution = c1.expected
		nc.dst.PreferredDuringSchedulingIgnoredDuringExecution = c1.dst
		nc.src.PreferredDuringSchedulingIgnoredDuringExecution = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructAtomicPointerNodeSelector(p Policy) []Case[*v1.NodeSelector] {
	cases := []Case[*v1.NodeSelector]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructAtomicNodeSelector(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.NodeSelector]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructAtomicNodeSelector(p Policy) []Case[v1.NodeSelector] {
	cases := []Case[v1.NodeSelector]{}
	cs0 := constructAtomicSliceNodeSelectorTerm(NoLimit)
	maxCount := max(
		len(cs0),
	)
	k0 := 0
	for i := range maxCount {
		nc := Case[v1.NodeSelector]{}
		if i/len(cs0) > k0 {
			cs0 = constructAtomicSliceNodeSelectorTerm(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.NodeSelectorTerms = c0.src
		nc.dst.NodeSelectorTerms = c0.dst
		nc.src.NodeSelectorTerms = c0.src
		cases = append(cases, nc)
	}
	return cases
}
func constructAtomicSliceNodeSelectorTerm(p Policy) []Case[[]v1.NodeSelectorTerm] {
	cases := []Case[[]v1.NodeSelectorTerm]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructAtomicNodeSelectorTerm(NoLimit)
	var nc Case[[]v1.NodeSelectorTerm]
	nc = Case[[]v1.NodeSelectorTerm]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.src)
		nc.dst = append(nc.dst, c.dst)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.NodeSelectorTerm]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.dst)
		nc.dst = append(nc.dst, c.dst)
	}
	nc.src = []v1.NodeSelectorTerm{}
	cases = append(cases, nc)
	return cases
}
func constructAtomicNodeSelectorTerm(p Policy) []Case[v1.NodeSelectorTerm] {
	cases := []Case[v1.NodeSelectorTerm]{}
	cs0 := constructAtomicSliceNodeSelectorRequirement(NoLimit)
	cs1 := constructAtomicSliceNodeSelectorRequirement(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[v1.NodeSelectorTerm]{}
		if i/len(cs0) > k0 {
			cs0 = constructAtomicSliceNodeSelectorRequirement(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.MatchExpressions = c0.src
		nc.dst.MatchExpressions = c0.dst
		nc.src.MatchExpressions = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructAtomicSliceNodeSelectorRequirement(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.MatchFields = c1.src
		nc.dst.MatchFields = c1.dst
		nc.src.MatchFields = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructAtomicSliceNodeSelectorRequirement(p Policy) []Case[[]v1.NodeSelectorRequirement] {
	cases := []Case[[]v1.NodeSelectorRequirement]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructNodeSelectorRequirement(NoLimit)
	var nc Case[[]v1.NodeSelectorRequirement]
	nc = Case[[]v1.NodeSelectorRequirement]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.src)
		nc.dst = append(nc.dst, c.dst)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.NodeSelectorRequirement]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.dst)
		nc.dst = append(nc.dst, c.dst)
	}
	nc.src = []v1.NodeSelectorRequirement{}
	cases = append(cases, nc)
	return cases
}
func constructNodeSelectorRequirement(p Policy) []Case[v1.NodeSelectorRequirement] {
	cases := []Case[v1.NodeSelectorRequirement]{}
	cs0 := constructString(NoLimit)
	cs1 := constructNodeSelectorOperator(NoLimit)
	cs2 := constructAtomicSliceString(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	for i := range maxCount {
		nc := Case[v1.NodeSelectorRequirement]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Key = c0.expected
		nc.dst.Key = c0.dst
		nc.src.Key = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructNodeSelectorOperator(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Operator = c1.expected
		nc.dst.Operator = c1.dst
		nc.src.Operator = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructAtomicSliceString(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.Values = c2.expected
		nc.dst.Values = c2.dst
		nc.src.Values = c2.src
		cases = append(cases, nc)
	}
	return cases
}
func constructNodeSelectorOperator(p Policy) []Case[v1.NodeSelectorOperator] {
	cases := []Case[v1.NodeSelectorOperator]{}
	cs := constructString(p)
	for _, c := range cs {
		cases = append(cases, Case[v1.NodeSelectorOperator]{
			expected: v1.NodeSelectorOperator(c.expected),
			dst:      v1.NodeSelectorOperator(c.dst),
			src:      v1.NodeSelectorOperator(c.src),
		})
	}
	return cases
}
func constructAtomicSlicePreferredSchedulingTerm(p Policy) []Case[[]v1.PreferredSchedulingTerm] {
	cases := []Case[[]v1.PreferredSchedulingTerm]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructPreferredSchedulingTerm(NoLimit)
	var nc Case[[]v1.PreferredSchedulingTerm]
	nc = Case[[]v1.PreferredSchedulingTerm]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.src)
		nc.dst = append(nc.dst, c.dst)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.PreferredSchedulingTerm]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.dst)
		nc.dst = append(nc.dst, c.dst)
	}
	nc.src = []v1.PreferredSchedulingTerm{}
	cases = append(cases, nc)
	return cases
}
func constructPreferredSchedulingTerm(p Policy) []Case[v1.PreferredSchedulingTerm] {
	cases := []Case[v1.PreferredSchedulingTerm]{}
	cs0 := constructInt32(NoLimit)
	cs1 := constructAtomicNodeSelectorTerm(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[v1.PreferredSchedulingTerm]{}
		if i/len(cs0) > k0 {
			cs0 = constructInt32(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Weight = c0.expected
		nc.dst.Weight = c0.dst
		nc.src.Weight = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructAtomicNodeSelectorTerm(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Preference = c1.expected
		nc.dst.Preference = c1.dst
		nc.src.Preference = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerPodAffinity(p Policy) []Case[*v1.PodAffinity] {
	cases := []Case[*v1.PodAffinity]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructPodAffinity(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.PodAffinity]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructPodAffinity(p Policy) []Case[v1.PodAffinity] {
	cases := []Case[v1.PodAffinity]{}
	cs0 := constructAtomicSlicePodAffinityTerm(NoLimit)
	cs1 := constructAtomicSliceWeightedPodAffinityTerm(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[v1.PodAffinity]{}
		if i/len(cs0) > k0 {
			cs0 = constructAtomicSlicePodAffinityTerm(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.RequiredDuringSchedulingIgnoredDuringExecution = c0.expected
		nc.dst.RequiredDuringSchedulingIgnoredDuringExecution = c0.dst
		nc.src.RequiredDuringSchedulingIgnoredDuringExecution = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructAtomicSliceWeightedPodAffinityTerm(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.PreferredDuringSchedulingIgnoredDuringExecution = c1.expected
		nc.dst.PreferredDuringSchedulingIgnoredDuringExecution = c1.dst
		nc.src.PreferredDuringSchedulingIgnoredDuringExecution = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructAtomicSlicePodAffinityTerm(p Policy) []Case[[]v1.PodAffinityTerm] {
	cases := []Case[[]v1.PodAffinityTerm]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructPodAffinityTerm(NoLimit)
	var nc Case[[]v1.PodAffinityTerm]
	nc = Case[[]v1.PodAffinityTerm]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.src)
		nc.dst = append(nc.dst, c.dst)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.PodAffinityTerm]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.dst)
		nc.dst = append(nc.dst, c.dst)
	}
	nc.src = []v1.PodAffinityTerm{}
	cases = append(cases, nc)
	return cases
}
func constructPodAffinityTerm(p Policy) []Case[v1.PodAffinityTerm] {
	cases := []Case[v1.PodAffinityTerm]{}
	cs0 := constructPointerLabelSelector(NoLimit)
	cs1 := constructAtomicSliceString(NoLimit)
	cs2 := constructString(NoLimit)
	cs3 := constructPointerLabelSelector(NoLimit)
	cs4 := constructAtomicSliceString(NoLimit)
	cs5 := constructAtomicSliceString(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
		len(cs4),
		len(cs5),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	k4 := 0
	k5 := 0
	for i := range maxCount {
		nc := Case[v1.PodAffinityTerm]{}
		if i/len(cs0) > k0 {
			cs0 = constructPointerLabelSelector(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.LabelSelector = c0.expected
		nc.dst.LabelSelector = c0.dst
		nc.src.LabelSelector = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructAtomicSliceString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Namespaces = c1.expected
		nc.dst.Namespaces = c1.dst
		nc.src.Namespaces = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructString(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.TopologyKey = c2.expected
		nc.dst.TopologyKey = c2.dst
		nc.src.TopologyKey = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructPointerLabelSelector(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.NamespaceSelector = c3.expected
		nc.dst.NamespaceSelector = c3.dst
		nc.src.NamespaceSelector = c3.src
		if i/len(cs4) > k4 {
			cs4 = constructAtomicSliceString(NoLimit)
			k4 += 1
		}
		c4 := &cs4[i%len(cs4)]
		nc.expected.MatchLabelKeys = c4.expected
		nc.dst.MatchLabelKeys = c4.dst
		nc.src.MatchLabelKeys = c4.src
		if i/len(cs5) > k5 {
			cs5 = constructAtomicSliceString(NoLimit)
			k5 += 1
		}
		c5 := &cs5[i%len(cs5)]
		nc.expected.MismatchLabelKeys = c5.expected
		nc.dst.MismatchLabelKeys = c5.dst
		nc.src.MismatchLabelKeys = c5.src
		cases = append(cases, nc)
	}
	return cases
}
func constructAtomicSliceWeightedPodAffinityTerm(p Policy) []Case[[]v1.WeightedPodAffinityTerm] {
	cases := []Case[[]v1.WeightedPodAffinityTerm]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructWeightedPodAffinityTerm(NoLimit)
	var nc Case[[]v1.WeightedPodAffinityTerm]
	nc = Case[[]v1.WeightedPodAffinityTerm]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.src)
		nc.dst = append(nc.dst, c.dst)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.WeightedPodAffinityTerm]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.dst)
		nc.dst = append(nc.dst, c.dst)
	}
	nc.src = []v1.WeightedPodAffinityTerm{}
	cases = append(cases, nc)
	return cases
}
func constructWeightedPodAffinityTerm(p Policy) []Case[v1.WeightedPodAffinityTerm] {
	cases := []Case[v1.WeightedPodAffinityTerm]{}
	cs0 := constructInt32(NoLimit)
	cs1 := constructPodAffinityTerm(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[v1.WeightedPodAffinityTerm]{}
		if i/len(cs0) > k0 {
			cs0 = constructInt32(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Weight = c0.expected
		nc.dst.Weight = c0.dst
		nc.src.Weight = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructPodAffinityTerm(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.PodAffinityTerm = c1.expected
		nc.dst.PodAffinityTerm = c1.dst
		nc.src.PodAffinityTerm = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerPodAntiAffinity(p Policy) []Case[*v1.PodAntiAffinity] {
	cases := []Case[*v1.PodAntiAffinity]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructPodAntiAffinity(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.PodAntiAffinity]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructPodAntiAffinity(p Policy) []Case[v1.PodAntiAffinity] {
	cases := []Case[v1.PodAntiAffinity]{}
	cs0 := constructAtomicSlicePodAffinityTerm(NoLimit)
	cs1 := constructAtomicSliceWeightedPodAffinityTerm(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[v1.PodAntiAffinity]{}
		if i/len(cs0) > k0 {
			cs0 = constructAtomicSlicePodAffinityTerm(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.RequiredDuringSchedulingIgnoredDuringExecution = c0.expected
		nc.dst.RequiredDuringSchedulingIgnoredDuringExecution = c0.dst
		nc.src.RequiredDuringSchedulingIgnoredDuringExecution = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructAtomicSliceWeightedPodAffinityTerm(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.PreferredDuringSchedulingIgnoredDuringExecution = c1.expected
		nc.dst.PreferredDuringSchedulingIgnoredDuringExecution = c1.dst
		nc.src.PreferredDuringSchedulingIgnoredDuringExecution = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructAtomicSliceToleration(p Policy) []Case[[]v1.Toleration] {
	cases := []Case[[]v1.Toleration]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructToleration(NoLimit)
	var nc Case[[]v1.Toleration]
	nc = Case[[]v1.Toleration]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.src)
		nc.dst = append(nc.dst, c.dst)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.Toleration]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.dst)
		nc.dst = append(nc.dst, c.dst)
	}
	nc.src = []v1.Toleration{}
	cases = append(cases, nc)
	return cases
}
func constructToleration(p Policy) []Case[v1.Toleration] {
	cases := []Case[v1.Toleration]{}
	cs0 := constructString(NoLimit)
	cs1 := constructTolerationOperator(NoLimit)
	cs2 := constructString(NoLimit)
	cs3 := constructTaintEffect(NoLimit)
	cs4 := constructPointerInt64(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
		len(cs4),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	k4 := 0
	for i := range maxCount {
		nc := Case[v1.Toleration]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Key = c0.expected
		nc.dst.Key = c0.dst
		nc.src.Key = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructTolerationOperator(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Operator = c1.expected
		nc.dst.Operator = c1.dst
		nc.src.Operator = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructString(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.Value = c2.expected
		nc.dst.Value = c2.dst
		nc.src.Value = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructTaintEffect(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.Effect = c3.expected
		nc.dst.Effect = c3.dst
		nc.src.Effect = c3.src
		if i/len(cs4) > k4 {
			cs4 = constructPointerInt64(NoLimit)
			k4 += 1
		}
		c4 := &cs4[i%len(cs4)]
		nc.expected.TolerationSeconds = c4.expected
		nc.dst.TolerationSeconds = c4.dst
		nc.src.TolerationSeconds = c4.src
		cases = append(cases, nc)
	}
	return cases
}
func constructTolerationOperator(p Policy) []Case[v1.TolerationOperator] {
	cases := []Case[v1.TolerationOperator]{}
	cs := constructString(p)
	for _, c := range cs {
		cases = append(cases, Case[v1.TolerationOperator]{
			expected: v1.TolerationOperator(c.expected),
			dst:      v1.TolerationOperator(c.dst),
			src:      v1.TolerationOperator(c.src),
		})
	}
	return cases
}
func constructTaintEffect(p Policy) []Case[v1.TaintEffect] {
	cases := []Case[v1.TaintEffect]{}
	cs := constructString(p)
	for _, c := range cs {
		cases = append(cases, Case[v1.TaintEffect]{
			expected: v1.TaintEffect(c.expected),
			dst:      v1.TaintEffect(c.dst),
			src:      v1.TaintEffect(c.src),
		})
	}
	return cases
}
func constructMapSliceHostAlias(p Policy) []Case[[]v1.HostAlias] {
	cases := []Case[[]v1.HostAlias]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructHostAliasIgnore_ip(NoLimit)
	var nc Case[[]v1.HostAlias]
	nc = Case[[]v1.HostAlias]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.expected)
		nc.dst = append(nc.dst, c.dst)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.HostAlias]{}
	srcs := []v1.HostAlias{}
	for i, c := range cs {
		switch i % 3 {
		case 0:
			nc.expected = append(nc.expected, c.expected)
			nc.dst = append(nc.dst, c.dst)
			nc.src = append(nc.src, c.src)
		case 1:
			nc.expected = append(nc.expected, c.dst)
			nc.dst = append(nc.dst, c.dst)
		case 2:
			srcs = append(srcs, c.src)
			nc.src = append(nc.src, c.src)
		}
	}
	nc.expected = append(nc.expected, srcs...)
	cases = append(cases, nc)
	nc = Case[[]v1.HostAlias]{}
	srcs = []v1.HostAlias{}
	for i, c := range cs {
		switch i % 2 {
		case 0:
			nc.expected = append(nc.expected, c.dst)
			nc.dst = append(nc.dst, c.dst)
		case 1:
			srcs = append(srcs, c.src)
			nc.src = append(nc.src, c.src)
		}
	}
	nc.expected = append(nc.expected, srcs...)
	cases = append(cases, nc)
	nc = Case[[]v1.HostAlias]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.src)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.HostAlias]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.dst)
		nc.dst = append(nc.dst, c.dst)
	}
	cases = append(cases, nc)
	return cases
}
func constructHostAliasIgnore_ip(p Policy) []Case[v1.HostAlias] {
	cases := []Case[v1.HostAlias]{}
	cs0 := constructString(NoNotEqual | NoZero | NoNil)
	cs1 := constructAtomicSliceString(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[v1.HostAlias]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoNotEqual | NoZero | NoNil)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.IP = c0.expected
		nc.dst.IP = c0.dst
		nc.src.IP = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructAtomicSliceString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Hostnames = c1.expected
		nc.dst.Hostnames = c1.dst
		nc.src.Hostnames = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerPodDNSConfig(p Policy) []Case[*v1.PodDNSConfig] {
	cases := []Case[*v1.PodDNSConfig]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructPodDNSConfig(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.PodDNSConfig]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructPodDNSConfig(p Policy) []Case[v1.PodDNSConfig] {
	cases := []Case[v1.PodDNSConfig]{}
	cs0 := constructAtomicSliceString(NoLimit)
	cs1 := constructAtomicSliceString(NoLimit)
	cs2 := constructAtomicSlicePodDNSConfigOption(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	for i := range maxCount {
		nc := Case[v1.PodDNSConfig]{}
		if i/len(cs0) > k0 {
			cs0 = constructAtomicSliceString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Nameservers = c0.expected
		nc.dst.Nameservers = c0.dst
		nc.src.Nameservers = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructAtomicSliceString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Searches = c1.expected
		nc.dst.Searches = c1.dst
		nc.src.Searches = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructAtomicSlicePodDNSConfigOption(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.Options = c2.expected
		nc.dst.Options = c2.dst
		nc.src.Options = c2.src
		cases = append(cases, nc)
	}
	return cases
}
func constructAtomicSlicePodDNSConfigOption(p Policy) []Case[[]v1.PodDNSConfigOption] {
	cases := []Case[[]v1.PodDNSConfigOption]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructPodDNSConfigOption(NoLimit)
	var nc Case[[]v1.PodDNSConfigOption]
	nc = Case[[]v1.PodDNSConfigOption]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.src)
		nc.dst = append(nc.dst, c.dst)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.PodDNSConfigOption]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.dst)
		nc.dst = append(nc.dst, c.dst)
	}
	nc.src = []v1.PodDNSConfigOption{}
	cases = append(cases, nc)
	return cases
}
func constructPodDNSConfigOption(p Policy) []Case[v1.PodDNSConfigOption] {
	cases := []Case[v1.PodDNSConfigOption]{}
	cs0 := constructString(NoLimit)
	cs1 := constructPointerString(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
	)
	k0 := 0
	k1 := 0
	for i := range maxCount {
		nc := Case[v1.PodDNSConfigOption]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Name = c0.expected
		nc.dst.Name = c0.dst
		nc.src.Name = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructPointerString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.Value = c1.expected
		nc.dst.Value = c1.dst
		nc.src.Value = c1.src
		cases = append(cases, nc)
	}
	return cases
}
func constructAtomicSlicePodReadinessGate(p Policy) []Case[[]v1.PodReadinessGate] {
	cases := []Case[[]v1.PodReadinessGate]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructPodReadinessGate(NoLimit)
	var nc Case[[]v1.PodReadinessGate]
	nc = Case[[]v1.PodReadinessGate]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.src)
		nc.dst = append(nc.dst, c.dst)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.PodReadinessGate]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.dst)
		nc.dst = append(nc.dst, c.dst)
	}
	nc.src = []v1.PodReadinessGate{}
	cases = append(cases, nc)
	return cases
}
func constructPodReadinessGate(p Policy) []Case[v1.PodReadinessGate] {
	cases := []Case[v1.PodReadinessGate]{}
	cs0 := constructPodConditionType(NoLimit)
	maxCount := max(
		len(cs0),
	)
	k0 := 0
	for i := range maxCount {
		nc := Case[v1.PodReadinessGate]{}
		if i/len(cs0) > k0 {
			cs0 = constructPodConditionType(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.ConditionType = c0.expected
		nc.dst.ConditionType = c0.dst
		nc.src.ConditionType = c0.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPodConditionType(p Policy) []Case[v1.PodConditionType] {
	cases := []Case[v1.PodConditionType]{}
	cs := constructString(p)
	for _, c := range cs {
		cases = append(cases, Case[v1.PodConditionType]{
			expected: v1.PodConditionType(c.expected),
			dst:      v1.PodConditionType(c.dst),
			src:      v1.PodConditionType(c.src),
		})
	}
	return cases
}
func constructPointerPreemptionPolicy(p Policy) []Case[*v1.PreemptionPolicy] {
	cases := []Case[*v1.PreemptionPolicy]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructPreemptionPolicy(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.PreemptionPolicy]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructPreemptionPolicy(p Policy) []Case[v1.PreemptionPolicy] {
	cases := []Case[v1.PreemptionPolicy]{}
	cs := constructString(p)
	for _, c := range cs {
		cases = append(cases, Case[v1.PreemptionPolicy]{
			expected: v1.PreemptionPolicy(c.expected),
			dst:      v1.PreemptionPolicy(c.dst),
			src:      v1.PreemptionPolicy(c.src),
		})
	}
	return cases
}
func constructMapSliceTopologySpreadConstraint(p Policy) []Case[[]v1.TopologySpreadConstraint] {
	cases := []Case[[]v1.TopologySpreadConstraint]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructTopologySpreadConstraintIgnore_topologyKey_whenUnsatisfiable(NoLimit)
	var nc Case[[]v1.TopologySpreadConstraint]
	nc = Case[[]v1.TopologySpreadConstraint]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.expected)
		nc.dst = append(nc.dst, c.dst)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.TopologySpreadConstraint]{}
	srcs := []v1.TopologySpreadConstraint{}
	for i, c := range cs {
		switch i % 3 {
		case 0:
			nc.expected = append(nc.expected, c.expected)
			nc.dst = append(nc.dst, c.dst)
			nc.src = append(nc.src, c.src)
		case 1:
			nc.expected = append(nc.expected, c.dst)
			nc.dst = append(nc.dst, c.dst)
		case 2:
			srcs = append(srcs, c.src)
			nc.src = append(nc.src, c.src)
		}
	}
	nc.expected = append(nc.expected, srcs...)
	cases = append(cases, nc)
	nc = Case[[]v1.TopologySpreadConstraint]{}
	srcs = []v1.TopologySpreadConstraint{}
	for i, c := range cs {
		switch i % 2 {
		case 0:
			nc.expected = append(nc.expected, c.dst)
			nc.dst = append(nc.dst, c.dst)
		case 1:
			srcs = append(srcs, c.src)
			nc.src = append(nc.src, c.src)
		}
	}
	nc.expected = append(nc.expected, srcs...)
	cases = append(cases, nc)
	nc = Case[[]v1.TopologySpreadConstraint]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.src)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.TopologySpreadConstraint]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.dst)
		nc.dst = append(nc.dst, c.dst)
	}
	cases = append(cases, nc)
	return cases
}
func constructTopologySpreadConstraintIgnore_topologyKey_whenUnsatisfiable(p Policy) []Case[v1.TopologySpreadConstraint] {
	cases := []Case[v1.TopologySpreadConstraint]{}
	cs0 := constructInt32(NoLimit)
	cs1 := constructString(NoNotEqual | NoZero | NoNil)
	cs2 := constructUnsatisfiableConstraintAction(NoNotEqual | NoZero | NoNil)
	cs3 := constructPointerLabelSelector(NoLimit)
	cs4 := constructPointerInt32(NoLimit)
	cs5 := constructPointerNodeInclusionPolicy(NoLimit)
	cs6 := constructPointerNodeInclusionPolicy(NoLimit)
	cs7 := constructAtomicSliceString(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
		len(cs3),
		len(cs4),
		len(cs5),
		len(cs6),
		len(cs7),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	k3 := 0
	k4 := 0
	k5 := 0
	k6 := 0
	k7 := 0
	for i := range maxCount {
		nc := Case[v1.TopologySpreadConstraint]{}
		if i/len(cs0) > k0 {
			cs0 = constructInt32(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.MaxSkew = c0.expected
		nc.dst.MaxSkew = c0.dst
		nc.src.MaxSkew = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructString(NoNotEqual | NoZero | NoNil)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.TopologyKey = c1.expected
		nc.dst.TopologyKey = c1.dst
		nc.src.TopologyKey = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructUnsatisfiableConstraintAction(NoNotEqual | NoZero | NoNil)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.WhenUnsatisfiable = c2.expected
		nc.dst.WhenUnsatisfiable = c2.dst
		nc.src.WhenUnsatisfiable = c2.src
		if i/len(cs3) > k3 {
			cs3 = constructPointerLabelSelector(NoLimit)
			k3 += 1
		}
		c3 := &cs3[i%len(cs3)]
		nc.expected.LabelSelector = c3.expected
		nc.dst.LabelSelector = c3.dst
		nc.src.LabelSelector = c3.src
		if i/len(cs4) > k4 {
			cs4 = constructPointerInt32(NoLimit)
			k4 += 1
		}
		c4 := &cs4[i%len(cs4)]
		nc.expected.MinDomains = c4.expected
		nc.dst.MinDomains = c4.dst
		nc.src.MinDomains = c4.src
		if i/len(cs5) > k5 {
			cs5 = constructPointerNodeInclusionPolicy(NoLimit)
			k5 += 1
		}
		c5 := &cs5[i%len(cs5)]
		nc.expected.NodeAffinityPolicy = c5.expected
		nc.dst.NodeAffinityPolicy = c5.dst
		nc.src.NodeAffinityPolicy = c5.src
		if i/len(cs6) > k6 {
			cs6 = constructPointerNodeInclusionPolicy(NoLimit)
			k6 += 1
		}
		c6 := &cs6[i%len(cs6)]
		nc.expected.NodeTaintsPolicy = c6.expected
		nc.dst.NodeTaintsPolicy = c6.dst
		nc.src.NodeTaintsPolicy = c6.src
		if i/len(cs7) > k7 {
			cs7 = constructAtomicSliceString(NoLimit)
			k7 += 1
		}
		c7 := &cs7[i%len(cs7)]
		nc.expected.MatchLabelKeys = c7.expected
		nc.dst.MatchLabelKeys = c7.dst
		nc.src.MatchLabelKeys = c7.src
		cases = append(cases, nc)
	}
	return cases
}
func constructUnsatisfiableConstraintAction(p Policy) []Case[v1.UnsatisfiableConstraintAction] {
	cases := []Case[v1.UnsatisfiableConstraintAction]{}
	cs := constructString(p)
	for _, c := range cs {
		cases = append(cases, Case[v1.UnsatisfiableConstraintAction]{
			expected: v1.UnsatisfiableConstraintAction(c.expected),
			dst:      v1.UnsatisfiableConstraintAction(c.dst),
			src:      v1.UnsatisfiableConstraintAction(c.src),
		})
	}
	return cases
}
func constructPointerNodeInclusionPolicy(p Policy) []Case[*v1.NodeInclusionPolicy] {
	cases := []Case[*v1.NodeInclusionPolicy]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructNodeInclusionPolicy(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.NodeInclusionPolicy]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructNodeInclusionPolicy(p Policy) []Case[v1.NodeInclusionPolicy] {
	cases := []Case[v1.NodeInclusionPolicy]{}
	cs := constructString(p)
	for _, c := range cs {
		cases = append(cases, Case[v1.NodeInclusionPolicy]{
			expected: v1.NodeInclusionPolicy(c.expected),
			dst:      v1.NodeInclusionPolicy(c.dst),
			src:      v1.NodeInclusionPolicy(c.src),
		})
	}
	return cases
}
func constructPointerPodOS(p Policy) []Case[*v1.PodOS] {
	cases := []Case[*v1.PodOS]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructPodOS(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.PodOS]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
func constructPodOS(p Policy) []Case[v1.PodOS] {
	cases := []Case[v1.PodOS]{}
	cs0 := constructOSName(NoLimit)
	maxCount := max(
		len(cs0),
	)
	k0 := 0
	for i := range maxCount {
		nc := Case[v1.PodOS]{}
		if i/len(cs0) > k0 {
			cs0 = constructOSName(NoLimit)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Name = c0.expected
		nc.dst.Name = c0.dst
		nc.src.Name = c0.src
		cases = append(cases, nc)
	}
	return cases
}
func constructOSName(p Policy) []Case[v1.OSName] {
	cases := []Case[v1.OSName]{}
	cs := constructString(p)
	for _, c := range cs {
		cases = append(cases, Case[v1.OSName]{
			expected: v1.OSName(c.expected),
			dst:      v1.OSName(c.dst),
			src:      v1.OSName(c.src),
		})
	}
	return cases
}
func constructMapSlicePodSchedulingGate(p Policy) []Case[[]v1.PodSchedulingGate] {
	cases := []Case[[]v1.PodSchedulingGate]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructPodSchedulingGateIgnore_name(NoLimit)
	var nc Case[[]v1.PodSchedulingGate]
	nc = Case[[]v1.PodSchedulingGate]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.expected)
		nc.dst = append(nc.dst, c.dst)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.PodSchedulingGate]{}
	srcs := []v1.PodSchedulingGate{}
	for i, c := range cs {
		switch i % 3 {
		case 0:
			nc.expected = append(nc.expected, c.expected)
			nc.dst = append(nc.dst, c.dst)
			nc.src = append(nc.src, c.src)
		case 1:
			nc.expected = append(nc.expected, c.dst)
			nc.dst = append(nc.dst, c.dst)
		case 2:
			srcs = append(srcs, c.src)
			nc.src = append(nc.src, c.src)
		}
	}
	nc.expected = append(nc.expected, srcs...)
	cases = append(cases, nc)
	nc = Case[[]v1.PodSchedulingGate]{}
	srcs = []v1.PodSchedulingGate{}
	for i, c := range cs {
		switch i % 2 {
		case 0:
			nc.expected = append(nc.expected, c.dst)
			nc.dst = append(nc.dst, c.dst)
		case 1:
			srcs = append(srcs, c.src)
			nc.src = append(nc.src, c.src)
		}
	}
	nc.expected = append(nc.expected, srcs...)
	cases = append(cases, nc)
	nc = Case[[]v1.PodSchedulingGate]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.src)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.PodSchedulingGate]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.dst)
		nc.dst = append(nc.dst, c.dst)
	}
	cases = append(cases, nc)
	return cases
}
func constructPodSchedulingGateIgnore_name(p Policy) []Case[v1.PodSchedulingGate] {
	cases := []Case[v1.PodSchedulingGate]{}
	cs0 := constructString(NoNotEqual | NoZero | NoNil)
	maxCount := max(
		len(cs0),
	)
	k0 := 0
	for i := range maxCount {
		nc := Case[v1.PodSchedulingGate]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoNotEqual | NoZero | NoNil)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Name = c0.expected
		nc.dst.Name = c0.dst
		nc.src.Name = c0.src
		cases = append(cases, nc)
	}
	return cases
}
func constructMapSlicePodResourceClaim(p Policy) []Case[[]v1.PodResourceClaim] {
	cases := []Case[[]v1.PodResourceClaim]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructPodResourceClaimIgnore_name(NoLimit)
	var nc Case[[]v1.PodResourceClaim]
	nc = Case[[]v1.PodResourceClaim]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.expected)
		nc.dst = append(nc.dst, c.dst)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.PodResourceClaim]{}
	srcs := []v1.PodResourceClaim{}
	for i, c := range cs {
		switch i % 3 {
		case 0:
			nc.expected = append(nc.expected, c.expected)
			nc.dst = append(nc.dst, c.dst)
			nc.src = append(nc.src, c.src)
		case 1:
			nc.expected = append(nc.expected, c.dst)
			nc.dst = append(nc.dst, c.dst)
		case 2:
			srcs = append(srcs, c.src)
			nc.src = append(nc.src, c.src)
		}
	}
	nc.expected = append(nc.expected, srcs...)
	cases = append(cases, nc)
	nc = Case[[]v1.PodResourceClaim]{}
	srcs = []v1.PodResourceClaim{}
	for i, c := range cs {
		switch i % 2 {
		case 0:
			nc.expected = append(nc.expected, c.dst)
			nc.dst = append(nc.dst, c.dst)
		case 1:
			srcs = append(srcs, c.src)
			nc.src = append(nc.src, c.src)
		}
	}
	nc.expected = append(nc.expected, srcs...)
	cases = append(cases, nc)
	nc = Case[[]v1.PodResourceClaim]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.src)
		nc.src = append(nc.src, c.src)
	}
	cases = append(cases, nc)
	nc = Case[[]v1.PodResourceClaim]{}
	for _, c := range cs {
		nc.expected = append(nc.expected, c.dst)
		nc.dst = append(nc.dst, c.dst)
	}
	cases = append(cases, nc)
	return cases
}
func constructPodResourceClaimIgnore_name(p Policy) []Case[v1.PodResourceClaim] {
	cases := []Case[v1.PodResourceClaim]{}
	cs0 := constructString(NoNotEqual | NoZero | NoNil)
	cs1 := constructPointerString(NoLimit)
	cs2 := constructPointerString(NoLimit)
	maxCount := max(
		len(cs0),
		len(cs1),
		len(cs2),
	)
	k0 := 0
	k1 := 0
	k2 := 0
	for i := range maxCount {
		nc := Case[v1.PodResourceClaim]{}
		if i/len(cs0) > k0 {
			cs0 = constructString(NoNotEqual | NoZero | NoNil)
			k0 += 1
		}
		c0 := &cs0[i%len(cs0)]
		nc.expected.Name = c0.expected
		nc.dst.Name = c0.dst
		nc.src.Name = c0.src
		if i/len(cs1) > k1 {
			cs1 = constructPointerString(NoLimit)
			k1 += 1
		}
		c1 := &cs1[i%len(cs1)]
		nc.expected.ResourceClaimName = c1.expected
		nc.dst.ResourceClaimName = c1.dst
		nc.src.ResourceClaimName = c1.src
		if i/len(cs2) > k2 {
			cs2 = constructPointerString(NoLimit)
			k2 += 1
		}
		c2 := &cs2[i%len(cs2)]
		nc.expected.ResourceClaimTemplateName = c2.expected
		nc.dst.ResourceClaimTemplateName = c2.dst
		nc.src.ResourceClaimTemplateName = c2.src
		cases = append(cases, nc)
	}
	return cases
}
func constructPointerResourceRequirements(p Policy) []Case[*v1.ResourceRequirements] {
	cases := []Case[*v1.ResourceRequirements]{
		{
			expected: nil,
			dst:      nil,
			src:      nil,
		},
	}
	cs := constructResourceRequirements(p)
	for _, c := range cs {
		cases = append(cases, Case[*v1.ResourceRequirements]{
			expected: &c.expected,
			dst:      &c.dst,
			src:      &c.src,
		})
	}
	return cases
}
