// Copyright 2024 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package generators

import (
	"io"
	"log/slog"
	"strings"

	"k8s.io/gengo/v2/generator"
	"k8s.io/gengo/v2/namer"
	"k8s.io/gengo/v2/types"
)

// runtimeGenerator produces a file with autogenerated functions.
type runtimeGenerator struct {
	generator.GoGenerator
	targetPackage string
	kind          string
	imports       namer.ImportTracker
}

func NewRuntimeGenerator(outputFilename, kind, targetPackage string) generator.Generator {
	g := &runtimeGenerator{
		GoGenerator: generator.GoGenerator{
			OutputFilename: outputFilename + "." + kind + "." + generator.GoFileType,
		},
		kind:          kind,
		targetPackage: targetPackage,
		imports:       generator.NewImportTrackerForPackage(targetPackage),
	}
	return g
}

// Filter returns true if this Generator cares about this type.
// This will be called for every type which made it through this Package's
// Filter method.
func (g *runtimeGenerator) Filter(_ *generator.Context, t *types.Type) bool {
	name := GroupToInstanceName(t)
	return strings.EqualFold(name, g.kind)
}

func (g *runtimeGenerator) Namers(*generator.Context) namer.NameSystems {
	return namer.NameSystems{
		"pub":         namer.NewPublicNamer(0),
		"instance":    NameFunc(GroupToInstanceName),
		"security":    NameFunc(GroupToSecurityTypeName),
		"tls":         NameFunc(GroupToTLSTypeName),
		"internaltls": NameFunc(GroupToInternalTLSTypeName),
	}
}

func (g *runtimeGenerator) Imports(_ *generator.Context) (imports []string) {
	importLines := []string{
		`"unsafe"`,

		`"k8s.io/apimachinery/pkg/api/meta"`,
		`metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"`,
		`"k8s.io/apimachinery/pkg/runtime"`,
		`"k8s.io/utils/ptr"`,

		`"github.com/pingcap/tidb-operator/api/v2/core/v1alpha1"`,
		`metav1alpha1 "github.com/pingcap/tidb-operator/api/v2/meta/v1alpha1"`,
	}
	importLines = append(importLines, g.imports.ImportLines()...)

	return importLines
}

func (g *runtimeGenerator) GenerateType(c *generator.Context, t *types.Type, w io.Writer) error {
	slog.Info("generate runtime", "type", t.Name.Name)

	if !strings.HasSuffix(t.Name.Name, "Group") {
		return g.generateInstance(c, t, w)
	}
	return g.generateGroup(c, t, w)
}

func (g *runtimeGenerator) generateInstance(c *generator.Context, t *types.Type, w io.Writer) error {
	sw := generator.NewSnippetWriter(w, c, "$", "$")

	sw.Do(`
type (
	$.|pub$      v1alpha1.$.|pub$
)

type $.|pub$Tuple struct{}

var _ InstanceTuple[*v1alpha1.$.|pub$, *$.|pub$] = $.|pub$Tuple{}

func ($.|pub$Tuple) From(t *v1alpha1.$.|pub$) *$.|pub$ {
	return From$.|pub$(t)
}

func ($.|pub$Tuple) FromSlice(t []*v1alpha1.$.|pub$) []*$.|pub$ {
	return From$.|pub$Slice(t)
}

func ($.|pub$Tuple) To(t *$.|pub$) *v1alpha1.$.|pub$ {
	return To$.|pub$(t)
}

func ($.|pub$Tuple) ToSlice(t []*$.|pub$) []*v1alpha1.$.|pub$ {
	return To$.|pub$Slice(t)
}

func From$.|pub$(in *v1alpha1.$.|pub$) *$.|pub$ {
	return (*$.|pub$)(in)
}

func To$.|pub$(in *$.|pub$) *v1alpha1.$.|pub$ {
	return (*v1alpha1.$.|pub$)(in)
}

func From$.|pub$Slice(ins []*v1alpha1.$.|pub$) []*$.|pub$ {
	return *(*[]*$.|pub$)(unsafe.Pointer(&ins))
}

func To$.|pub$Slice(ins []*$.|pub$) []*v1alpha1.$.|pub$ {
	return *(*[]*v1alpha1.$.|pub$)(unsafe.Pointer(&ins))
}

var _ Instance = &$.|pub${}

func (in *$.|pub$) DeepCopyObject() runtime.Object {
	return (*v1alpha1.$.|pub$)(in).DeepCopyObject()
}

func (in *$.|pub$) To() *v1alpha1.$.|pub$ {
	return To$.|pub$(in)
}

func (in *$.|pub$) GetTopology() v1alpha1.Topology {
	return in.Spec.Topology
}

func (in *$.|pub$) SetTopology(t v1alpha1.Topology) {
	in.Spec.Topology = t
}

func (in *$.|pub$) GetUpdateRevision() string {
	if in.Labels == nil {
		return ""
	}
	return in.Labels[v1alpha1.LabelKeyInstanceRevisionHash]
}

func (in *$.|pub$) CurrentRevision() string {
	return in.Status.CurrentRevision
}

func (in *$.|pub$) SetCurrentRevision(rev string) {
	in.Status.CurrentRevision = rev
}

func (in *$.|pub$) IsReady() bool {
	cond := meta.FindStatusCondition(in.Status.Conditions, v1alpha1.CondReady)
	if cond == nil {
		return false
	}
	if cond.ObservedGeneration != in.GetGeneration() {
		return false
	}
	return cond.Status == metav1.ConditionTrue
}

func (in *$.|pub$) IsUpToDate() bool {
	return in.Status.ObservedGeneration == in.GetGeneration() && in.GetUpdateRevision() == in.Status.CurrentRevision
}

func (in *$.|pub$) Conditions() []metav1.Condition {
	return in.Status.Conditions
}

func (in *$.|pub$) SetConditions(conds []metav1.Condition) {
	in.Status.Conditions = conds
}

func (in *$.|pub$) ObservedGeneration() int64 {
	return in.Status.ObservedGeneration
}

func (in *$.|pub$) SetObservedGeneration(gen int64) {
	in.Status.ObservedGeneration = gen
}

func (in *$.|pub$) SetCluster(cluster string) {
	in.Spec.Cluster.Name = cluster
}

func (in *$.|pub$) Cluster() string {
	return in.Spec.Cluster.Name
}

func (*$.|pub$) Component() string {
	return v1alpha1.LabelValComponent$.|pub$
}

func (in *$.|pub$) PodOverlay() *v1alpha1.PodOverlay {
	if in.Spec.Overlay == nil {
		return nil
	}
	return in.Spec.Overlay.Pod
}

func (in *$.|pub$) Features() []metav1alpha1.Feature {
	return in.Spec.Features
}

func (in *$.|pub$) SetVersion(version string) {
	in.Spec.Version = version
}

func (in *$.|pub$) Version() string {
	return in.Spec.Version
}

func (in *$.|pub$) SetImage(image string) {
	in.Spec.Image = ptr.To(image)
}

func (in *$.|pub$) Subdomain() string {
	return in.Spec.Subdomain
}

func (in *$.|pub$) ClusterCertKeyPairSecretName() string {
	sec := in.Spec.Security
	if sec != nil && sec.TLS != nil && sec.TLS.Cluster != nil && sec.TLS.Cluster.CertKeyPair != nil {
		return sec.TLS.Cluster.CertKeyPair.Name
	}
	prefix, _ := NamePrefixAndSuffix(in.GetName())
	return prefix + "-" + in.Component() + "-cluster-secret"
}

func (in *$.|pub$) ClusterCASecretName() string {
	sec := in.Spec.Security
	if sec != nil && sec.TLS != nil && sec.TLS.Cluster != nil && sec.TLS.Cluster.CA != nil {
		return sec.TLS.Cluster.CA.Name
	}
	prefix, _ := NamePrefixAndSuffix(in.GetName())
	return prefix + "-" + in.Component() + "-cluster-secret"
}

func (in *$.|pub$) ClientCertKeyPairSecretName() string {
	sec := in.Spec.Security
	if sec != nil && sec.TLS != nil && sec.TLS.Client != nil && sec.TLS.Client.CertKeyPair != nil {
		return sec.TLS.Client.CertKeyPair.Name
	}
	return in.Cluster() + "-cluster-client-secret"
}

func (in *$.|pub$) ClientCASecretName() string {
	sec := in.Spec.Security
	if sec != nil && sec.TLS != nil && sec.TLS.Client != nil && sec.TLS.Client.CA != nil {
		return sec.TLS.Client.CA.Name
	}
	return in.Cluster() + "-cluster-client-secret"
}

func (in *$.|pub$) ClientInsecureSkipTLSVerify() bool {
	sec := in.Spec.Security
	if sec != nil && sec.TLS != nil && sec.TLS.Client != nil && sec.TLS.Client.CA != nil {
		return sec.TLS.Client.InsecureSkipTLSVerify
	}
	return false
}
`, t)

	// Generate Store interface methods for TiKV and TiFlash
	if strings.EqualFold(t.Name.Name, "TiKV") || strings.EqualFold(t.Name.Name, "TiFlash") {
		sw.Do(`
func (in *$.|pub$) IsOffline() bool {
	return in.Spec.Offline
}

func (in *$.|pub$) IsStore() bool {
	return true
}
`, t)
	} else {
		sw.Do(`
func (in *$.|pub$) IsOffline() bool {
	return false
}

func (in *$.|pub$) IsStore() bool {
	return false
}
`, t)
	}

	return sw.Error()
}

func (g *runtimeGenerator) generateGroup(c *generator.Context, t *types.Type, w io.Writer) error {
	sw := generator.NewSnippetWriter(w, c, "$", "$")

	sw.Do(`
type (
	$.|pub$ v1alpha1.$.|pub$
)

type $.|pub$Tuple struct{}

var _ GroupTuple[*v1alpha1.$.|pub$, *$.|pub$] = $.|pub$Tuple{}

func ($.|pub$Tuple) From(t *v1alpha1.$.|pub$) *$.|pub$ {
	return From$.|pub$(t)
}

func ($.|pub$Tuple) FromSlice(t []*v1alpha1.$.|pub$) []*$.|pub$ {
	return From$.|pub$Slice(t)
}

func ($.|pub$Tuple) To(t *$.|pub$) *v1alpha1.$.|pub$ {
	return To$.|pub$(t)
}

func ($.|pub$Tuple) ToSlice(t []*$.|pub$) []*v1alpha1.$.|pub$ {
	return To$.|pub$Slice(t)
}

func From$.|pub$(g *v1alpha1.$.|pub$) *$.|pub$ {
	return (*$.|pub$)(g)
}

func To$.|pub$(g *$.|pub$) *v1alpha1.$.|pub$ {
	return (*v1alpha1.$.|pub$)(g)
}

func From$.|pub$Slice(gs []*v1alpha1.$.|pub$) []*$.|pub$ {
	return *(*[]*$.|pub$)(unsafe.Pointer(&gs))
}

func To$.|pub$Slice(gs []*$.|pub$) []*v1alpha1.$.|pub$ {
	return *(*[]*v1alpha1.$.|pub$)(unsafe.Pointer(&gs))
}

var _ Group = &$.|pub${}

func (g *$.|pub$) DeepCopyObject() runtime.Object {
	return (*v1alpha1.$.|pub$)(g)
}

func (g *$.|pub$) To() *v1alpha1.$.|pub$ {
	return To$.|pub$(g)
}

func (g *$.|pub$) SetReplicas(replicas int32) {
	g.Spec.Replicas = &replicas
}

func (g *$.|pub$) Replicas() int32 {
	if g.Spec.Replicas == nil {
		return 1
	}
	return *g.Spec.Replicas
}

func (g *$.|pub$) SetVersion(version string) {
	g.Spec.Template.Spec.Version = version
}

func (g *$.|pub$) Version() string {
	return g.Spec.Template.Spec.Version
}

func (g *$.|pub$) SetImage(image string) {
	g.Spec.Template.Spec.Image = ptr.To(image)
}

func (g *$.|pub$) SetCluster(cluster string) {
	g.Spec.Cluster.Name = cluster
}

func (g *$.|pub$) Cluster() string {
	return g.Spec.Cluster.Name
}

func (*$.|pub$) Component() string {
	return v1alpha1.LabelValComponent$.|instance$
}

func (g *$.|pub$) Conditions() []metav1.Condition {
	return g.Status.Conditions
}

func (g *$.|pub$) SetConditions(conds []metav1.Condition) {
	g.Status.Conditions = conds
}

func (g *$.|pub$) ObservedGeneration() int64 {
	return g.Status.ObservedGeneration
}

func (g *$.|pub$) SetObservedGeneration(gen int64) {
	g.Status.ObservedGeneration = gen
}

func (g *$.|pub$) SetStatusVersion(version string) {
	g.Status.Version = version
}

func (g *$.|pub$) StatusVersion() string {
	return g.Status.Version
}

func (g *$.|pub$) SetStatusReplicas(replicas, ready, update, current int32) {
	g.Status.Replicas = replicas
	g.Status.ReadyReplicas = ready
	g.Status.UpdatedReplicas = update
	g.Status.CurrentReplicas = current
}

func (g *$.|pub$) StatusReplicas() (replicas, ready, update, current int32) {
	return g.Status.Replicas,
		g.Status.ReadyReplicas,
		g.Status.UpdatedReplicas,
		g.Status.CurrentReplicas
}

func (g *$.|pub$) SetStatusRevision(update, current string, collisionCount *int32) {
	g.Status.UpdateRevision = update
	g.Status.CurrentRevision = current
	g.Status.CollisionCount = collisionCount
}

func (g *$.|pub$) StatusRevision() (update, current string, collisionCount *int32) {
	return g.Status.UpdateRevision,
		g.Status.CurrentRevision,
		g.Status.CollisionCount
}

func (g *$.|pub$) SetStatusSelector(l string) {
	g.Status.Selector = l
}

func (g *$.|pub$) StatusSelector() string {
	return g.Status.Selector
}

func (g *$.|pub$) TemplateLabels() map[string]string {
	return g.Spec.Template.Labels
}

func (g *$.|pub$) TemplateAnnotations() map[string]string {
	return g.Spec.Template.Annotations
}

func (g *$.|pub$) Features() []metav1alpha1.Feature {
	return g.Spec.Features
}

func (g *$.|pub$) SetTemplateClusterTLS(ca, certKeyPair string) {
	if g.Spec.Template.Spec.Security == nil {
		g.Spec.Template.Spec.Security = &v1alpha1.$.|security${}
	}
	sec := g.Spec.Template.Spec.Security
	if sec.TLS == nil {
		sec.TLS = &v1alpha1.$.|tls${}
	}
	sec.TLS.Cluster = &v1alpha1.$.|internaltls${}
	if ca != "" {
		sec.TLS.Cluster.CA = &v1alpha1.CAReference {
			Name: ca,
		}
	}
	if certKeyPair != "" {
		sec.TLS.Cluster.CertKeyPair = &v1alpha1.CertKeyPairReference{
			Name: certKeyPair,
		}
	}
}

func (g *$.|pub$) ClusterCertKeyPairSecretName() string {
	defaultName := g.Name + "-" + g.Component() + "-cluster-secret"
	sec := g.Spec.Template.Spec.Security
	if sec != nil && sec.TLS != nil && sec.TLS.Cluster != nil && sec.TLS.Cluster.CertKeyPair != nil {
		return sec.TLS.Cluster.CertKeyPair.Name
	}
	return defaultName
}

func (g *$.|pub$) ClusterCASecretName() string {
	defaultName := g.Name + "-" + g.Component() + "-cluster-secret"
	sec := g.Spec.Template.Spec.Security
	if sec != nil && sec.TLS != nil && sec.TLS.Cluster != nil && sec.TLS.Cluster.CA != nil {
		return sec.TLS.Cluster.CA.Name
	}
	return defaultName
}

func (g *$.|pub$) ClientCertKeyPairSecretName() string {
	sec := g.Spec.Template.Spec.Security
	if sec != nil && sec.TLS != nil && sec.TLS.Client != nil && sec.TLS.Client.CertKeyPair != nil {
		return sec.TLS.Client.CertKeyPair.Name
	}
	return g.Cluster() + "-cluster-client-secret"
}

func (g *$.|pub$) ClientCASecretName() string {
	sec := g.Spec.Template.Spec.Security
	if sec != nil && sec.TLS != nil && sec.TLS.Client != nil && sec.TLS.Client.CA != nil {
		return sec.TLS.Client.CA.Name
	}
	return g.Cluster() + "-cluster-client-secret"
}

func (g *$.|pub$) ClientInsecureSkipTLSVerify() bool {
	sec := g.Spec.Template.Spec.Security
	if sec != nil && sec.TLS != nil && sec.TLS.Client != nil && sec.TLS.Client.CA != nil {
		return sec.TLS.Client.InsecureSkipTLSVerify
	}
	return false
}
`, t)

	return sw.Error()
}
