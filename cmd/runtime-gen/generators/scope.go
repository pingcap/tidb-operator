// Copyright 2024 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package generators

import (
	"io"
	"log/slog"
	"strings"

	"k8s.io/gengo/v2/generator"
	"k8s.io/gengo/v2/namer"
	"k8s.io/gengo/v2/types"
)

// scopeGenerator produces a file with autogenerated functions.
type scopeGenerator struct {
	generator.GoGenerator
	targetPackage string
	kind          string
	imports       namer.ImportTracker
}

func NewScopeGenerator(outputFilename, kind, targetPackage string) generator.Generator {
	g := &scopeGenerator{
		GoGenerator: generator.GoGenerator{
			OutputFilename: outputFilename + "." + kind + "." + generator.GoFileType,
		},
		kind:          kind,
		targetPackage: targetPackage,
		imports:       generator.NewImportTrackerForPackage(targetPackage),
	}
	return g
}

// Filter returns true if this Generator cares about this type.
// This will be called for every type which made it through this Package's
// Filter method.
func (g *scopeGenerator) Filter(_ *generator.Context, t *types.Type) bool {
	name := GroupToInstanceName(t)
	return strings.EqualFold(name, g.kind)
}

func (g *scopeGenerator) Namers(*generator.Context) namer.NameSystems {
	return namer.NameSystems{
		"pub":      namer.NewPublicNamer(0),
		"instance": NameFunc(GroupToInstanceName),
	}
}

func (g *scopeGenerator) Imports(_ *generator.Context) (imports []string) {
	importLines := []string{
		`"k8s.io/apimachinery/pkg/runtime/schema"`,
		`"github.com/pingcap/tidb-operator/api/v2/core/v1alpha1"`,
		`"github.com/pingcap/tidb-operator/pkg/runtime"`,
	}
	importLines = append(importLines, g.imports.ImportLines()...)

	return importLines
}

func (g *scopeGenerator) GenerateType(c *generator.Context, t *types.Type, w io.Writer) error {
	slog.Info("generate scope", "type", t.Name.Name)

	if !strings.HasSuffix(t.Name.Name, "Group") {
		return g.generateInstance(c, t, w)
	}
	return g.generateGroup(c, t, w)
}

func (g *scopeGenerator) generateInstance(c *generator.Context, t *types.Type, w io.Writer) error {
	sw := generator.NewSnippetWriter(w, c, "$", "$")

	sw.Do(`
type (
	$.|pub$ struct{}
)

func ($.|pub$) From(f *v1alpha1.$.|pub$) *runtime.$.|pub$ {
	return runtime.From$.|pub$(f)
}

func ($.|pub$) To(t *runtime.$.|pub$) *v1alpha1.$.|pub$ {
	return runtime.To$.|pub$(t)
}

func ($.|pub$) Component() string {
	return v1alpha1.LabelValComponent$.|pub$
}

func ($.|pub$) GVK() schema.GroupVersionKind {
	return v1alpha1.SchemeGroupVersion.WithKind("$.|pub$")
}

func ($.|pub$) NewList() *v1alpha1.$.|pub$List {
	return &v1alpha1.$.|pub$List{}
}

func ($.|pub$) GetItems(l *v1alpha1.$.|pub$List) []*v1alpha1.$.|pub$ {
	items := make([]*v1alpha1.$.|pub$, 0, len(l.Items))
	for i := range l.Items {
		items = append(items, &l.Items[i])
	}
	return items
}
`, t)

	return sw.Error()
}

func (g *scopeGenerator) generateGroup(c *generator.Context, t *types.Type, w io.Writer) error {
	sw := generator.NewSnippetWriter(w, c, "$", "$")

	sw.Do(`
type $.|pub$ struct{}

func ($.|pub$) From(f *v1alpha1.$.|pub$) *runtime.$.|pub$ {
	return runtime.From$.|pub$(f)
}

func ($.|pub$) To(t *runtime.$.|pub$) *v1alpha1.$.|pub$ {
	return runtime.To$.|pub$(t)
}

func ($.|pub$) Component() string {
	return v1alpha1.LabelValComponent$.|instance$
}

func ($.|pub$) GVK() schema.GroupVersionKind {
	return v1alpha1.SchemeGroupVersion.WithKind("$.|pub$")
}

func ($.|pub$) NewList() *v1alpha1.$.|pub$List {
	return &v1alpha1.$.|pub$List{}
}

func ($.|pub$) GetItems(l *v1alpha1.$.|pub$List) []*v1alpha1.$.|pub$ {
	items := make([]*v1alpha1.$.|pub$, 0, len(l.Items))
	for i := range l.Items {
		items = append(items, &l.Items[i])
	}
	return items
}

func ($.|pub$) Instance() $.|instance$ {
	return $.|instance${}
}
`, t)

	return sw.Error()
}
